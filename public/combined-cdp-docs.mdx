
<!-- File: /Users/tinahe/docs/projects/mesh/docs/api-data.mdx -->

---
title: "Data API Overview"
sidebar_label: "Data API"
slug: "api-data"
---

The Data API provides the ability to access blocks, transactions, and balances of any blockchain in a standard format.

> For a full list of expectations of any Mesh API implementation, see the documents in the Expectations section. We also recommend the list of [Common Mistakes](/mesh/docs/common-mistakes) that implementers tend to make when meeting these expectations.

## Flow of Operations

<img src={require('../assets/images/data-api-flow-of-operations.jpg').default} alt="Sample flows using the Data API such as getting an on-chain account balance or a transaction from the mempool." />

## Effortless Exchange Support

For developers of new blockchain projects, the Data API makes it easier to integrate with exchanges that support the Mesh API (like Coinbase). This can dramatically speed up the time it takes exchanges to integrate with new blockchains without making compromises that could put customer funds at risk.

## Unified Abstraction for All Blockchains

The number of blockchains has grown dramatically in recent years, and with it has come a proliferation of different APIs that must be used to access blocks, transactions, and balances. Often, it is with good reason that blockchain teams introduce new mechanisms to retrieve blockchain data as new blockchains often introduce new abstractions that don't fit cleanly into existing models. Other times, blockchain teams don't know what developers would prefer and choose to model access to their blockchain in the way that they would expect to be most convenient based on some approach another blockchain takes.

We do not believe it is possible to cram all possible models of blockchain data into a perfect one-size-fits-all abstraction (there will always be nuance and new approaches that push the envelope of any abstraction). And yet, we firmly believe the standard endpoints, standard structure of data, and standard communication protocol specified in the Data API go a long way in making blockchain integration much faster, easier, and reliable for everyone involved.

## Instant Ecosystem

For the broader community of crypto developers, the Data API makes it easier to build cross-blockchain applications such as block explorers, wallets and apps. Instead of writing custom parsing for every blockchain, applications can use a blockchain project’s Mesh API implementation to read all interesting information, minimizing code and simplifying maintenance.

> If you have any questions about the Data API, reach out in our [Discord](https://discord.com/invite/cdp)!



<!-- File: /Users/tinahe/docs/projects/mesh/docs/principles.mdx -->

---
title: "Principles"
sidebar_label: "Principles"
slug: "principles"
---

Mesh is a universal layer for interacting with blockchains, regardless of the blockchain specifics. Mesh standardizes and structures deployment, communication, and data formats while providing extensive flexibility to developers to innovate without needing to appeal to a gatekeeper.

## Standard Data Format

The Mesh API is specified in the [OpenAPI 3.0 format](https://www.openapis.org). Requests and responses can be crafted with autogenerated code using [Swagger Codegen](https://swagger.io/tools/swagger-codegen) or [OpenAPI Generator](https://openapi-generator.tech). You can find the downloadable JSON spec in the [mesh-specifications](https://github.com/coinbase/mesh-specifications) repository in GitHub.

## No Required Languages

Because all usage occurs over a JSON-based specification instead of through some specialized protocol, or relies on an SDK (with support in only a few languages), it is possible to provide an implementation of the Mesh APIs in any language.

## No Master Repository

When creating an implementation of the Mesh APIs, there is no repository where finished implementations must be merged. Any developer can use an implementation of the Mesh APIs for a particular blockchain if they determine it meets their needs. Multiple teams can create implementations for a given blockchain and no implementation will be given preference for gaining favor with the repository maintainer.

## Universal Transactions

Transacting on blockchains today poses unique challenges. Each often requires unique context to do well. For example, recognizing and accounting for a staking transaction on-chain can involve making multiple RPC requests and combining the results of multiple data models. Constructing a staking transaction may require fetching a collection of on-chain data and an understanding of a particular SDK used to construct transactions for that particular network.

In Mesh, a single abstraction is used to represent on-chain activity and to construct transactions. There is only one notion of an [account](./identifiers.md#accountidentifier), [transaction](./identifiers.md#transaction), and [transaction operation](./identifiers.md#operation) for both reading and writing from a blockchain. This single notion is used for all blockchains with Mesh implementations.

The [Data API](./api-data.mdx) and [Construction API](./api-construction.mdx) share a standard data format that is based on a series of low-level abstractions. These abstractions can be combined to form the building blocks of more complex operations. However, these formats are generic enough to natively support [sharded blockchains](#sharded-blockchain-support), [staking, and smart contracts](#staking-and-smart-contract-support).

Other complex operations that Mesh's low-level abstractions simplify are transaction fees. It's complicated to represent a fee payment as a transaction property in blockchains where there is no explicit fee payer, where there are multiple fee payers, where fees can be paid in multiple currencies, or where fee payment is made by one of many parties in a transaction. This is why, with Mesh's API, all transaction fees are represented exclusively as operations.

## Sharded Blockchain Support

To support sharding, Mesh introduces the [sub-network](./identifiers.md#subnetworkidentifier) identifier, which allows developers to specify a particular sub-network on any request to the [Data API](./api-data.mdx). This allows for very explicit querying of blockchain data across a vast network of shards.

## Staking and Smart Contract Support

When designing Mesh, we considered seamless interaction with staking mechanisms and powerful contracts to be a critical feature. To provide first-class support for these paradigms, the [mesh-specifications](https://github.com/coinbase/mesh-specifications) define a very expressive notion of accounts that can be used in blockchain data and in account balance queries.

In blockchains with generalized smart contracting, the notion of account state can be much more nuanced than a single token balance at a single height at a single address. The specifications introduce the [sub-accounts](./identifiers.md#subaccountidentifier) identifier to allow developers to identify a state that is specific to a certain contract or lockup restriction (for example, a delegated stake or payment channel). It is possible to specify an account's sub-account in any block operation, in a request to get a balance, and in transaction construction.

## Modules

For blockchains with smart contracts, it is usually not possible to add high fidelity support for each deployed contract to the "core" Mesh implementation. Accessing any contract often requires generating some SDK and making very contract-specific access decisions that can introduce significant complexity into the "core" implementation.

To empower developers to build Mesh API implementations for a given smart contract on top of your "core" implementation, we recommend implementing the <ins>[`/call`](/mesh/reference/call)</ins> endpoint and providing support for common network-specific endpoints that would be used to read or modify contract state. In theory, you could stack any number of Mesh API implementations on top of each other, where each child implementation calls some set of primitives exposed in this `/call` endpoint.

In the case of Ethereum, a group of developers could implement a core `mesh-ethereum` implementation that provides the ability to track and create ETH transfers, while another group of developers could write a `mesh-erc20` that allows for tracking and creating ERC-20 token transfers using the `eth_call` method exposed by `mesh-ethereum`. Another group of developers could write an implementation that tracks DEX trades, lending activity, or even validator performance. You can see an example of how this would work in the following illustration:

<figcaption><b>Click to enlarge</b></figcaption><img src={require('../assets/images/mesh-modules.png').default} alt="Two implementations. One of mesh-ethereum that tracks and creates ETH transfers, and one of mesh-erc20 that tracks and creates ERC-20 token transfers using the eth_call method exposed by rosetta-ethereum." />





<!-- File: /Users/tinahe/docs/projects/mesh/docs/api-construction.mdx -->

---
title: "Construction API Overview"
sidebar_label: "Construction API"
slug: "api-construction"
---

Just as the Data API provides the ability to read data from a blockchain in a standard format, the Construction API enables developers to write to a blockchain (i.e., construct transactions) in a standard format. To meet strict security standards, implementations are expected to be stateless, operate entirely offline, and support detached key generation and signing.

For a full list of expectations of any Mesh API implementation, refer to the [Best Practices](./docker-deployment.md) section. We also recommend taking a look at the [Common Mistakes](./common-mistakes.md) document for a list of some of the mistakes implementers make when meeting these expectations.

## Flow of Operations

<img src={require('../assets/images/construction-api-flow-of-operations.jpg').default}  alt="Sample flows using the Construction API such as constructing a payload or submitting a transaction." />

## Standard Format

Rather than defining a new set of types to construct transactions, the Construction API uses the same set of types as the Data API. Just as you would read a stream of [operations](./identifiers.md#operation) to a blockchain using the Data API, you can write a stream of operations to the blockchain using the Construction API.

With the same expressiveness as on-chain activity, this standardized format allows for the construction of complex transactions with a general abstraction. Feasibly, you could take the operations observed on-chain using the Data API and construct a new transaction using them (after changing the fields).

Naturally, it is not possible to fully specify everything that will occur in a transaction in many cases (especially in blockchains with invoked events) but it is still possible to deterministically specify intent. Specifying a transfer with a given fee is straightforward enough but specifying a complicated contract invocation is not possible. There is an expectation that what is observed on-chain using the Data API will be a superset of what was provided during construction (not necessarily a strict superset because sometimes it is possible to fully specify a transaction).

It is up to the implementer to responsibly error when a request may lead to non-deterministic transaction construction. One of the largest efforts of the automated testing currently under development is to test this edge case extensively.

## Stateless Execution

Construction API implementations must not keep any state. For example, Construction API implementations must not assume that they can persist data to help with transaction construction between calls. Each invocation of a function in the Construction API will be a fresh invocation in a new execution environment (all information needed in later calls must be confined to the responses).

## Completely Offline

Construction API implementations will be expected to run in a completely offline environment. However, many blockchains require dynamic information to construct valid transactions (for example, account nonce or recent block hash). Any metadata required for transaction construction can be retrieved by creating a request that must be made to the `/construction/metadata` endpoint in the Data API. This explicit connectivity boundary allows for comprehensive auditing of all communication that occurs during transaction construction.

It is likely that developers in the community will build on top of these low level constructs to provide tooling that performs online construction (hiding this metadata fetch) while retaining the ability to construct transactions with the Mesh operations.

## Detached Key Generation and Transaction Signing

The Construction API exclusively supports detached key management (for example, key generation and signing). At a high level, this means that Construction API implementations provide a series of payloads to sign during construction instead of signing transactions directly with some provided key. It is up to the the user of the Construction API implementation to return a correctly formatted signature to the implementation (the format of each signature type is explicitly specified).

> Check out the [keys](https://github.com/coinbase/mesh-sdk-go/tree/master/keys) package in `mesh-sdk-go` for an example of a Construction API-compatible signer.

It is likely that developers in the community will build modules that allow for signing these Mesh-based payloads in many languages (especially for mobile wallet support). This would allow for a [Coinbase Wallet SDK](https://github.com/coinbase/coinbase-wallet-sdk)-like experience for any blockchain (not just for web3-compatible ones).

> If you have any questions about the Construction API, reach out in our [Discord](https://discord.com/invite/cdp).



<!-- File: /Users/tinahe/docs/projects/mesh/docs/getting-started.mdx -->

---
title: "Getting Started with the Mesh API"
sidebar_label: "Getting Started"
slug: "getting-started"
---

Do you want to create a Mesh implementation for your blockchain? Or integrate with an existing Mesh implementation? Getting started with the Mesh API depends on your goals. 

In general, once you **implement** Mesh API with a blockchain, you can **integrate** applications that use the Mesh API to interact with that blockchain (or any blockchain that has a Mesh implementation). 

## Implementing Mesh for your Blockchain

To make a blockchain more accessible with Mesh API:

1. **Refer to the API Reference.** We have Mesh [specifications](/mesh/docs/api-reference) to help you check what the APIs request response should be.

2. **Implement the endpoints.** The [mesh-specifications](https://github.com/coinbase/mesh-specifications) repository contains all the API endpoints that you need to implement and [test](/mesh/docs/mesh-test) your code. If you are coding in Golang, see our [Go SDK](https://github.com/coinbase/mesh-sdk-go).

3. **Deploy the Mesh implementation with the blockchain node.** Write a functional Docker file to do this. Follow this guide on [Docker deployment](/mesh/docs/docker-deployment) for more information. The references in the [mesh-ecosystem](https://github.com/coinbase/mesh-ecosystem) repo that you can use to see how developers implement the Mesh API for their assets.

4. **Test your implementation with the `mesh-cli` tool.** Once you run the blockchain node, you can use the [`mesh-cli`](/mesh/docs/mesh-cli) tool to [test your implementation](/mesh/docs/mesh-test). The tool runs a basic check against the Mesh API specs and will make sure your implementation functions correctly.

## Integrating Applications with Mesh API

Once you have a Mesh implementation, you can use the Mesh client to integrate applications with your blockchain. You can also integrate using existing Mesh implementations. Here’s the best way to get started with this task:

1. **Refer to the API Reference.** We have Mesh [specifications](/mesh/docs/api-reference) to help you check what the APIs request response should be.

2. **Choose a Mesh blockchain implementation to work with.** You can find a collection of community-driven implementations [mesh-ecosystem repository](https://github.com/coinbase/mesh-ecosystem) in GitHub. 

3. **Deploy the Mesh implementation with the blockchain node.** Write a functional Docker file to do this. Follow this guide on [Docker deployment](/mesh/docs/docker-deployment) for more information. The references in the [mesh-ecosystem](https://github.com/coinbase/mesh-ecosystem) repo can also guide you.

4. **Test requests and responses using the Mesh API endpoints.** You can find the entire specification in our [Full Reference](/mesh/docs/api-reference) documentation. For a quick overview, read the next section.

## Mesh Quick Reference Guide

This guide provides an overview of the Mesh API endpoints. For more information on these endpoints, read the [API Reference](/mesh/docs/api-reference) documentation.

<img src={require('../assets/images/mesh-api-quick-reference-guide.jpg').default} width="500" alt="Mesh API Quickstart with list of endpoints" />

## Next Steps

- You can start [writing a configuration file](/mesh/docs/configuration-file) to test with [mesh-cli](/mesh/docs/mesh-cli). 

- Or follow the [implementations](/mesh/docs/implementation-samples) we’ve referenced.

- The Testing section provides great details on how to [test](/mesh/docs/mesh-test) your Mesh implementation. 

If you have any questions, you can check out our [Discord](https://discord.com/invite/cdp) to find the answer or submit your own questions. Happy coding!



<!-- File: /Users/tinahe/docs/projects/mesh/docs/flow-of-operations.mdx -->

---
title: "Flow of Operations"
sidebar_label: "Flow of Operations"
slug: "flow-of-operations"
excerpt: "Before diving into the specification and documentation, we recommend reviewing the high-level diagrams below to gain some familiarity with the functionality of the Mesh APIs."
---

The Mesh APIs are comprised of the [Data API](./api-data.mdx) and the [Construction API](./api-construction.mdx). The Data API retrieves data from a blockchain network. The Construction API constructs and submits transactions to a blockchain network.

## Data API

<img src={require('../assets/images/data-api-flow-of-operations.jpg').default} alt="Sample flows using the Data API such as getting an on-chain account balance or a transaction from the mempool." />

## Construction API

Unlike traditional SDKs, Construction API implementations are fully stateless, can perform construction offline (when metadata like an account nonce is pre-fetched), and never have access to private key material.

<img src={require('../assets/images/construction-api-flow-of-operations.jpg').default} alt="Sample flows using the Construction API such as constructing a payload or submitting a transaction." />

### Simplified Flow using a Higher-Level Interface

Many developers may not have security constraints that dictate that construction must occur offline, or that they use their own detached signer (making the previously described flow much more cumbersome than other transaction construction and signing SDKs).

Fortunately, it is possible (and encouraged) to build higher-level interfaces on top of these low-level endpoints to simplify development for integrators. For example, an interface developer may wish to automatically fetch metadata during their call to construct a transaction so users would not even know there are multiple interactions occurring. One could also provide a signing library with their higher-level interface so users do not need to use a detached signer. Here is an example of a simplified flow:

<img src={require('../assets/images/construction-api-simplified-flow.jpg').default} alt="Sample flows of simplied operations using the Construction API." />

Why build a higher-level interface on this Construction API instead of using existing SDKs? Any interface built on top of the Construction API could support the construction of transactions on any blockchain that supports Mesh with no modification. For example, you can build a [Coinbase Wallet SDK](/wallet-sdk/docs/welcome) service that works with any blockchain.


<!-- File: /Users/tinahe/docs/projects/cdp-apis/docs/wallet-comparison.mdx -->

---
title: "Comparing Our Wallets"
sidebar_label: "Comparing Our Wallets"
hide_table_of_contents: true
displayed_sidebar: "docs"
slug: "wallet-comparison"
---

Coinbase offers two main wallet solutions for developers: [Smart Wallet](https://www.coinbase.com/wallet/smart-wallet) and [MPC Wallet](https://docs.cdp.coinbase.com/mpc-wallet/docs/welcome). 

The Smart Wallet enables seamless onchain experiences by providing your **end-users** with an intuitive consumer experience. It streamlines user onboarding by minimizing private key management, avoiding app installations, and enabling gasless transactions via Paymaster. Check out [this demo](https://onchain-app-template.vercel.app/) of how easy it is to sign up and interact with Smart Wallet.

The MPC Wallet is perfect for **backend developers** that want to spin up wallets programmatically for themselves, AI agents, or their users. It gives developers full control over their UI, does not require end-user onboarding, and can be created in a few lines of code. [Here’s a walkthrough](https://x.com/brian_armstrong/status/1831831451945595231) of how fast you can get started using our [Replit Templates](https://replit.com/@CoinbaseDev).

## Wallet Comparison Table

Understanding their differences will help you choose the best fit for your application:

| Feature | Smart Wallet<br/>(Frontend) | MPC Wallet API<br/>(Backend) |
|---------|----------------------------|------------------------------|
| Primary Use | End-user wallets for connecting to applications | Developer-controlled wallets for programmatic blockchain interactions |
| Control | End-user controlled and managed | Developer controlled and managed |
| Security | Secured by user's passkey (biometric) | Secured via single key (1-of-1) or Multi-Party Computation (2-of-2) |
| Key Features | • Sponsored gas for users using Paymaster<br/>• Spend using Coinbase App balance through Magic Spend<br/>• Use across the onchain ecosystem<br/>• Free USDC sends on Base | • 2-of-2 wallet private keys secured via Multi-Party Computation<br/>• Fully programmable and customizable<br/>• CDP SDK support for Transfers, Trades, Staking, and Arbitrary Message Signing & Smart Contract Invocations<br/>• Free USDC sends on Base |
| Example Use Cases | • User authentication for applications<br/>• Cross-app interactions<br/>• Collecting NFTs and tokens | • AI agent wallets<br/>• Wallets for your company or your users<br/>• Programmatic asset management (e.g. rewards distribution, one-to-many payouts) |
| Supported Networks | Base, Arbitrum, Optimism, Zora, Polygon, BNB, Avalanche, Ethereum | Ethereum, Base, Polygon, and Arbitrum with more coming soon |

## Resources
- **Smart Wallet:** [Landing Page](https://www.coinbase.com/developer-platform/products/wallet-sdk) | [Documentation](https://www.smartwallet.dev/why) | [ERC-4337 Account Abstraction Standard](https://www.erc4337.io/)
- **MPC Wallet API:** [Documentation](https://docs.cdp.coinbase.com/mpc-wallet/docs/welcome) | [What is an MPC Wallet?](https://www.coinbase.com/learn/wallet/what-is-a-multi-party-computation-mpc-wallet) | [EOA vs Smart Contract Accounts](https://blog.ambire.com/eoas-vs-smart-contract-accounts/)



<!-- File: /Users/tinahe/docs/projects/cdp-apis/docs/welcome.mdx -->

---
title: "CDP APIs"
hide_title: true
sidebar_label: "Introduction"
hide_table_of_contents: true
slug: "welcome"
---

import QuickstartSection from "@site/src/components/QuickstartSection";
import DemoAppsSection from "@site/src/components/DemoAppsSection";
import ProductHeader from "@site/src/components/ProductHeader";
import { Divider } from "@cbhq/cds-web/layout/Divider";
import { Box } from "@cbhq/cds-web/layout/Box";
import { TextBody, TextHeadline, TextTitle2 } from "@cbhq/cds-web/typography";
import { CDP_APIS_QUICKSTARTS, CDP_APIS_DEMO_APPS, CDP_APIS_PRODUCTS } from "@site/src/constants";
import CategoryProducts from "@site/src/components/CategoryProducts";
import QuickstartCarousel from "@components/QuickstartCarousel";
import Quickstart from "@components/Quickstart";

<Box maxWidth={800}>
  <ProductHeader
    title="CDP APIs"
    subtitle="Coinbase Developer Platform (CDP) APIs are backend and frontend suites of crypto services to easily build onchain apps."
  />
</Box>

<Divider spacingVertical={5}/>

<div className="mb-8">
  <TextTitle2 as="h2">Use cases</TextTitle2>
</div>

<ul className="pl-4 gap-4 !mb-0 space-y-4">
  <li className="[&>p]:!m-0">
    <TextHeadline as="span">Wallets:</TextHeadline>&nbsp;
    <TextBody as="span" color="foregroundMuted">Programmatically provision and manage wallets for yourself and your users to build trading apps, AI wallets, and more.</TextBody>
  </li>
  <li className="[&>p]:!m-0">
    <TextHeadline as="span">Onramp:</TextHeadline>&nbsp;
    <TextBody as="span" color="foregroundMuted">Enable customers to seamlessly fund their wallets with fiat-to-crypto onramps in your app.</TextBody>
  </li>
  <li className="[&>p]:!m-0">
    <TextHeadline as="span">Paymaster:</TextHeadline>&nbsp;
    <TextBody as="span" color="foregroundMuted">Sponsor transactions on Base and provide a gasless experience for your users.</TextBody>
  </li>
  <li className="[&>p]:!m-0">
    <TextHeadline as="span">Staking:</TextHeadline>&nbsp;
    <TextBody as="span" color="foregroundMuted">Deliver programmatic staking in your apps using one common interface across protocols.</TextBody>
  </li>
</ul>

<Divider spacingVertical={5}/>

<QuickstartCarousel
  quickstarts={CDP_APIS_QUICKSTARTS}
/>

<Divider spacingVertical={5}/>

<DemoAppsSection demoApps={CDP_APIS_DEMO_APPS} />

<Divider spacingVertical={5}/>

<CategoryProducts products={CDP_APIS_PRODUCTS} title="Explore all CDP APIs" />



<!-- File: /Users/tinahe/docs/projects/exchange/docs/intro-sandbox.mdx -->

---
title: "Exchange Sandbox"
sidebar_label: "Sandbox"
slug: "sandbox"
---

A public sandbox is available for testing API connectivity and web trading.

:::caution Sandbox is subset
The sandbox hosts a _subset_ of the production order books and supports all exchange functionality _except_ [Transfers](./intro-sandbox.mdx#unsupported-features). You can add unlimited fake funds for testing.
:::

:::info
Login sessions and API keys are separate from production. Log into the [sandbox web interface](https://public.sandbox.exchange.coinbase.com) to create an API key, deposit/withdraw funds, etc.
:::

## Sandbox URLs

Use the following URLs to test your API connectivity. See the [Runbook](./intro-runbook.md#production-urls) for Production URLs.

| API                           | URL                                            |
| :---------------------------- | :--------------------------------------------- |
| REST API                      | <code>VAR::REST_URL_SAND </code>               |
| Websocket Feed                | <code>VAR::WSS_URL_SAND </code>                |
| Websocket Direct Feed         | <code>VAR::WSS_DIRECT_URL_SAND </code>         |
| FIX API - Order Entry 4.2     | <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FOUR </code> |
| FIX API - Order Entry 5.0 SP2 | <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FIVE </code> |
| FIX API - Market Data 5.0 SP2 | <code>VAR::FIX_URL_SAND_MARKET_DATA_FIVE </code> |

## Sandbox SSL Certificate

Your FIX SSL client must validate the following sandbox FIX server SSL certificate:

```
-----BEGIN CERTIFICATE-----
MIIEdDCCA1ygAwIBAgIQD03L1cHVypYSDFuvcnpAHzANBgkqhkiG9w0BAQsFADBG
MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg
Q0EgMUIxDzANBgNVBAMTBkFtYXpvbjAeFw0yMjAzMjcwMDAwMDBaFw0yMzA0MjUy
MzU5NTlaMCoxKDAmBgNVBAMMHyouc2FuZGJveC5leGNoYW5nZS5jb2luYmFzZS5j
b20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC8LYRdqMoVNa/0M4MF
+Wkr8SiybZ95JycTE+0ZVmf92DKo4I8m/8fBtOrH0jgrhvamVSJ0lI6VFiAzlTd1
doUbliQ9Xm1aE/YHQO9J64AIP97peysgHBd+g3/Vhz33aaaU2vyHH5kPHiekU8n/
ObXPPoFd/Awul8uxxlXsVFx8oBWL2MeMjLNLLWNiGWq+lQloGKsQYVR/fQZizvpP
vyZO6pCLRId6+Wq3Tcb7NHQZc6+tePVi+5fovE+lm/yQrhjGqDzI7P4rWjJqCPrA
sYJeYFcVJhdSuFY2Ngm8eKeDP14TVEs9pkIWvyMGmB17QBPbRJipdoKu1N6fsx54
N9JDAgMBAAGjggF4MIIBdDAfBgNVHSMEGDAWgBRZpGYGUqB7lZI8o5QHJ5Z0W/k9
0DAdBgNVHQ4EFgQUa5RZ0yvv71YteSuqO1VRvmGGKv0wKgYDVR0RBCMwIYIfKi5z
YW5kYm94LmV4Y2hhbmdlLmNvaW5iYXNlLmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYD
VR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMD0GA1UdHwQ2MDQwMqAwoC6GLGh0
dHA6Ly9jcmwuc2NhMWIuYW1hem9udHJ1c3QuY29tL3NjYTFiLTEuY3JsMBMGA1Ud
IAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0
cDovL29jc3Auc2NhMWIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRw
Oi8vY3J0LnNjYTFiLmFtYXpvbnRydXN0LmNvbS9zY2ExYi5jcnQwDAYDVR0TAQH/
BAIwADANBgkqhkiG9w0BAQsFAAOCAQEATpjyCMwAOSFKFTA67UaVkDCjz/ULBY6P
L4JwTJ+7kmT+HMvGimx15CsVjne64bT5twWlzqA/l4h25HGj0hD0TU2ktqmFhfAm
DpjGVp4KgIcZpvv7oRIU4e5I422Y++2UVuATwLWdELgpnm4AVq1aqI10XrQlJeHL
gRVfV5qkr9Vsc+fk7HY7YwbNQk2jXbRaj22f6GxiJ/6VmUcCD7zZ1GZtUipv0JEy
PtWD/BbSKNx1GJnLZ6L+QytPs+MW+FEetlU/oqPuyYRhmJUBUiwKkm6yKWRj9tQf
sq0a4uLI3SUgsBv/CQ/Qa9LnRdNjvlWSKLzeIX2LU9rE/3F3oQh7HQ==
-----END CERTIFICATE-----
```

## Unsupported Features

The Transfer endpoints are _not_ available for testing in the Sandbox:

- [Withdraw to payment](/exchange/reference/exchangerestapi_postwithdrawpaymentmethod)
- [Deposit from payment](/exchange/reference/exchangerestapi_postdepositpaymentmethod)
- [Deposit from Coinbase account](/exchange/reference/exchangerestapi_postdepositcoinbaseaccount)
- [Withdraw to crypto address](/exchange/reference/exchangerestapi_postwithdrawcrypto)
- [Withdraw to Coinbase Account](/exchange/reference/exchangerestapi_postwithdrawcoinbaseaccount)

## Creating API Keys

To create an API key in the sandbox web interface:

1. Go to the [sandbox web interface](https://public.sandbox.exchange.coinbase.com)
2. Create an account or sign in.
3. Go to **API** in your profile dropdown menu.
4. Click **New API Key**.

## Managing Funds

To add or remove funds in the sandbox web interface:

1. Go to the **Portfolios** tab.
2. Click the **Deposit** and **Withdraw** buttons as you would on the production web interface.



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-msg-order-entry.mdx -->

---
title: "Exchange FIX Order Entry Messages 4.2"
sidebar_label: Order Entry Messages 4.2
slug: "fix-msg-order-entry"
hide_table_of_contents: false
---

import useBaseUrl from '@docusaurus/useBaseUrl';

:::caution FIX 4.2 Order Entry Gateway Deprecation

  FIX 4.2 Order Entry Gateway will be deprecated on <b>March 3rd, 2025</b>. For FIX based order entry, <b>leverage the newer, more performant</b> [FIX 5 Order Entry Gateway](./fix-msg-order-entry-50.mdx).

  :::

About this API:

- **Baseline**: [FIX 4.2 SP2 specification](https://www.onixs.biz/fix-dictionary/4.2/index.html). Includes tags from later FIX versions plus custom tags in the high number range as allowed by the standard.
- **Environments**: Production, Sandbox

:::info Environment URLs

- Production: <code>VAR::FIX_URL_PROD_ORDER_ENTRY</code>
- Sandbox: <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FOUR</code>
  :::

## Header

A standard header must be present at the start of every message in both directions.

| Tag | Name               | Description                                                                                              |
| :-- | :----------------- | :------------------------------------------------------------------------------------------------------- |
| 8   | BeginString        | Must be `FIX.4.2`                                                                                        |
| 49  | SenderCompID       | Client API key (on messages from the client)                                                             |
| 56  | TargetCompID       | Must be `Coinbase` (on messages from the client)                                                         |
| 999 | CoinbaseProductSeq | Response header only (returned on [Execution Reports](#execution-report-8)). Represents market sequence. |

:::caution
[New orders](#new-order-single-d) can only be placed when the number of open orders is below VAR::MAX_OPEN_ORDERS for that given product.
:::

## Logon (A)

Sent by the client to initiate a session and by the server as an acknowledgement. Only one session may exist per connection; sending a Logon message within an established session is an error.

| Tag  | Name                     | Description                                                                                                                                                                                                                                                                      |
| :--- | :----------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 34   | MsgSeqNum                | Must be `1`                                                                                                                                                                                                                                                                      |
| 98   | EncryptMethod            | Must be `0` (None)                                                                                                                                                                                                                                                               |
| 108  | HeartBtInt               | Must be &le; `30` (secs). Values greater are capped at `30`. Server sends Test Request if client messages are not received in approximately (HeartBtInt x 1.5) seconds. Server terminates session if client messages are not received in approximately (HeartBtInt x 2 seconds). |
| 141  | ResetSeqNumFlag          | If set to `Y`, reset sequence numbers for both sides of the FIX session.                                                                                                                                                                                                         |
| 554  | Password                 | Client API passphrase                                                                                                                                                                                                                                                            |
| 96   | RawData                  | Client message signature (see below)                                                                                                                                                                                                                                             |
| 8013 | CancelOrdersOnDisconnect | `S`: Batch cancel all open orders placed during session; `Y`: Batch cancel all open orders for the current profile. The latter is more performant and recommended.                                                                                                               |
| 9406 | DropCopyFlag             | If set to `Y`, execution reports are generated for all user orders (defaults to `Y`).                                                                                                                                                                                            |

The Logon message sent by the client must be signed for security. The signing method is described in [Signing a Message](./rest-auth.md#signing-a-message). The prehash string is the following fields joined by the FIX field separator (ASCII code 1):

`SendingTime, MsgType, MsgSeqNum, SenderCompID, TargetCompID, Password`.

There is no trailing separator. The `RawData` field should be a base64 encoding of the HMAC signature.

```js
// create a new Logon message
var logon = new Msgs.Logon();
logon.SendingTime = new Date();
logon.HeartBtInt = 30;
logon.EncryptMethod = 0;
logon.passphrase = "...";

var presign = [
  logon.SendingTime,
  logon.MsgType,
  session.outgoing_seq_num,
  session.sender_comp_id,
  session.target_comp_id,
  passphrase,
].join("\x01");

// add the presign string to the RawData field of the Logon message
logon.RawData = sign(presign, secret);

// send the logon message to the server
session.send(logon);

function sign(what, secret) {
  var key = Buffer.from(secret, "base64");
  var hmac = crypto.createHmac("sha256", key);
  return hmac.update(what).digest("base64");
}
```

:::caution
To establish multiple FIX connections, generate a new API key for each one. The maximum is VAR::FIX_MAX_CONNECTIONS_PER_PROFILE connections per profile. Do not use a single API key for multiple connections at the same time.
:::

:::caution
The value of `SendingTime` must be within 5 minutes of server time in UTC.
:::

## Logout (5)

Sent by either side to initiate session termination. The side which receives this message first should reply with the same message type to confirm session termination.

:::caution
Do not close a connection without logging out of the session first or it triggers an error.
:::

## New Order Single (D)

Sent by the client to enter an order. Each profile can place a maximum of VAR::MAX_OPEN_ORDERS open orders on a product. Once reached, the profile cannot place any new orders until the total number of open orders is below VAR::MAX_OPEN_ORDERS .

| Tag  | Name                  | Description                                                                                                                                                                                                                                                                                                                                                                    |
| :--- | :-------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11   | ClOrdID               | UUID selected by client to identify the order                                                                                                                                                                                                                                                                                                                                  |
| 55   | Symbol                | Required symbol to identify the new order, e.g., `BTC-USD`                                                                                                                                                                                                                                                                                                                     |
| 54   | Side                  | Must be `1` to buy or `2` to sell                                                                                                                                                                                                                                                                                                                                              |
| 44   | Price                 | Limit price (e.g., in USD) (Limit order only)                                                                                                                                                                                                                                                                                                                                  |
| 38   | OrderQty              | Order size in base units (e.g., BTC)                                                                                                                                                                                                                                                                                                                                           |
| 152  | CashOrderQty          | Order size in quote units (e.g., USD) (Market or [Limit order](./fix-msg-oe-lwf.mdx) only)                                                                                                                                                                                                                                                                                                                      |
| 40   | OrdType               | Must be `1` for Market, `2` for Limit, `4` for Stop Limit, `O` for [Take Profit Stop Loss](./fix-msg-oe-tpsl.md)                                                                                                                                                                                                                                                              |
| 99   | StopPx                | Stop price for order                                                                                                                                                                                                                                                                                                                                                           |
| 59   | TimeInForce           | Must be a valid TimeInForce value. See the table below (Limit order only)                                                                                                                                                                                                                                                                                                      |
| 111  | MaxFloor              | Maximum size within an order to be displayed. Must be > 10% of OrderQty                                                                                                                                                                                                                                                                                                        |
| 126  | ExpireTime            | Time/Date (in UTC) of order expiration for Good Till Date (GTD) only. The order expires within one second after the specified time.                                                                                                                                                                                                                                            |
| 1109 | TriggerPriceDirection | The side from which the trigger price (or <b>last trade price</b>) is reached. <br /> Valid values: <br /><ul> <li>U = Trigger if price goes UP to or through specified Trigger Price.</li> <li>D = Trigger if price goes DOWN to or through specified Trigger Price.</li></ul> <b> Note:</b> If OrdType = 4, 1109 is highly recommended. If OrdType != 4, 1109 is not needed. |
| 7928 | SelfTradePrevention   | Optional, see the table below                                                                                                                                                                                                                                                                                                                                                  |

### SelfTradePrevention Values

| Value | Description                        |
| :---- | :--------------------------------- |
| `D`   | Decrement and cancel (the default) |
| `O`   | Cancel resting order               |
| `N`   | Cancel incoming order              |
| `B`   | Cancel both orders                 |

If an order is decremented due to self-trade prevention, an Execution Report is sent to the client with `ExecType=D` indicating unsolicited `OrderQty` reduction (i.e., partial cancel).

See the [self-trade prevention](/exchange/docs/matching-engine#self-trade-prevention) documentation for more details about this field.

### Time In Force Values

| Value | Policy                                | Abbr |
| :---- | :------------------------------------ | :--- |
| `1`   | Good Till Cancel                      | GTC  |
| `3`   | Immediate or Cancel                   | IOC  |
| `4`   | Fill or Kill                          | FOK  |
| `6`   | Good Till Date (90-day hard limit)    | GTD  |
| `P`   | Post-Only (GTC & make liquidity only) |      |

:::info Post-Only
The post-only flag (`P`) indicates that the order should only make liquidity. If any part of the order results in taking liquidity, the order is rejected and no part of it executes. Open Post-Only orders are treated as Good Till Cancel.
:::

See the [Time In Force](/exchange/reference/exchangerestapi_postorders#time-in-force) documentation for more details about these values.

### Errors

If a trading error occurs (for example, the user has insufficient funds), an Execution Report with `ExecType=8` is sent back, signifying that the order was rejected.

### Iceberg Orders

See [Iceberg Orders](./fix-msg-oe-iceberg.mdx).

### Take Profit Stop Loss Orders

See [TPSL Orders](./fix-msg-oe-tpsl.md).

### Limit With Funds Orders

See [Limit With Funds Orders](./fix-msg-oe-lwf.mdx).

## New Order Batch (U6)

Sent by the client to create multiple orders. Maximum of VAR::FIX_MAX_BATCH_ORDERS orders per message. All orders must have the same symbol.

Each profile can place a maximum of VAR::MAX_OPEN_ORDERS open orders on a product. Once reached, the profile cannot place any new orders until the total number of open orders is below VAR::MAX_OPEN_ORDERS . If the total number of open orders in the batch causes the profile to exceed the VAR::MAX_OPEN_ORDERS maximum, the entire batch is rejected.

| Tag  | Name                | Description                                                                                                                         |
| :--- | :------------------ | :---------------------------------------------------------------------------------------------------------------------------------- |
| 8014 | BatchID             | UUID selected by client to identify this New Order Batch request                                                                    |
| 73   | NoOrders            | Number of orders in this message (number of repeating groups to follow). Must be less than or equal to 15.                          |
| 11   | ClOrdID             | UUID selected by client for the order. Must be the first field in the repeating group.                                              |
| 55   | Symbol              | Required symbol to identify the new order (e.g., `BTC-USD`)                                                                         |
| 54   | Side                | Must be `1` to buy or `2` to sell                                                                                                   |
| 44   | Price               | Limit price (e.g., in USD)                                                                                                          |
| 38   | OrderQty            | Order size in base units (e.g., BTC)                                                                                                |
| 40   | OrdType             | Must be `2` for Limit                                                                                                               |
| 59   | TimeInForce         | Must be a valid [TimeInForce value](#time-in-force-values)                                                                            |
| 126  | ExpireTime          | Time/Date (in UTC) of order expiration for Good Till Date (GTD) only. The order expires within one second after the specified time. |
| 7928 | SelfTradePrevention | Optional, see the table above                                                                                                       |

## Order Cancel Request (F)

Sent by the client to cancel an order.

| Tag | Name        | Description                                                                                         |
| :-- | :---------- | :-------------------------------------------------------------------------------------------------- |
| 11  | ClOrdID     | UUID selected by client to identify this cancel request                                             |
| 37  | OrderID     | OrderID from the ExecutionReport with OrdStatus=New (39=0)                                          |
| 41  | OrigClOrdID | ClOrdID from the New Order Single. When supplying this value, you do not need to supply an OrderID. |
| 55  | Symbol      | Required symbol of the order to cancel (must match Symbol of the Order).                            |
| 58  | Text        | Free format text string                                                                             |

## Order Status Request (H)

Sent by the client to obtain information about pending and done orders.

| Tag | Name    | Description                                                                                        |
| :-- | :------ | :------------------------------------------------------------------------------------------------- |
| 37  | OrderID | OrderID of order to be sent back.                                                                  |
| 11  | ClOrdID | ClOrdID of order to be sent back. When supplying this value, you do not need to supply an OrderID. |
| 55  | Symbol  | Required symbol to identify the order, e.g., `BTC-USD`                                             |

### Response

The response to an Order Status Request is an ExecutionReport with `ExecType=I`. The ExecutionReport contains the `ClOrdID` if the value is supplied. If the order cannot be found, the ExecutionReport has `OrderID=0`.

## Order Cancel Batch Request (U4)

Sent by the client to cancel multiple orders. Maximum of VAR::FIX_MAX_BATCH_ORDERS orders per message. All orders must have the same symbol.

| Tag  | Name        | Description                                                                                                                                            |
| :--- | :---------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- |
| 8014 | BatchID     | UUID selected by client to identify this Order Batch Cancel Request                                                                                    |
| 73   | NoOrders    | Number of orders in this message (number of repeating groups to follow). Must be less than or equal to 15.                                             |
| 41   | OrigClOrdID | UUID selected by client for the order. Must be the first field in the repeating group.                                                                 |
| 55   | Symbol      | Required symbol of the order to cancel (must match Symbol of the Order)                                                                                |
| 37   | OrderID     | OrderID from the ExecutionReport with OrdStatus=New (39=0). If present, this field takes precedence over OrigClOrdID to identify the order (optional). |
| 11   | ClOrdID     | UUID selected by client to identify this cancel request                                                                                                |

### Response

When the message is invalid or an unexpected error occurs, an Order Cancel Batch Reject (U5) message is sent. When orders are cancelled, an Execution Report (8) is sent for each order canceled. When Order Cancel Batch Request (U4) is partially rejected (i.e., some orders are filled or already canceled), Order Cancel Reject (9) is sent for each rejected cancel.

## Execution Report (8)

Sent by the server when an order is accepted, rejected, filled, or canceled. Also sent when the user sends an `OrderStatusRequest`.

| Tag  | Name               | Description                                                                                                                                                                                                                                                                                                                             |
| :--- | :----------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 6    | AvgPx              | Calculated average price of all fills on this order. Only popluates Exec Report if CumQty > 0                                                                                                                                                                                                                                           |
| 11   | ClOrdID            | Only present on order acknowledgements, ExecType=New (150=0)                                                                                                                                                                                                                                                                            |
| 14   | CumQty             | Currently executed quantity for chain of orders. Populates Exec Report when: <ul> <li>`39=0` ⇒ OrdStatus = New</li> <li>`39=1` ⇒ OrdStatus = Partially filled</li> <li>`39=3` ⇒ OrdStatus = Done for day</li> <li>`39=5` ⇒ OrdStatus = Replaced</li></ul>                                                                               |
| 17   | ExecID             | Unique identifier of execution message as assigned by broker                                                                                                                                                                                                                                                                            |
| 37   | OrderID            | OrderID from the ExecutionReport with ExecType=New (150=0)                                                                                                                                                                                                                                                                              |
| 39   | OrdStatus          | Order status as of the current message                                                                                                                                                                                                                                                                                                  |
| 55   | Symbol             | Symbol of the original order                                                                                                                                                                                                                                                                                                            |
| 54   | Side               | Must be `1` to buy or `2` to sell                                                                                                                                                                                                                                                                                                       |
| 32   | LastShares         | Amount filled (if ExecType=1). Also called LastQty as of FIX 4.3                                                                                                                                                                                                                                                                        |
| 44   | Price              | Price of the fill if ExecType indicates a fill, otherwise the order price                                                                                                                                                                                                                                                               |
| 38   | OrderQty           | OrderQty as accepted (may be less than requested upon self-trade prevention). Represents original order quantity when `OrdStatus` is Canceled or Done for day.                                                                                                                                                                          |
| 111  | MaxFloor           | Maximum size within an order to be displayed. Must be > 10% of OrderQty                                                                                                                                                                                                                                                                 |
| 198  | SecondaryOrderID   | Assigned by the party that accepts the order. Can be used to provide the OrderID (37) used by an exchange or executing system.                                                                                                                                                                                                          |
| 58   | Text               | Human-readable description of the reject or cancel (optional) <ul><li>101:Time In Force</li> <li>102:Self-trade Prevention</li> <li>103:Admin</li> <li>104:Price Bound Order Protection</li> <li>105:Insufficient Funds</li> <li>106:Insufficient Liquidity</li> <li>107:Broker</li> <li>109:High Bid Limit Order Protection</li> </ul> |
| 60   | TransactTime       | Time the event occurred                                                                                                                                                                                                                                                                                                                 |
| 103  | OrdRejReason       | Insufficient funds=`3`, Post-only=`8`, Unknown error=`0`                                                                                                                                                                                                                                                                                |
| 136  | NoMiscFees         | `1` (Order Status Request responses and fill reports)                                                                                                                                                                                                                                                                                   |
| 137  | MiscFeeAmt         | Fee amount (absolute value for Order Status Request responses, percentage value for fill reports)                                                                                                                                                                                                                                       |
| 138  | MiscFeeCurr        | Fee currency                                                                                                                                                                                                                                                                                                                            |
| 139  | MiscFeeType        | `4` (Exchange fees) (Order Status Request responses and fill reports)                                                                                                                                                                                                                                                                   |
| 150  | ExecType           | May be `1` (Partial fill) for fills, `D` for self-trade prevention, etc.                                                                                                                                                                                                                                                                |
| 151  | LeavesQty          | Quantity open for further execution. Populates Exec Report when: <ul> <li>`39=0` ⇒ OrdStatus = New</li> <li>`39=1` ⇒ OrdStatus = Partially filled</li> <li>`39=3` ⇒ OrdStatus = Done for day</li> <li>`39=5` ⇒ OrdStatus = Replaced</li></ul>                                                                                           |
| 152  | CashOrderQty       | Order size in quote units (e.g., USD) (Market order only)                                                                                                                                                                                                                                                                               |
| 891  | MiscFeeBasis       | `2` (Percentage fee basis) (fill report only)                                                                                                                                                                                                                                                                                           |
| 1003 | TradeID            | Product unique trade id                                                                                                                                                                                                                                                                                                                 |
| 1057 | AggressorIndicator | `Y` for taker orders, `N` for maker orders                                                                                                                                                                                                                                                                                              |

### ExecType Values

| ExecType | Description                         |
| :------- | :---------------------------------- |
| `0`      | New Order                           |
| `1`      | Partial Fill                        |
| `3`      | Done                                |
| `4`      | Canceled                            |
| `7`      | Stopped                             |
| `8`      | Rejected                            |
| `D`      | Restated (Order Changed due to STP) |
| `I`      | Order Status                        |

## New Order Batch Reject (U7)

Sent by the server when a New Order Batch message is rejected.

| Tag  | Name    | Description                                        |
| :--- | :------ | :------------------------------------------------- |
| 8014 | BatchID | BatchID from the New Order Batch message           |
| 58   | Text    | Human-readable description of the error (optional) |

## Modify Order Request (G)

Supports the [Order Replace Request](https://www.onixs.biz/fix-dictionary/4.2/msgtype_g_71.html) outlined in the FIX protocol. See also: [WebSocket Full Channel, Change](./websocket-channels.mdx#change).

:::caution
Each Modify Order Request, per order, must be processed in turn. A client can only send a Modify Order Request after the previous request for the same order has been fully processed.
:::

Example FIX Request:

```
 BeginString=FIX.4.2 BodyLength=265 MsgType=ORDER_CANCEL_REPLACE_REQUEST MsgSeqNum=17 SenderCompID=00000000100000000000000000000003 SendingTime=20220609-04:01:48.757 TargetCompID=Coinbase ClOrdID=907b6ae6-bcbe-441a-b7bb-d932afdb9edb OrderID=71de0cdf-938f-495b-9fad-108837bde704 OrderQty=2 OrdType=LIMIT OrigClOrdID=907b6ae6-bcbe-441a-b7bb-d932afdb9eda Price=100.00 Side=BUY Symbol=ETH-USD TransactTime=20220609-04:01:48.757 CheckSum=107
```

Example Execution Report:

```
BeginString=FIX.4.2 BodyLength=253 MsgType=EXECUTION_REPORT MsgSeqNum=18 SenderCompID=Coinbase SendingTime=20220609-04:01:48.766 TargetCompID=00000000100000000000000000000003 ExecID=450d0b12-e994-48de-9f74-0f43c74fd054 ExecTransType=NEW OrderID=71de0cdf-938f-495b-9fad-108837bde704 OrderQty=3 OrdStatus=DONE_FOR_DAY Price=100 Side=BUY Symbol=ETH-USD Text=107:Broker TransactTime=20220609-04:01:48.762 ExecType=DONE_FOR_DAY LeavesQty=0 CheckSum=150
```

| Tag | Name         | Description                                                                                          |
| :-- | :----------- | :--------------------------------------------------------------------------------------------------- |
| 37  | OrderID      | Unique identifier of most recent order as assigned by broker                                         |
| 41  | OrigClOrdID  | `ClOrdID <11>` of previous order (NOT initial order of the day) when canceling or replacing an order |
| 11  | ClOrdID      | Unique identifier of replacement order as assigned by institution.                                   |
| 55  | Symbol       | Must match original order                                                                            |
| 54  | Side         | Must match original side                                                                             |
| 38  | OrderQty     | Total Intended Order Quantity (including the amount already executed for this chain of orders)       |
| 60  | TransactTime | Time this order request was initiated/released by the trader or trading system                       |
| 40  | OrdType      | Only limit orders are supported for now (2)                                                          |
| 44  | Price        | Price per share                                                                                      |

### Guidance

#### Queue Priority

- If you increase the quantity, or modify the price (up or down) you **lose your place and move to the back of the queue**. If you decrease the quantity you keep your place in the queue.

#### OrderQty (38)

- If you send a Modify Order request whose `OrderQty (38)` is less than the filled size of the order, **Coinbase cancels the order and marks it as filled**.

#### Matching

- If your Modify Order request results in an **immediate match** and you are both the **initiator of the order** AND **subscribed to the authenticated WebSocket feed**, you should receive a change message with `"reason": "modify_order"`.

  After the immediate match, if there is any **quantity remaining** on the modified order, you should receive a new change message with `"reason":"remainder_after_modification"` which reports the new / old prices as a result of the Modify Order.

- If you are **using the non-authenticated WebSocket feed** (as the initiator or not), you should receive a `match + done` message for the order at the newly modified price.

:::caution
Clients may experience a non-standard FIX `OrderCancelReject` with text (when processing the last cancel replace request). This can occur when our system is backlogged and unable to process this Modify Order Request (or `OrderCancelReplaceRequest`).
:::

## Order Cancel Reject (9)

Sent by the server when an Order Cancel Request cannot be satisfied, e.g., because the order is already canceled or completely filled.

| Tag | Name             | Description                 |
| :-- | :--------------- | :-------------------------- |
| 11  | ClOrdID          | As on the cancel request    |
| 37  | OrderID          | As on the cancel request    |
| 41  | OrigClOrdID      | As on the cancel request    |
| 39  | OrdStatus        | `4` if too late to cancel   |
| 102 | CxlRejReason     | `1` if the order is unknown |
| 434 | CxlRejResponseTo | `1` (Order Cancel Request)  |

## Order Cancel Batch Reject (U5)

Sent by the server when an Order Cancel Batch Request cannot be satisfied, e.g., because a Symbol was not present. This is not sent if no orders can be found.

| Tag  | Name    | Description                                        |
| :--- | :------ | :------------------------------------------------- |
| 8014 | BatchID | BatchID from the New Order Batch message           |
| 58   | Text    | Human-readable description of the error (optional) |

## Reject (3)

Sent by either side upon receipt of a message which cannot be processed, e.g., due to missing fields or an unsupported message type.

| Tag | Name                | Description                                                |
| :-- | :------------------ | :--------------------------------------------------------- |
| 45  | RefSeqNum           | MsgSeqNum of the rejected incoming message                 |
| 371 | RefTagID            | Tag number of the field which caused the reject (optional) |
| 372 | RefMsgType          | MsgType of the rejected incoming message                   |
| 58  | Text                | Human-readable description of the error (optional)         |
| 373 | SessionRejectReason | Code to identify reason for reject                         |

### SessionRejectReason Values

The following values can be sent by the server.

| Value | Description                                    |
| :---- | :--------------------------------------------- |
| 1     | Required tag missing                           |
| 5     | Value is incorrect (out of range) for this tag |
| 6     | Incorrect data format for value                |
| 11    | Invalid MsgType (35)                           |

## RFQ Request (AH)

Request For Quote (RFQ) allows liquidity providers to respond and interact with real-time RFQ requests. The RFQ process begins with [Quote Request (R)](#quote-request-r).

Request For Quote is enabled for users who have been approved by Coinbase as an RFQ Liquidity Provider. Once approved, clients must send an RFQ Request message (35=AH) after each successful Logon (35=A) message for any session in which you are interested in receiving RFQ requests.

- If this request is acknowledged, and no symbol is specified, this session receives all Quote requests (all assets).
- If this request is acknowledged, and symbol is specified , this session only receives requests for the specific symbols. For instance, in the scenario of subscribing to "BTC-USD," if the related products are present, quote request message for both "BTC-USD" and "USD-BTC" will be subsequently returned as responses.
- If the session submitting this request is not approved by Coinbase for participating in the RFQ program, this request is rejected with a Business Message Reject (j).

| Tag | Name         | Type     | Required | Notes                                                             |
| :-- | :----------- | :------- | :------- | :---------------------------------------------------------------- |
| 644 | RFQReqID     | UUID     | Y        |                                                                   |
| 146 | NoRelatedSym | Int32    | N        | Repeating group for number of symbols in the subscription message |
| 55  | Symbol       | String32 | Y        |                                                                   |

:::tip
_Not_ receiving a response is expected and indicative of a successful request.
:::

### RFQ Order Protections

RFQ orders are subject to price protection points (PPP) at the time a quote is accepted for execution.

At Execution time:

- If an Order Book is present, RFQs fill at prices up to the PPP from the mid-point price, between the best bid and best offer.

- If an Order Book is not present, PPPs are calculated using the same mid-point price methodology but leveraging PPP settings from the higher of the two USD equivalent Order Books for the given pair (e.g., max PPP setting for SHIB-USD and DOGE-USD for a SHIB-DOGE RFQ).

If a PPP threshold is crossed, a [QuoteStatusReport (AI)](#quote-status-report-ai) is sent indicating your Quote has been canceled.

## Quote Request (R)

Quote Request (R) is the start of the RFQ process. Liquidity Providers receive a Quote Request from Coinbase on behalf of a customer looking to participate in an RFQ trade. Any quote response to this request must adhere to the following rules to avoid rejections:

- Message must be well formed and complete (i.e., all required fields present).
- [Quote](#quote-s) message must be received before the expiration time indicated on Tag=62.

| Tag | Name             | Type         | Required | Notes                                                |
| :-- | :--------------- | :----------- | :------- | :--------------------------------------------------- |
| 131 | QuoteReqID       | UUID         | R        |                                                      |
| 146 | NoRelatedSym     | Int32        | Y        | Always 1                                             |
| 55  | Symbol           | String32     | Y        | Example: `BTC-AVAX`                                  |
| 38  | OrderQty         | Float64      | Y        |                                                      |
| 62  | ValidUntilTime   | UTCTimestamp | Y        | UTC millis<br/>`20220712-00:00:00.000`               |
| 126 | ExpireTime       | UTCTimestamp | Y        | UTC millis<br/>`20220712-00:00:00.000`               |
| 303 | QuoteRequestType | Char         | Y        | 1 = Manual Accept<br/>2 = Automatic Accept (default) |
| 891 | MiscFeeBasis     | INT          | Y        | Always 2 = Percentage                                |
| 137 | MiscFeeAmt       | AMT          | Y        | Basis point fee to market makers (MMs)               |

:::caution
QuoteRequestType (303) is always `2 = Automatic Accept` for the current implementation of RFQ on Coinbase Exchange.
MiscFeeBasis (891) is always `2 = Percentage` for the current implementation of RFQ on Coinbase Exchange.
:::

>

<figcaption><i>Request For Quote Message Flow</i></figcaption> <img src={useBaseUrl('exchange/assets/images/rfq-example.png')} width="500" alt="Request For Quote message flow in 7 steps. (1) Customer submits RFQ; (2) Exchange sends Quote Request to liquidity provider; (3) Liquidity provider sends Quote to Exchange; (4) the Exchange responds to the liquidity provider with the Quote Status Report and (5) the Execution Report and (6) the Quote Status Report; (7) the Exchange then sends the customer a fill or cancel message."  />

:::info
See also the new WebSocket [RFQ Matches Channel](./websocket-channels.mdx#rfq-matches-channel).
:::

## Quote (S)

Quote in response to a [Quote Request](#quote-request-r) that can be submitted up to the `ValidUntilTime` (Tag=62) specified in the Quote Request message. The Quote can be submitted as either a one-way quote or two-way quote. Only one side is actioned on if participant wins RFQ.

:::info
Precision for price and size is limited to 16 decimal places and 40 digits total.
:::

| Tag | Name       | Type     | Required | Notes                                                                 |
| :-- | :--------- | :------- | :------- | :-------------------------------------------------------------------- |
| 131 | QuoteReqID | UUID     | Y        |                                                                       |
| 117 | QuoteID    | UUID     | Y        |                                                                       |
| 55  | Symbol     | String32 | Y        | Example: `BTC-AVAX`                                                   |
| 132 | BidPx      | Float64  | C        | Required if submitting a bid                                          |
| 133 | OfferPx    | Float64  | C        | Required if submitting an offer                                       |
| 134 | BidSize    | Float64  | C        | Required if submitting a bid. Must match OrderQty in Quote Request    |
| 135 | OfferSize  | Float64  | C        | Required if submitting an offer. Must match OrderQty in Quote Request |

{/* <!---
## Quote Request Reject (AG)

Message received when the quote response does not meet the minimum requirements highlighted above under the [Quote Request](#quote-request-r) spec.

| Tag | Name                     | Type     | Required | Notes                     |
|:----|:-------------------------|:---------|:---------|:--------------------------|
| 131 | QuoteReqID               | UUID     | Y        |                           |
| 658 | QuoteRequestRejectReason | Int32    | Y        | 1 = Unknown Symbol<br/>6 = Not Authorized<br/>7 = No Match for Inquiry (Cancel Reject)<br/>11 = Insufficient Credit<br/>99 = Other |
| 11  | ClOrdID                  | UUID     | Y        |                           |
| 146 | NoRelatedSym             | Int32    | Y        | Always 1                  |
| 55  | Symbol                   | String32 | Y        | Example: `BTC-AVAX`       |
| 38  | OrderQty                 | Float64  | Y        | Echoed from Quote Request |
---> */}

## Quote Status Report (AI)

`
Message sent in response to a successful or unsuccessful Quote.

- If the Quote was accepted, QuoteStatus=16 (Active).
- If the Quote was rejected, QuoteStatus=9 (Rejected).
- If the Quote was accepted and selected for execution, QuoteStatus=19 (Pending), and you receive an Execution Report.
- If the Quote was accepted but not selected for execution, QuoteStatus=17 (Canceled).
- If there is no response to a Quote request from Liquidity Providers, QuoteStatus=7 (Expired).

| Tag | Name           | Type         | Required | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| :-- | :------------- | :----------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 131 | QuoteReqID     | UUID         | Y        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 117 | QuoteID        | UUID         | C        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 55  | Symbol         | String32     | Y        | Example: `BTC-AVAX`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 38  | OrderQty       | Float64      | Y        | Echoed from Quote<br/>35=S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 132 | BidPx          | Float64      | Y        | Echoed from Quote<br/>35=S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 133 | OfferPx        | Float64      | Y        | Echoed from Quote<br/>35=S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 134 | BidSize        | Float64      | C        | Must match OrderQty in Quote Request                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 135 | OfferSize      | Float64      | C        | Must match OrderQty in Quote Request                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 62  | ValidUntilTime | UTCTimestamp | Y        | UTC millis<br/>`20220712-00:00:00.000`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 126 | ExpireTime     | UTCTimestamp | Y        | UTC millis<br/>`20220712-00:00:00.000`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 297 | QuoteStatus    | Int32        | Y        | `5` = Rejected: Insufficient funds (in response to [35=S](#quote-s))<br /> `7` = Expired:<br /> &nbsp;&nbsp;&#x25AA;&nbsp;Either no response to [35=S](#quote-s) from liquidity providers<br />&nbsp;&nbsp;&#x25AA;&nbsp;Or best quote not accepted by counterparty<br /> `16` = Active: Quote successful (in response to [35=S](#quote-s)) <br /> `17` = Canceled:<br />&nbsp;&nbsp;&#x25AA;&nbsp;Either quoting window expired bc quote not best<br />&nbsp;&nbsp;&#x25AA;&nbsp;Or RFQ was unable to hold funds<br /> `19` = Pending Trade: RFQ selected for execution |
| 58  | Text           | String       | C        | Required if QuoteStatus=5, Quote action was rejected                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |

## Resend Request (2)

[FIX Resend Requests](https://www.onixs.biz/fix-dictionary/4.2/msgtype_2_2.html) are sent by the receiving application to initiate the retransmission of messages.

| Tag | Name                                                                 | Description                                            |
| :-- | :------------------------------------------------------------------- | :----------------------------------------------------- |
| 7   | [BeginSeqNo](https://www.onixs.biz/fix-dictionary/4.2/tagnum_7.html) | Sequence number of first message in range to be resent |
| 16  | [EndSeqNo](https://www.onixs.biz/fix-dictionary/4.2/tagnum_16.html)  | Sequence number of last message in range to be resent  |

### Guidance

- To successfully use replay functionality, submit a unique `senderLocationID` when logging on (because you can have multiple connections per API key).

  [SenderLocationID \<142\>](https://www.onixs.biz/fix-dictionary/4.2/tagnum_142.html) identifies the message originator's location.

- To replay messages from a previous session, include `ResetSeqNumFlag=N` in your logon message (because, by default, we clear users sessions when logging on). You must also include the same `senderLocationID` used in the previous session to continue the session.

  [ResetSeqNumFlag \<141\>](https://www.onixs.biz/fix-dictionary/4.2/tagnum_141.html) is a boolean flag that indicates whether or not both sides of the FIX session should reset sequence numbers.

#### Sequence Numbers

Each request must be in batches of 2000 messages or less and lookback (the duration we keep messages) is 3 hours. For example, say you received messages in sequence range 4000-10000 within the last 3 hours:

- You can retrieve all messages from 4000 to 10000 by sending 3 requests in batches of 2000.
- You cannot retrieve messages before 4000 because of the 3 hour lookback.

#### Sample Ranges

- Request single: `BeginSeqNo <7>` = `EndSeqNo <16>`
- Request range: `BeginSeqNo <7>` = first message in range; `EndSeqNo <16>` = last message in range
- Request range: `BeginSeqNo <7>` = first message in range; `EndSeqNo <16>` = 2000th message from first message (`999999` or `0`)

## Heartbeat (0)

Sent by both sides if no messages have been sent for (HeartBtInt x 0.75) seconds, as agreed upon during logon. May also be sent in response to a Test Request.

| Tag | Name      | Description                          |
| :-- | :-------- | :----------------------------------- |
| 112 | TestReqID | Copied from the Test Request, if any |

## Test Request (1)

May be sent at any time by either side.

| Tag | Name      | Description |
| :-- | :-------- | :---------- |
| 112 | TestReqID | Free text   |



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-msg-oe-iceberg.mdx -->

---
title: "Exchange Iceberg Orders"
sidebar_label: Iceberg Orders
slug: "fix-msg-oe-iceberg"
hide_table_of_contents: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


Iceberg orders are supported in New Order Single (35=D) [FIX 4.2](./fix-msg-order-entry.mdx#new-order-single-d) and [FIX 5.0](./fix-msg-order-entry-50.mdx#newordersingle-35d) with the [Create a new order](/exchange/reference/exchangerestapi_postorders) REST API. 

Iceberg orders allow you to disclose fills to the market in parts, by sending a [New Order Single (D)](./fix-msg-order-entry.mdx#new-order-single-d) with [MaxFloor (111)](https://fiximate.fixtrading.org/en/FIX.Latest/tag111.html): 

- A quantity equal to the MaxFloor is displayed on the order book, with the remainder added to the order book at the same price level as the hidden quantity at the end of the queue. 
- When the displayed quantity is fully filled, matching logic continues to execute and fill the hidden quantity. 
- Once the matching event is completed, if there is still a hidden quantity left, a new displayed order is added to the end of the display order queue, for a size up to MaxFloor.

Changes to the displayed portion of the order, such as replenishes, fills, STPs, or user cancels, are supplied via ExecutionReport with [SecondaryOrderID (198)](https://fiximate.fixtrading.org/en/FIX.Latest/tag198.html).

### Supported Pairs

See [Iceberg Orders Supported Trading Pairs](https://help.coinbase.com/en/exchange/trading-and-funding/iceberg-trading).

:::note 
All trading pairs have Iceberg supported in sandbox.
:::

### Sample Message Flow

In this example message flow, a client submitted a buy order of quantity = 1 and while displaying only 0.3 at a time. (Non-relevant FIX fields and IDs are not shown for brevity.)

<details>
<summary><b>Event 1 - Passive New Order</b></summary>
<div>

A passive Iceberg order is placed with OrderQty=1 (`38=1`) and MaxFloor=0.3 (`111=0.3`):

`OrderID123` is _not_ in the Full channel, nor in the Level2 FIX Market Data. Instead, only the displayed portion is shown as `Order456`. 

<Tabs>
<TabItem value="FIX" label="FIX">

```json
-> 35=D|55=BTC-USD|40=2|38=1|44=25000|111=0.3
<- 35=8|37=OrderID123|39=New|38=1
// Event generated when the first displayed portion of the order is added to the orderbook
<- 35=8|37=OrderID123|198=OrderID456|39=Restated|378=Broker_Option|38=0.3
```

</TabItem>
<TabItem value="WebSocketFull" label="WebSocket Full Channel">

```json
{"order_id":"OrderID456","order_type":"limit","size":"0.3","price":"25000","type":"received","side":"buy","product_id":"BTC-USD","time":...}
{"order_id":"OrderID456","order_type":"limit","remaining_size":"0.3","price":"25000","type":"open","side":"buy","product_id":"BTC-USD","time":...}
```

</TabItem>
<TabItem value="WebSocketL2" label="WebSocket Level2 Channel">

```json
{"type":"l2update","product_id":"BTC-USD","changes":[["buy","25000.0000","0.3000"]]...}
```

</TabItem>
</Tabs>
</div>
</details>

<details>
<summary><b>Event 2 - MaxFloor Match</b></summary>
<div>

A match takes place with quantity = 0.3. 

Once the displayed order is fully filled, a `Done_For_Day` with SecondaryOrderID is sent. This does not mean the Iceberg order is complete. Rather, a replenish event occurs with a different SecondaryOrderID. The new displayed order is added to the end of the queue of the displayed book at the price of 25000.

<Tabs>
<TabItem value="FIX" label="FIX">

```json
<- 35=8|37=OrderID123|198=OrderID456|39=Partially_Filled|32=0.3|151=0.7|14=0.3|137=0.0004
<- 35=8|37=OrderID123|198=OrderID456|39=Done_For_Day|32=0|151=0.7|14=0.3
// Displayed portion replenish event
<- 35=8|37=OrderID123|198=OrderID789|39=Restated|378=Broker_Option|38=0.3
```

</TabItem>
<TabItem value="WebSocketFull" label="WebSocket Full Channel">

```json
{"trade_id":1761595,"maker_order_id":"OrderID456","taker_order_id":"...","size":"0.3","price":"25000","type":"match","side":"buy",...}
{"order_id":"OrderID456","reason":"filled","price":"25000","remaining_size":"0","type":"done","side":"buy","product_id":"BTC-USD",...}
{"order_id":"Order789","order_type":"limit","size":"0.3","price":"25000","type":"received","side":"buy","product_id":"BTC-USD","time":...}
{"order_id":"Order789","order_type":"limit","remaining_size":"0.3","price":"25000","type":"open","side":"buy","product_id":"BTC-USD","time":...}
```

</TabItem>
<TabItem value="WebSocketL2" label="WebSocket Level2 Channel">

```json
{"type":"l2update","product_id":"BTC-USD","changes":[["buy","25000.0000","0.0000"]]...} {"type":"l2update","product_id":"BTC-USD","changes":[["buy","25000.0000","0.3000"]]...}
```

</TabItem>
</Tabs>
</div>
</details>


<details>
<summary><b>Event 3 - Aggressive Order</b></summary>
<div>

An aggressive order takes place with quantity = 0.7. 

In this event, a large aggressive order came in. First, the displayed `OrderID789` was filled for 0.3. Then, because the displayed book was empty at the price level of 25000, the matching logic continued to the hidden book at the price level 25000. The hidden `OrderID123` was filled for 0.4. Note that the `Done_For_Day` ExecutionReport does _not_ have a SecondaryOrderID and the the Iceberg order is complete.

<Tabs>
<TabItem value="FIX" label="FIX">

```json
<- 35=8|37=OrderID123|198=OrderID789|39=Partially_Filled|32=0.3|151=0.4|14=0.6|137=0.0004
<- 35=8|37=OrderID123|198=OrderID789|39=Done_For_Day|32=0|151=0.4|14=0.6
<- 35=8|37=OrderID123|39=Partially_Filled|32=0.4|151=0|14=1.0|137=0.00045
<- 35=8|37=OrderID123|39=Done_For_Day|32=0|151=0|14=1.0

```

</TabItem>
<TabItem value="WebSocketFull" label="WebSocket Full Channel">

```json
{"trade_id":1761596,"maker_order_id":"OrderID456","taker_order_id":"...","size":"0.3","price":"25000","type":"match","side":"buy",...}
{"order_id":"OrderID456","reason":"filled","price":"25000","remaining_size":"0","type":"done","side":"buy","product_id":"BTC-USD",...}
{"trade_id":1761596,"maker_order_id":"OrderID123","taker_order_id":"...","size":"0.4","price":"25000","type":"match","side":"buy",...}
```

</TabItem>
<TabItem value="WebSocketL2" label="WebSocket Level2 Channel">

```json
{"type":"l2update","product_id":"BTC-USD","changes":[["buy","25000.0000","0.0000"]]...} 
```

</TabItem>
</Tabs>
</div>
</details>

### Trading Rules

To date, the Coinbase Exchange matching engine has followed price/time priority. With the introduction of Iceberg orders, our matching engine is changing to **price/display/time priority**. Regardless of whether they are displayed or hidden, better price orders will have higher priority. At a given price level, all displayed orders will have a higher priority than the hidden portion of the Iceberg orders. Replenish events will add a displayed order to the end of the displayed book at that price level. 
 
### Fees for Non-displayed Fills

Fees are subject to change, but in general:

- Fills for displayed orders are charged with the standard taker/maker fee rate. 
- Fills for non-displayed orders are charged with the standard taker/maker fee rate + a **fixed** 0.00005 (half a bps).

Fills can occur as non-displayed when an Iceberg order:

- Is executed as a taker.
- Is resting in the non-displayed book, and a significant taker order clears all displayed orders, eventually executing against this non-displayed order.

### Self Trade Prevention

Displayed and hidden orders will be treated separately. For instance, if you have an Iceberg buy order of OrderQty=1 and MaxFloor=0.3, and you place a sell order with OrderQty=0.2 with SelfTradePrevention=O (Cancel Old), the displayed order is canceled but the hidden order is not. Instead, a replenish event will occur. 

- **Cancel Old**: Once the displayed order is touched, the displayed order is canceled and matching continues. If the aggressive order hits the hidden order, the hidden order will then be canceled.
- **Decrement Cancel**: Size matters. The displayed order is first decremented and the matching logic continues. If the hidden order has quantity remaining, a replenish event occurs.  If the hidden order is crossed, it will then be decremented. 
- **Cancel Both**: This is similar to the approach for Cancel Old. Only the displayed portion gets canceled with the aggressive order. A replenish event occurs, if there is hidden size left.

### Allowed / Not Allowed

#### Allowed
- Post Only order with MaxFloor.
- Stop order with MaxFloor.
- MaxFloor must be >= 10% of the OrderQty .

#### Not Yet Allowed
- Batch order with MaxFloor.
- Modifying an Iceberg order.
- Iceberg order in auction mode (existing Iceberg orders will be canceled if a product is transitioned to auction mode).



<!-- File: /Users/tinahe/docs/projects/exchange/docs/websocket-channels.mdx -->

---
title: "Exchange WebSocket Channels"
sidebar_label: "Channels"
slug: "websocket-channels"
---

import Badge from '@components/Badge';

## Heartbeat Channel

To receive heartbeat messages for specific products every second, subscribe to the `heartbeat` channel. Heartbeats include [sequence numbers](./websocket-overview.md#sequence-numbers) and last trade IDs that can be used to verify that no messages were missed.

```json
// Request
{
    "type": "subscribe",
    "channels": [
        {
            "name": "heartbeat",
            "product_ids": [
                "ETH-EUR"
            ]
        }
    ]
}
```

```json
// Heartbeat message
{
  "type": "heartbeat",
  "sequence": 90,
  "last_trade_id": 20,
  "product_id": "BTC-USD",
  "time": "2014-11-07T08:19:28.464459Z"
}
```


## Status Channel

:::danger Order Size Properties Removed
The properties `base_max_size`, `base_min_size`, `max_market_funds` were removed on June 30. The property, `min_market_funds`, has been repurposed as the notional minimum size for limit orders. See the [Changelog](./changelog.md#2022-jun-30).
:::

The `status` channel sends all products and currencies on a preset interval.

```json
// Request
{
  "type": "subscribe",
  "channels": [{ "name": "status"}]
}
```

```json
// Status Message
{
  "type": "status",
  "products": [
    {
      "id": "BTC-USD",
      "base_currency": "BTC",
      "quote_currency": "USD",
      "base_increment": "0.00000001",
      "quote_increment": "0.01",
      "display_name": "BTC-USD",
      "status": "online",
      "status_message": null,
      "min_market_funds": "10",
      "post_only": false,
      "limit_only": false,
      "cancel_only": false,
      "fx_stablecoin": false
    }
  ],
  "currencies": [
    {
      "id": "USD",
      "name": "United States Dollar",
      "display_name": "USD",
      "min_size": "0.01000000",
      "status": "online",
      "status_message": null,
      "max_precision": "0.01",
      "convertible_to": ["USDC"],
      "details": {},
      "default_network": "",
      "supported_networks": []
    },
    {
      "id": "USDC",
      "name": "USD Coin",
      "display_name": "USDC",
      "min_size": "0.00000100",
      "status": "online",
      "status_message": null,
      "max_precision": "0.000001",
      "convertible_to": ["USD"],
      "details": {},
      "default_network": "ethereum",
      "supported_networks": [
        {
          "id": "ethereum",
          "name": "Ethereum",
          "status": "online",
          "contract_address": "",
          "crypto_address_link": "https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48?a={{address}}",
          "crypto_transaction_link": "https://etherscan.io/tx/0x{{txId}}",
          "min_withdrawal_amount": 0.001,
          "max_withdrawal_amount": 300000000,
          "network_confirmations": 14,
          "processing_time_seconds": 0,
          "destination_tag_regex": ""
        }
      ]
    },
    {
      "id": "BTC",
      "name": "Bitcoin",
      "display_name": "BTC",
      "min_size":" 0.00000001",
      "status": "online",
      "status_message": null,
      "max_precision": "0.00000001",
      "convertible_to": [],
      "details": {},
      "default_network": "bitcoin",
      "supported_networks": [
        {
          "id": "bitcoin",
          "name": "Bitcoin",
          "status": "online",
          "contract_address": "",
          "crypto_address_link": "https://live.blockcypher.com/btc/address/{{address}}",
          "crypto_transaction_link": "https://live.blockcypher.com/btc/tx/{{txId}}",
          "min_withdrawal_amount": 0.0001,
          "max_withdrawal_amount": 2400,
          "network_confirmations": 2,
          "processing_time_seconds": 0,
          "destination_tag_regex": ""
        }
      ]
    }
  ]
}
```


## Auction Channel

The `auction` channel sends information about the auction while the product is in auction mode. 

Auction messages provide the most recent indicative quote disseminated during the auction. Indicative quote messages are sent on an interval basis (about once a second) during the collection phase of an auction. The indicative quote includes information about the tentative price and size affiliated with the completion.

The open price and size indicate the aggregate size of all the orders eligible for crossing, along with the price used for matching all the orders as the auction enters the opening state. The best bid and ask price and size fields indicate the anticipated BBO upon entering full trading or limit only after the matching has completed. 

Because indicative quotes are sent on an interval, values are not firm. The price may change in between two quote updates: (1) in between two normal quote update intervals, or (2) in between the last normal quote update interval and the final indicative quote that occurs when the book transitions from auction mode to full trading.

See [Get Product Book](/exchange/reference/exchangerestapi_getproductbook) in the API Reference for more details on the level 1 book and products in auction mode.


```json
// Request
{
  "type": "subscribe",
  "channels": [{ "name": "auctionfeed", "product_ids": ["LTC-USD"] }]
}
```

```json
// Auction Message
{
    "type": "auction",
    "product_id": "LTC-USD",
    "sequence": 3262786978,
    "auction_state": "collection",
    "best_bid_price": "333.98",
    "best_bid_size": "4.39088265",
    "best_ask_price": "333.99",
    "best_ask_size": "25.23542881",
    "open_price": "333.99",
    "open_size": "0.193",
    "can_open": "yes",
    "timestamp": "2015-11-14T20:46:03.511254Z"
}
```


## Matches Channel

If you are only interested in [match](#match) messages, you can subscribe to the matches channel. This is useful when you're consuming the remaining feed using the [level2 channel](#level2-channel).

After subscribing to the matches channel, the message `type` of the first message returned (and only the first message) is `last_match`, for example, `"type": "last_match",`

:::caution
Messages can be dropped from this channel. Use the [heartbeat channel](#heartbeat-channel) to track the last trade ID and fetch trades that you missed from the REST API.
:::


## RFQ Matches Channel

The subscription message for the Request For Quote or `rfq_matches` channel does not require the `product_ids` field; otherwise, it is the same as all other WebSocket feed channels. 

- If `product_ids` is not sent, or sent as an empty string “”, or sent as "ALL”, the user receives `rfq_matches` for all products. 
- If `product_ids` is defined, the subscriber only receives `rfq_matches` for that product. The product specified must be a valid Coinbase product ID. 

:::tip
Coinbase recommends submitting an empty list in the subscription request (and not specifying `product_ids`) to ensure you get all RFQ matches.
:::

:::caution
If the user has an “ALL” subscription and subscribes to a specific product, that new subscription is denied.
:::

```json
// Subscription Request
{
  "type": "subscriptions",
  "channels": [
    {
      "name": "rfq_matches",
      "product_ids": [
        "",
      ],
    },
  ]
}
```

:::caution
The subscription message uses the plural `product_ids`, whereas RFQ messages use the singluar, `product_id`.
:::

```json
// RFQ Request
{
  "type": "rfq_match",
  "maker_order_id": "ac928c66-ca53-498f-9c13-a110027a60e8",
  "taker_order_id": "132fb6ae-456b-4654-b4e0-d681ac05cea1",
  "time": "2014-11-07T08:19:27.028459Z",
  "trade_id": 30,
  "product_id": "BTC-USD",
  "size": "5.23512",
  "price": "400.23",
  "side": "sell"
}
```

:::info
See also the new [FIX Request For Quote messages](./fix-msg-order-entry.mdx#rfq-request-ah).
:::


## Ticker Channel

The `ticker` channel provides real-time price updates every time a match happens. It batches updates in case of cascading matches, greatly reducing bandwidth requirements.

```json
// Request
{
    "type": "subscribe",
    "product_ids": [
        "ETH-USD",
        "BTC-USD"
    ],
    "channels": ["ticker"]
}
```

```json
// Ticker messsage
{
  "type": "ticker",
  "sequence": 37475248783,
  "product_id": "ETH-USD",
  "price": "1285.22",
  "open_24h": "1310.79",
  "volume_24h": "245532.79269678",
  "low_24h": "1280.52",
  "high_24h": "1313.8",
  "volume_30d": "9788783.60117027",
  "best_bid": "1285.04",
  "best_bid_size": "0.46688654",
  "best_ask": "1285.27",
  "best_ask_size": "1.56637040",
  "side": "buy",
  "time": "2022-10-19T23:28:22.061769Z",
  "trade_id": 370843401,
  "last_size": "11.4396987"
}
```


## Ticker Batch Channel

The `ticker_batch` channel provides latest price updates **every 5000 milliseconds** (5 seconds) if there is a change. It has the same JSON message schema as the [ticker channel](#ticker-channel).

:::info
The `ticker_1000` channel was renamed ticker_batch but you can use either name when subscribing.
:::

```json
// Request
{
    "type": "subscribe",
    "product_ids": [
        "ETH-USD",
        "BTC-USD"
    ],
    "channels": ["ticker_batch"]
}
```


## Full Channel

<Badge color="0a639a" url="./websocket-auth" label="Full Channel:Authentication Required" />

The `full` channel provides real-time updates on orders and trades. These updates can be applied to a level3 order book snapshot to maintain an accurate and up-to-date copy of the exchange order book.

To maintain an up-to-date level3 order book: 

1. Send a `subscribe` message for the product(s) of interest and the `full` channel.
2. Queue any messages received over the websocket stream.
3. Make a REST request for the order book snapshot from the REST feed.
4. Playback queued messages, discarding sequence numbers before or equal to the snapshot sequence number.
5. Apply playback messages to the snapshot as needed (see below).
6. After playback is complete, apply real-time stream messages as they arrive.

:::info
All `open` and `match` messages always result in a change to the order book. Not all `done` or `change` messages result in changing the order book. These messages are sent for received orders which are not yet on the order book. Do not alter the order book for such messages, otherwise your order book will be incorrect.
:::

The following messages are sent over the websocket stream in JSON format when subscribing to the full channel:

### Received

_A valid order has been received and is now active._

This message is emitted for every single valid order as soon as the matching engine receives it, whether it fills immediately or not.

The `received` message does not indicate a resting order on the order book. The `received` message indicates that a new incoming order has been accepted by the matching engine for processing. Received orders may cause `match` message to follow if they are able to begin being filled (taker behavior).

[Self-trade prevention](./intro-matching-engine.md#self-trade-prevention) may also trigger `change` messages to follow if the order size needs to be adjusted. Orders that are not fully filled or that are canceled due to self-trade prevention, result in an `open` message and become resting orders on the order book.

Market orders (indicated by the `order_type` field) may have an optional `funds` field which indicates how much quote currency is used to buy or sell. For example, a `funds` field of `100.00` for the `BTC-USD` product would indicate a purchase of up to `100.00 USD` worth of bitcoin.


:::caution
`client-oid` is only available in the **authenticated** `full` channel and the [user channel](./websocket-channels.mdx#user-channel) (which is also authenticated). You can only see your own `client-oid`.
:::

Received message for limit order:
```json
{
  "type": "received",
  "time": "2014-11-07T08:19:27.028459Z",
  "product_id": "BTC-USD",
  "sequence": 10,
  "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
  "size": "1.34",
  "price": "502.1",
  "side": "buy",
  "order_type": "limit",
  "client-oid": "d50ec974-76a2-454b-66f135b1ea8c"
}
```

Received message for market order:
```json
{
  "type": "received",
  "time": "2014-11-09T08:19:27.028459Z",
  "product_id": "BTC-USD",
  "sequence": 12,
  "order_id": "dddec984-77a8-460a-b958-66f114b0de9b",
  "funds": "3000.234",
  "side": "buy",
  "order_type": "market",
  "client-oid": "d50ec974-76a2-454b-66f135b1ea8c"
}
```

### Open

_The order is now open on the order book._

This message is only sent for orders that are not fully filled immediately. `remaining_size` indicates how much of the order is unfilled and going on the book.

:::info
There is no `open` message for orders that are filled immediately. And there is no `open` message for market orders since they are filled immediately.
:::

```json
{
  "type": "open",
  "time": "2014-11-07T08:19:27.028459Z",
  "product_id": "BTC-USD",
  "sequence": 10,
  "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
  "price": "200.2",
  "remaining_size": "1.00",
  "side": "sell"
}
```

### Done

_The order is no longer on the order book._

This message is sent for all orders for which there was a received message and can result from an order being canceled or filled. 

There are no more messages for an `order_id` after a done message. `remaining_size` indicates how much of the order went unfilled; this is `0` for `filled` orders.

`market` orders do not have a `remaining_size` or `price` field as they are never on the open order book at a given price.

:::info
A `done` message is sent for received orders that are fully filled or canceled due to self-trade prevention. There are no `open` messages for such orders. `done` messages for orders that are not on the book should be ignored when maintaining a real-time order book.
:::

```json
{
  "type": "done",
  "time": "2014-11-07T08:19:27.028459Z",
  "product_id": "BTC-USD",
  "sequence": 10,
  "price": "200.2",
  "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
  "reason": "filled", // or "canceled"
  "side": "sell",
  "remaining_size": "0"
}
```

#### Cancel Reason

Done messages with `reason=canceled` (that are authenticated and that originated with you the user) return the reason in the `cancel_reason` field:

Supported cancel reasons are:

```
101:Time In Force
102:Self Trade Prevention
103:Admin
104:Price Bound Order Protection
105:Insufficient Funds
106:Insufficient Liquidity
107:Broker
```

### Match

_A trade occurred between two orders._

The aggressor or `taker` order is the one executing immediately after being received and the `maker` order is a resting order on the book.

The `side` field indicates the maker order side. If the side is `sell` this indicates the maker was a sell order and the `match` is considered an up-tick. A `buy` side match is a down-tick.

```json
{
  "type": "match",
  "trade_id": 10,
  "sequence": 50,
  "maker_order_id": "ac928c66-ca53-498f-9c13-a110027a60e8",
  "taker_order_id": "132fb6ae-456b-4654-b4e0-d681ac05cea1",
  "time": "2014-11-07T08:19:27.028459Z",
  "product_id": "BTC-USD",
  "size": "5.23512",
  "price": "400.23",
  "side": "sell"
}
```

If authenticated, and you were the taker, the message would also have the following fields:

```json
{
  ...
  "taker_user_id": "5844eceecf7e803e259d0365",
  "user_id": "5844eceecf7e803e259d0365",
  "taker_profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
  "profile_id": "765d1549-9660-4be2-97d4-fa2d65fa3352",
  "taker_fee_rate": "0.005"
}
```

Similarly, if you were the maker, the message would have the following:

```json
{
  ...
  "maker_user_id": "5f8a07f17b7a102330be40a3",
  "user_id": "5f8a07f17b7a102330be40a3",
  "maker_profile_id": "7aa6b75c-0ff1-11eb-adc1-0242ac120002",
  "profile_id": "7aa6b75c-0ff1-11eb-adc1-0242ac120002",
  "maker_fee_rate": "0.001"
}
```

### Change

_An order has changed._

A `change` message can be the result of either a [Self-trade Prevention (STP)](./intro-matching-engine.md#self-trade-prevention) or a Modify Order Request: 

:::info
Modify Order Request adds three new fields: `new_price`, `old_price`, `reason`. See also [FIX Modify Order Request (G)](./fix-msg-order-entry.mdx#modify-order-request-g).
:::

- A Self-trade Prevention adjusts the order size or available funds (and can only decrease). 
- A Modify Order Request adjusts the order size or price. 

`change` messages are sent anytime an order changes in size or price. This includes: 

- Orders that are open (resting) 
- Orders that are received but not yet open.
- Market orders with `funds` changed from a Self-trade Prevention control. 

:::info
If you are building a real-time order book, you can ignore `change` messages for received but not yet open orders. 
:::
>
> If you are building from a level2 book, the `side` and `price` fields to indicate whether the change message is relevant. STP Change messages for limit orders always have a price specified. STP change messages for market orders have no price (`null`) and a decrease in order size.

Example of a change message from a Self-trade Prevention action: 

> STP messages have a new `reason` field and continue to use the `price` field (not `new_price` and `old_price`).

```json
{
  "type": "change",
  "reason":"STP",
  "time": "2014-11-07T08:19:27.028459Z",
  "sequence": 80,
  "order_id": "ac928c66-ca53-498f-9c13-a110027a60e8",
  "side": "sell",
  "product_id": "BTC-USD",
  "old_size": "12.234412",
  "new_size": "5.23512",
  "price": "400.23"
}
```

Example of a change message from a Modify Order Request: 

> Modify Order messages add three new fields: `new_price`, `old_price`, `reason`.

```json
{
  "type": "change",
  "reason":"modify_order",
  "time": "2022-06-06T22:55:43.433114Z",
  "sequence": 24753,
  "order_id": "c3f16063-77b1-408f-a743-88b7bc20cdcd",
  "side": "buy",
  "product_id": "ETH-USD",
  "old_size": "80",
  "new_size": "80",
  "old_price": "7",
  "new_price": "6"
}
```

### Activate

_An activate message is sent when a stop order is placed._

When the stop is triggered the order is placed and goes through the [order lifecycle](./intro-matching-engine.md#order-lifecycle).

```json
{
  "type": "activate",
  "product_id": "test-product",
  "timestamp": "1483736448.299000",
  "user_id": "12",
  "profile_id": "30000727-d308-cf50-7b1c-c06deb1934fc",
  "order_id": "7b52009b-64fd-0a2a-49e6-d8a939753077",
  "stop_type": "entry",
  "side": "buy",
  "stop_price": "80",
  "size": "2",
  "funds": "50",
  "private": true
}
```


## User Channel

<Badge color="0a639a" url="./websocket-auth" label="User Channel:Authentication Required" />

The `user` channel is a version of the [full channel](#full-channel) and only contains messages that include the authenticated user. Consequently, you need to be [authenticated](./websocket-auth#authentication) to receive any messages.

:::caution
Modify Order Request is a new feature that affects the [Full Channel, Change](./websocket-channels.mdx#change) message, and by extension, the User channel. 
:::


## Level2 Channel

<Badge color="0a639a" url="./websocket-auth" label="Level2 Channel:Authentication Required" />

The `level2` channel guarantees delivery of all updates and is the easiest way to keep a snapshot of the order book. This channel also reduces the overhead required when consuming the [full channel](#full-channel).

```json
// Request
{
    "type": "subscribe",
    "channels": ["level2"],
    "product_ids": [
        "ETH-USD",
        "BTC-USD"
    ]
}
```

:::tip
The [Level2 Batch Channel](./websocket-channels.mdx#level2-batch-channel) does not require authenticaion and delivers Level 2 data in batches every 50 milliseconds.
:::

The `level2` channel sends a message with the type `snapshot` and the corresponding `product_id`. The properties `bids` and `asks` are arrays of `[price, size]` tuples and represent the entire order book.

```json
{
  "type": "snapshot",
  "product_id": "BTC-USD",
  "bids": [["10101.10", "0.45054140"]],
  "asks": [["10102.55", "0.57753524"]]
}
```

Subsequent updates have the type `l2update`. The `changes` property of `l2update`s is an array with `[side, price, size]` tuples. The `time` property of `l2update` is the time of the event as recorded by our trading engine.

##### Single `changes` Array

```json
{
  "type": "l2update",
  "product_id": "BTC-USD",
  "time": "2019-08-14T20:42:27.265Z",
  "changes": [
    [
      "buy",
      "10101.80000000",
      "0.162567"
    ]
  ]
}
```

##### Multiple `changes` Arrays

```json
{
  "type": "l2update",
  "product_id": "BTC-USD",
  "changes": [
    [
      "buy",
      "22356.270000",
      "0.00000000"
    ],
    [
      "buy",
      "22356.300000",
      "1.00000000"
    ]
  ],
  "time": "2022-08-04T15:25:05.010758Z"
}
```

:::info
The `size` property is the updated size at the price level, not a delta. A size of `"0"` indicates the price level can be removed.
:::


## Level2 Batch Channel

The `level2_batch` channel sends batches of `level2` messages **every 50 milliseconds** (0.05 seconds). It has the same JSON message schema as the [`level2` channel](#level2-channel). The time field correlates to the most recent message in the batch.

:::tip
The `level2_batch` channel lets you receive [`level2`](#level2-channel) data _without authenticating_. You get the same benefits while minimizing traffic.
:::


```json
// Request
{
    "type": "subscribe",
    "product_ids": [
        "ETH-USD",
        "BTC-USD"
    ],
    "channels": ["level2_batch"]
}
```

:::info
The `level2_50` channel was renamed `level2_batch` but you can use either when subscribing.
:::


## Level3 Channel

<Badge color="0a639a" url="./websocket-auth" label="Level3 Channel:Authentication Required" />

The `level3` channel is a compact version of the Full channel. It conveys all of the same data in a compact message structure that requires less bandwidth with potentially more efficient client side parsing. 

```json
// Subscribe request
{
    "type": "subscribe",
    "channels": ["level3"],
    "product_ids": [
        "ETH-USD",
        "BTC-USD"
    ]
}
```

### L3 Schema

On subscribe, the first response returns a level3 schema with the structure for each message type. The schema is not repeated. 

:::caution Level3 Message Structures
You should process level3 message structures before parsing the subsequent messages. While the schema should not change, it may. 
:::

<details>
<summary><b>Expand to view the full level3 schema</b></summary>
<div>

```
{
  "type": "level3",
  "schema": {
    "change": [
      "type",
      "product_id",
      "sequence",
      "order_id",
      "price",
      "size",
      "time"
    ],
    "done": [
      "type",
      "product_id",
      "sequence",
      "order_id",
      "time"
    ],
    "match": [
      "type",
      "product_id",
      "sequence",
      "maker_order_id",
      "taker_order_id",
      "price",
      "size",
      "time"
    ],
    "noop": [
      "type",
      "product_id",
      "sequence",
      "time"
    ],
    "open": [
      "type",
      "product_id",
      "sequence",
      "order_id",
      "side",
      "price",
      "size",
      "time"
    ]
  }
}
```
</div>
</details>

Subsequent messages for each type pack the data into an array with a structure as defined in the initial response, for example: 

```
[
  "open",
  "BTC-USD",
  "57560479456",
  "12aca6e0-7400-418a-9e59-c0020a3bf8cc",
  "buy",
  "27268.09",
  "0.02",
  "2023-03-28T23:24:03.185394Z"
]
```


## Balance Channel

<Badge color="0a639a" url="./websocket-auth" label="Balance Channel:Authentication Required" />

The `balance` channel tracks account balance updates, which is useful for checking the holds and available balance on your account. It does _not_ track every update. Authentication is required.

Clients are recommended to subscribe to this channel for accounts with frequent balance changes as accounts without any changes do not receive updates.

#### Fields

A response from the channel includes the following fields:

```
{
  "type": "balance",
  "account_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
  "currency": "USD",
  "holds": "1000.23",                      // funds locked in account
  "available": "102030.99",                // balance available for trading
  "updated": "2023-10-10T20:42:27.265Z",   // when last balance change is observed
  "timestamp": "2023-10-10T20:42:29.265Z"  // when message is sent from websocket
}
```

#### Subscribe

Clients can subscribe to this channel using the following subscribe messages:

##### Example 1

```
{
  "type": "subscribe",
  "channels": [
    {
      "name": "balance",
      "account_ids": [
        "d50ec984-77a8-460a-b958-66f114b0de9b",
        "d50ec984-77a8-460a-b958-66f114b0de9a"
      ]
    }
  ]
}
```

##### Example 2

```
{
  "type": "subscribe",
  "channels": [
    "balance"
  ],
  "account_ids": [
    "d50ec984-77a8-460a-b958-66f114b0de9b",
    "d50ec984-77a8-460a-b958-66f114b0de9a"
  ]
}
``` 



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-connectivity.mdx -->

---
title: "Exchange FIX API Connectivity"
sidebar_label: "Connectivity"
slug: "fix-connectivity"
hide_table_of_contents: false
---

{/* Import reusable content snippets */}

import Fix5AutoLogoutSaturdays from './\_snippet-fix5-auto-logout.mdx';

[Financial Information eXchange](http://en.wikipedia.org/wiki/Financial_Information_eXchange), or FIX, is a standard protocol which can be used to enter orders, submit cancel requests, and receive fills. FIX API users typically have existing software that runs FIX for order management.

The baseline specification for the Exchange FIX API is mixed:

- Order Entry: [FIX 4.2 SP2](https://www.onixs.biz/fix-dictionary/4.2/index.html)
- Market Data: [FIX 5.0 SP2](https://www.onixs.biz/fix-dictionary/5.0/index.html)

<Fix5AutoLogoutSaturdays />

## Supported Endpoints

:::info
**Production**<br />
Order Entry (FIX42): <code>VAR::FIX_URL_PROD_ORDER_ENTRY </code><br />
Order Entry (FIX50): <code>VAR::FIX_URL_PROD_ORDER_ENTRY_FIVE </code><br />
Market Data (FIX50): <code>VAR::FIX_URL_PROD_MARKET_DATA </code><br /><br />

**Sandbox**<br />
Order Entry (FIX42): <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FOUR </code><br />
Order Entry (FIX50): <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FIVE </code><br />
Market Data (FIX50): <code>VAR::FIX_URL_SAND_MARKET_DATA_FIVE </code>
:::

:::caution Resend Requests
Resend requests are not supported. Every connection establishes a new session and a new set of session sequence numbers.
:::

## FIX Gateway

Before logging onto a FIX session, clients must establish a secure connection to the FIX gateway. See the [available endpoints](#supported-endpoints) above.

**TCP SSL**

If your FIX implementation does not support establishing a **native TCP SSL connection**, you must setup a local proxy such as [stunnel](https://www.stunnel.org) to establish a secure connection to the FIX gateway.

**Static IP**

Coinbase Exchange **does not** support static IP addresses. If your firewall rules require a static IP address, you must create a TCP proxy server with a static IP address which is capable of resolving an IP address using DNS.

**AWS IP**

If connecting from servers **outside of AWS** which require firewall rules, use the [AWS provided resources](https://docs.aws.amazon.com/general/latest/gr/aws-ip-ranges.html) to determine how best to whitelist AWS IP ranges.

:::info
Changes are deployed every Monday and Thursday at or near `11 AM PST`. At that time, a <strong>logout</strong> message is sent from the server to indicate the session is ending. We do not deploy on US federal holidays.
:::

## Ciphers

Coinbase Exchange supports **TLSv1.2** with the following server ciphers:

| Recommend | Length   | Cipher Suite                | Elliptic Curve      |
| :-------- | :------- | :-------------------------- | :------------------ |
| Preferred | 128 bits | ECDHE-RSA-AES128-GCM-SHA256 | Curve P-256 DHE 256 |
| Accepted  | 128 bits | ECDHE-RSA-AES128-SHA256     | Curve P-256 DHE 256 |
| Accepted  | 256 bits | ECDHE-RSA-AES256-GCM-SHA384 | Curve P-256 DHE 256 |
| Accepted  | 256 bits | ECDHE-RSA-AES256-SHA384     | Curve P-256 DHE 256 |

## SSL Tunnels

[Exchange FIX API endpoints](./fix-connectivity.mdx#supported-endpoints) only accept TCP connections secured by SSL. If your FIX client library cannot establish an SSL connection natively, you must run a local proxy that establishes a secure connection and allows unencrypted local connections.



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-msg-market-data.mdx -->

---
title: "Exchange FIX Market Data Messages 5.0"
sidebar_label: Market Data Messages
slug: "fix-msg-market-data"
hide_table_of_contents: false
---

{/* Import reusable content snippets */}

import Fix5AutoLogoutSaturdays from './\_snippet-fix5-auto-logout.mdx';

The FIX market data API provides an L3 feed only with direct, low-latency, deterministic access.

About this API:

- **Baseline**: [FIX 5.0 SP2 specification](https://www.onixs.biz/fix-dictionary/5.0.sp2/index.html).
- **Environments**: Production, Sandbox

:::info Environment URLs

- Production Snapshot Enabled Gateway: <code>VAR::FIX_URL_PROD_MARKET_DATA </code>
- Production Snapshot Disabled Gateway: <code>VAR::FIX_URL_PROD_MARKET_DATA_SNAPSHOT_FREE </code>
- Sandbox Snapshot Enabled Gateway: <code>VAR::FIX_URL_SAND_MARKET_DATA_FIVE </code>
- Sandbox Snapshot Disabled Gateway: <code>VAR::FIX_URL_SAND_MARKET_DATA_FIVE_SNAPSHOT_FREE</code>

:::

You can connect with the same authentication as our existing FIX order entry system. Connectivity is limited to a single connection per API key&mdash;Order Entry [rate limits](./fix-rate-limits.md) _do not apply_ (connections, rps, burst rps).



<Fix5AutoLogoutSaturdays />

## Header

A standard header must be present at the start of every message in both directions.

| Tag | FieldName    | Type   | Required | Notes                                        |
| :-- | :----------- | :----- | :------- | :------------------------------------------- |
| 8   | BeginString  | String | Y        | Must be `FIXT.1.1`                           |
| 49  | SenderCompID | String | Y        | Client API key (on messages from the client) |
| 56  | TargetCompID | String | Y        | Must be `Coinbase` (on messages from client) |

## Logon (35=A)

| Tag  | FieldName        | Type   | Required | Notes                                                     |
| :--- | :--------------- | :----- | :------- | :-------------------------------------------------------- |
| 34   | MsgSeqNum        | Int    | Y        | Must be `1`                                               |
| 98   | EncryptMethod    | Int    | Y        | Must be `0` (None)                                        |
| 108  | HeartBtInt       | Int    | Y        | Heartbeat interval is capped at 300s, defaults to 10s     |
| 553  | Username         | String | Y        | Client API Key                                     |
| 554  | Password         | String | Y        | Client API passphrase                                     |
| 95   | RawDataLength    | Int    | Y        | Number of bytes in RawData field                          |
| 96   | RawData          | String | Y        | [Client message signature](./rest-auth.md#signing-a-message) |
| 1137 | DefaultApplVerID | String | Y        | Must be `9` (FIX 5.0 SP2)                                 |

## Market Data Request (35=V)

Clients should use this message to subscribe to or unsubscribe from market data for one or more symbols.

| Tag  | FieldName               | Type   | Required | Notes                                                                |
| :--- | :---------------------- | :----- | :------- | :------------------------------------------------------------------- |
| 262  | MDReqID                 | String | Y        | Client identifier for the market data request                        |
| 263  | SubscriptionRequestType | Int    | Y        | 1=Subscribe<br />2=Unsubscribe                                       |
| 146  | NoRelatedSym            | Int    | Y        | How many symbols are in the request                                  |
| =>55 | Symbol                  | String | Y        | Repeating group of symbols for which the client requests market data |

<!---
The arrow (=>) indicates that this property is within a FIX repeating group. If we had multiple entries within a single fix message, you'd see each of those tags more than once for each respective group. Presently, we are always sending a single group per incremental update, but we still denote that these properties (279,269,278, etc) fall within a group.
--->

#### Market Data Request Reject (35=Y)

This message is sent to clients to reject an invalid market data request.

| Tag | FieldName      | Type   | Required | Notes                                                  |
| :-- | :------------- | :----- | :------- | :----------------------------------------------------- |
| 262 | MDReqID        | String | Y        | Client identifier for the market data request          |
| 281 | MDReqRejReason | Char   | Y        | 0=Unknown symbol<br />1=Duplicate MDReqID<br />7=Other |
| 58  | Text           | String | N        | Error description                                      |

## Security Status (35=f)

This message is streamed to clients together with the incremental updates for subscribed symbols and reflects changes in the trading status, tick size, or other attributes of an instrument.

| Tag   | FieldName               | Type    | Required | Notes                                                                                                                  |
| :---- | :---------------------- | :------ | :------- | :--------------------------------------------------------------------------------------------------------------------- |
| 262   | MDReqID                 | String  | Y        | Client identifier for the market data request                                                                          |
| 83    | RptSeq                  | Long    | Y        | Public sequence number by symbol                                                                                       |
| 55    | Symbol                  | String  | Y        | Repeating group of symbols for which the client requests market data                                                   |
| 1682  | MDSecurityTradingStatus | String  | Y        | `trading_disabled`<br />`cancel_only`<br />`post_only`<br />`limit_only`<br />`full_trading`<br />`auction_mode`<br /> |
| 969   | MinPriceIncrement       | Decimal | Y        | Minimum increment for quote currency (e.g., 0.01 USD for BTC-USD)                                                      |
| 29003 | MinSizeIncrement        | Decimal | Y        | Minimum increment for base currency (e.g., 0.00000001 BTC for BTC-USD)                                                 |

## Market Data Incremental Refresh (35=X)

Coinbase Exchange sends L3 order-by-order updates so clients can build a full book of all open orders, plus acknowledgements of orders by the matching engine with the order’s client order ID (ClOrdID) before matching. This helps clients immediately identify which orders and trades in the book (both aggressive and passive) are theirs, as well gain advance knowledge of orders that are pending processing by the matching engine. These acks correspond to the `Received` message in the web-socket feed.

- When `MDEntryID` is not present, the message is the acknowledgement of an order prior to matching.
- When `MDEntryID` is present, the message should be used for book-building. You can ignore Change messages with an MDEntryID for which you never received a New message.

:::info
When book-building, Change messages received before a corresponding New message can be ignored. Users may occasionally receive Change messages with `MDUpdateAction=1` and an MDEntryID with `Text=CHANGE_REASON_STP` when the quantity on the original received order was reduced due to Self-trade Prevention (prior to the order being placed on the order book).

If the order has any remaining quantity resting on the book after any aggressive trades, customers will receive a New message with `MDUpdateAction=0` and the same MDEntryID with MDEntrySize reflecting the remaining passively resting quantity of the order.
:::

:::info
To maintain an up-to-date L3 order book when subscribing to the Snapshot Disabled Gateway:

1. Send a `SubscriptionRequestType=1` Market Data Request (35=V) message for the product(s) of interest.
2. Queue any Market Data Incremental Refresh (35=X) messages received over the FIX session.
3. Make a [REST request](/exchange/reference/exchangerestapi_getproductbook#levels) for the order book snapshot from the REST API.
4. Playback queued messages, discarding sequence numbers before or equal to the snapshot sequence number.
5. Apply playback messages to the snapshot as needed.
6. After playback is complete, apply real-time Market Data Incremental Refresh (35=X) messages as they arrive.
:::

| Tag     | FieldName      | Type         | Required | Notes                                                                                                                                                                                                                                           |
| :------ | :------------- | :----------- | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 262     | MDReqID        | String       | Y        | Client identifier for the market data request                                                                                                                                                                                                   |
| 268     | NoMDEntries    | Int          | Y        | Always `1`                                                                                                                                                                                                                                      |
| =>279   | MDUpdateAction | Char         | Y        | 0=New<br />1=Change<br />2=Delete                                                                                                                                                                                                               |
| =>269   | MDEntryType    | Char         | Y        | 0=Bid<br />1=Offer<br />2=Trade                                                                                                                                                                                                                 |
| =>278   | MDEntryID      | String       | N        | If present, this ID is the order ID that should be used for book-building<br />If not present, this message is the initial ack and should not be used to build the book                                                                         |
| =>83    | RptSeq         | Long         | Y        | Public sequence number by symbol                                                                                                                                                                                                                |
| =>55    | Symbol         | String       | Y        | Repeating group of symbols for which the client requests market data                                                                                                                                                                            |
| =>270   | MDEntryPx      | Decimal      | Y        | The price of the order                                                                                                                                                                                                                          |
| =>271   | MDEntrySize    | Decimal      | Y        | The quantity remaining of the order                                                                                                                                                                                                             |
| =>60    | TransactTime   | UTCTimestamp | Y        | The engine timestamp of the order in microseconds                                                                                                                                                                                               |
| =>40    | OrdType        | Char         | N        | Sent only if the message represents the initial ack of an order:<br />1=Market<br />2=Limit                                                                                                                                                     |
| =>11    | ClOrdID        | String       | N        | The client order ID on the initial ack of an order                                                                                                                                                                                              |
| =>37    | OrderID        | String       | N        | The exchange order ID on the initial ack of an order<br />OR<br />If MDEntryType=2, then this is the aggressive Order ID                                                                                                                        |
| =>58    | Text           | String       | N        | If MDEntryType=1, then the possible values are:<br />`CHANGE_REASON_STP`<br />`CHANGE_REASON_MODIFY_ORDER`<br />`CHANGE_REASON_REMAINDER_AFTER_MODIFICATION`<br />If MDEntryType=2, then the possible values are:<br />`CANCELED`<br />`FILLED` |
| =>5797  | AggressorSide  | Int          | N        | Sent only on trades MDEntryType=2<br />1=Buy<br />2=Sell                                                                                                                                                                                        |
| =>29004 | Funds          | Decimal      | N        | Market orders may have an optional funds field which indicates how much quote currency is used to buy or sell                                                                                                                                   |

## Market Data Snapshot Full Refresh (35=W)

:::caution Only Available On Snapshot Enabled Gateway
The Market Data Snapshot Full Refresh (35=W) message is only supported on the Snapshot Enabled Gateway.
:::

This message provides a full snapshot of all orders in the order book, including those placed before the client subscribed to incremental market data.

A snapshot is requested automatically when a successful Market Data Request from the client is processed for a given symbol. Clients should queue up incremental updates and process only the incremental updates with sequence number RptSeq greater than the RptSeq in the initial MD Snapshot Full Refresh snapshot message.

If clients are already subscribed to a symbol and send another Market Data Request to subscribe, they will not receive a new snapshot for that symbol. Clients must unsubscribe and subscribe to the market data again for a given symbol to receive a new snapshot.

| Tag   | FieldName               | Type    | Required | Notes                                                                                                            |
| :---- | :---------------------- | :------ | :------- | :--------------------------------------------------------------------------------------------------------------- |
| 262   | MDReqID                 | String  | Y        | Client identifier for the market data request                                                                    |
| 83    | RptSeq                  | Long    | Y        | Public sequence number for the final update in the snapshot by symbol                                            |
| 893   | LastFragment            | Char    | Y        | Is this the last message in the snapshot for a given symbol<br />Y=Yes<br />N=No                                 |
| 55    | Symbol                  | String  | Y        | Repeating group of symbols for which the client requests market data                                             |
| 268   | NoMDEntries             | Int     | Y        | Number of orders to be added to the book in this snapshot message                                                |
| 1682  | MDSecurityTradingStatus | String  | Y        | `trading_disabled`<br />`cancel_only`<br />`post_only`<br />`limit_only`<br />`full_trading`<br />`auction_mode` |
| =>269 | MDEntryType             | Char    | Y        | 0=Bid<br />1=Offer                                                                                               |
| =>278 | MDEntryID               | String  | Y        | The order ID that should be added to the book                                                                    |
| =>270 | MDEntryPx               | Decimal | Y        | The price of the order                                                                                           |
| =>271 | MDEntrySize             | Decimal | Y        | The quantity remaining of the order                                                                              |

## Security List Request (35=x)

This message is sent by clients to request a full list of instruments that Coinbase Exchange supports together with each instrument’s trading status, tick size, minimum order quantity, and any other descriptive fields.

| Tag | FieldName               | Type   | Required | Notes                             |
| :-- | :---------------------- | :----- | :------- | :-------------------------------- |
| 320 | SecurityReqID           | String | Y        | Client identifier for the request |
| 559 | SecurityListRequestType | Int    | Y        | Always 4=All Securities           |

## Security List (35=y)

Instrument definition messages are returned in response to a client’s Security List Request.

| Tag     | FieldName               | Type    | Required | Notes                                                                                                            |
| :------ | :---------------------- | :------ | :------- | :--------------------------------------------------------------------------------------------------------------- |
| 320     | SecurityReqID           | String  | Y        | Client identifier for the request                                                                                |
| 322     | SecurityResponseID      | String  | Y        | Response ID for the Security List Request                                                                        |
| 560     | SecurityRequestResult   | Int     | Y        | 0=Valid Request<br />1=Invalid Request                                                                           |
| 893     | LastFragment            | Char    | Y        | Is this the last instrument definition message in response to the original request<br />Y=Yes<br />N=No          |
| 393     | TotNoRelatedSym         | Int     | Y        | Total number of symbols that will be sent cumulatively                                                           |
| 146     | NoRelatedSym            | Int     | Y        | How many symbols are in this FIX message                                                                         |
| 1682    | MDSecurityTradingStatus | String  | Y        | `trading_disabled`<br />`cancel_only`<br />`post_only`<br />`limit_only`<br />`full_trading`<br />`auction_mode` |
| =>55    | Symbol                  | String  | Y        | Repeating group of symbols for which the client requests market data                                             |
| =>15    | Currency                | String  | Y        | The quote currency for the symbol (e.g., USD if 55=BTC-USD)                                                      |
| =>562   | MinTradeVol             | Decimal | Y        | The minimum notional amount in quote currency terms for an order                                                 |
| =>969   | MinPriceIncrement       | Decimal | Y        | Minimum increment for quote currency (e.g., 0.01 USD for BTC-USD)                                                |
| =>29003 | MinSizeIncrement        | Decimal | Y        | Minimum increment for base currency (e.g., 0.00000001 BTC for BTC-USD)                                           |



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-msg-order-entry-50.mdx -->

---
title: "Exchange FIX Order Entry Messages 5.0"
sidebar_label: Order Entry Messages 5.0
slug: "fix-msg-order-entry-50"
hide_table_of_contents: false
---

{/* Import reusable content snippets */}
import Fix5AutoLogoutSaturdays from './\_snippet-fix5-auto-logout.mdx';

About this API:

- **Baseline**: [FIX 5.0 SP2 specification](https://www.onixs.biz/fix-dictionary/5.0.sp2/index.html).
- **Environments**: Production, Sandbox

:::info Environment URLs
- Production: <code>VAR::FIX_URL_PROD_ORDER_ENTRY_FIVE </code><br />
- Sandbox: <code>VAR::FIX_URL_SAND_ORDER_ENTRY_FIVE </code>
:::

<Fix5AutoLogoutSaturdays />

## Components

### Standard Header

Fields that go at the beginning of every message. This exists for all messages sent and received.

| Tag | Name         | Type         | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| :-- | :----------- | :----------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 8   | BeginString  | String       | Y        | Must be set to `FIXT.1.1` and be the first field in the message.<br/><br/>(Since FIX version 5.0 this field now represents the session version. The application version gets specified in [Logon](#logon-35a) message's `DefaultApplVerID (1137)` tag.)                                                                                                                                                                                                                                                                                                                                                                    |
| 9   | BodyLength   | Int          | Y        | Message length in bytes up to the checksum field (tags after `BodyLength (9)` and before `Checksum (10)`). This must be the second field in message.                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 35  | MsgType      | String       | Y        | The type of message proceeding the header, must be the third field in the message.<br/><br/><b>Supported values include:</b><br/><u>Admin Messages</u><br/>`A` = Logon<br/>`0` = Heartbeat<br/>`1` = TestRequest<br/>`3` = Reject<br/>`5` = Logout<br/><br/><u>Application Messages</u><br/>`D` = NewOrderSingle<br/>`F` = OrderCancelRequest<br/>`G` = OrderCancelReplaceRequest<br/>`H` = OrderStatusRequest<br/>`j` = BusinessMessageReject<br/>`8` = ExecutionReport<br/>`9` = OrderCancelReject<br/>`U4` = OrderCancelBatch<br/>`U5` = OrderCancelBatchReject<br/>`U6` = NewOrderBatch<br/>`U7` = NewOrderBatchReject |
| 49  | SenderCompID | String       | Y        | Client API key (on messages from the client).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 56  | TargetCompID | String       | Y        | Must be `Coinbase` (on messages from client).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 34  | MsgSeqNum    | Int          | Y        | Monotonically increasing sequence number of the message.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 43  | PossDupFlag  | Boolean      | C        | Indicates that the message was sent in response to a ResendRequest.<br />- `Y` - Sent in response to ResendRequest. Should be ignored unless message was not previously processed<br /> - `N` or null - Normal transmission                                                                                                                                                                                                                                                                                                                                                                                                |
| 52  | SendingTime  | UTCTimestamp | Y        | UTC time that the order was sent down to millisecond resolution in the format `YYYYMMDD-HH:MM:SS.sss`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 83  | RptSeq       | Int          | C        | The feed sequence number of the message corresponding to the `RptSeq` in FIX 5.0 Market Data                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |

### Standard Trailer

Fields that go at the end of every message.

| Tag | Name     | Type   | Required | Description                                                                                                                                                                                                                               |
| :-- | :------- | :----- | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 10  | CheckSum | String | Y        | Three byte checksum calculated by summing every byte in the message up to and not including the checksum field itself. This value is then moduloed by `256` and written with prefixed `0`s (if necessary) to meet the 3 byte requirement. |

## Administrative

### Logon (35=A)

First message that is required immediately upon connection to authenticate the connection. `MsgSeqNum` always equals 1 (`34=1`) on this message in both directions.

| Tag  | Name                               | Type    | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| :--- | :--------------------------------- | :------ | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 98   | EncryptMethod                      | Int     | N        | Must be `0` (None)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 108  | HeartBtInt                         | Int     | O        | Must be &le; `30` (secs). Server sends [Test Request](#testrequest-351) if client messages are not received in approximately (`HeartBtInt` x `1.5`) seconds. Server terminates session if client messages are not received in approximately (`HeartBtInt` x `2`) seconds. Defaults to `10` seconds if not value provided.                                                                                                                                                                                                                       |
| 141  | ResetSeqNumFlag                    | Boolean | Y        | Resets the sequence number. Defaults to `Y`. <br /><br />Sequence numbers from Customer => Coinbase always get reset after a disconnect.<br /><br />Sequence numbers from Coinbase => Customer are reset after a disconnect if either of these are true: <br />1. ResetSeqNumFlag not set<br />2. ResetSeqNumFlag = `Y`<br />3. Customer was not logged on using same API key more than 1 day. <br /> <br /> The max possible MsgSeqNum is 2147483647 and customers are responsible for resetting their sessions to avoid breaching this limit. |
| 553  | Username                           | String  | Y        | Client API Key.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 554  | Password                           | String  | Y        | Passphrase for Client API key.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 95   | RawDataLength                      | Int     | Y        | Number of bytes in `RawData` field.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 96   | RawData                            | String  | Y        | Client message signature (see [Signing a message](./rest-auth.md#signing-a-message))                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 1137 | DefaultApplVerID                   | String  | Y        | Contains the version of the FIX protocol the exchange uses. Only FIX50SP2 is supported.<br/><br/><b>Supported values:</b><br/><code>9</code> = FIX50SP2                                                                                                                                                                                                                                                                                                                                                                                         |
| 8001 | DefaultSelfTradePreventionStrategy | Char    | N        | The default SelfTradePreventionStrategy applied to all orders sent on the session unless overridden on a per order basis using the SelfTradeType (7928) in the order request message.<br/><br/>The following values specify what to do when two orders submitted by the same portfolio attempt to match:<br/>`N` = Cancel aggressing order<br/>`Q` = Cancel both orders<br/><br/>Default if not specified is Cancel both orders (`Q`).                                                                                                          |
| 8013 | CancelOrdersOnDisconnect           | Char    | N        | `S` = Cancel all session orders on disconnect<br/>`Y` = Cancel all profile orders on disconnect <b>(recommended)</b>                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 9406 | DropCopyFlag                       | Char    | N        | `N` = Normal order-entry session<br/>`Y` = Drop Copy Session that only returns fills (Execution Report - Filled and Execution Report - Partially Filled)                                                                                                                                                                                                                                                                                                                                                                                        |

### Heartbeat (35=0)

Sent at a prearranged interval from both sides to indicate liveness of the connections and used in response to a [TestRequest](#testrequest-351) message (35=1).

| Tag | Name      | Type   | Required | Description                                                                                                                |
| :-- | :-------- | :----- | :------- | :------------------------------------------------------------------------------------------------------------------------- |
| 112 | TestReqID | String | C        | Conditionally required when the heartbeat message is sent in response to a [TestRequest](#testrequest-351) (35=1) message. |

### TestRequest (35=1)

This message forces the other side of the connection to send a [Heartbeat](#heartbeat-350) message (35=0) with the `TestReqID` (tag 112) populated with the same value provided on this message.

| Tag | Name      | Type   | Required | Description                                                       |
| :-- | :-------- | :----- | :------- | :---------------------------------------------------------------- |
| 112 | TestReqID | String | Y        | A unique identifier used to track the response to a test request. |

### ResendRequest (35=2)

Sent by the customer to Coinbase to request the retransmission of a range of messages on a given FIX session.

The Coinbase FIX gateway keeps a 4 hour history of messages sent to customers:

- Administrative messages are always replaced by [SequenceReset-GapFill](#sequencereset-354) messages during retransmission.
- Older non-administrative messages are also replaced by SequenceReset-GapFill messages.
- Retransmitted messages, including SequenceReset-GapFill messages, have PossDupFlag enabled (`43=Y`) in the header.

:::info
The maximum allowed range per request is 1000 messages and only 1 ResendRequest can be processed at a time per session.
:::

| Tag | Name       | Type | Required | Description                                                                           |
| :-- | :--------- | :--- | :------- | :------------------------------------------------------------------------------------ |
| 7   | BeginSeqNo | Int  | Y        | Sequence number of first message in range to be resent. Must be >= 1                  |
| 16  | EndSeqNo   | Int  | Y        | Sequence number of last message in range to be resent. Must be >= 1 and >= BeginSeqNo |

### SequenceReset (35=4)

Used to skip messages during retransmission. Coinbase only supports "GapFill" mode where GapFillFlag is always true.

Coinbase sends SequenceReset-GapFill messages to customers with or without PossDupFlag (43) in the header:

- Without PossDupFlag: Coinbase sends immediately after logon to reset the Coinbase sequence number to the next outbound sequence number stored for the session.
- With PossDupFlag=Y: Coinbase sends in response to a [ResendRequest](#resendrequest-352) for all administrative messages, irrespective of time sent, as well as non-administrative messages older than 4 hours.

| Tag | Name        | Type    | Required | Description           |
| :-- | :---------- | :------ | :------- | :-------------------- |
| 123 | GapFillFlag | Boolean | Y        | Always true (`123=Y`) |
| 36  | NewSeqNo    | Int     | Y        | Must be > 1           |

### Reject (35=3)

A session level reject message sent when the FIX session can't process a message.

| Tag | Name                | Type   | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| :-- | :------------------ | :----- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 45  | RefSeqNum           | Int    | Y        | The `MsgSeqNum` of the referenced message that was rejected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 371 | RefTagID            | Int    | N        | The tag number of the FIX field referenced in the reject.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 372 | RegMsgType          | String | N        | The `MsgType` of the FIX message referenced in the reject.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 373 | SessionRejectReason | Int    | N        | A code to quickly identify common reasons for a reject.<br/><br/><b>Supported values:</b><br/>`0` = Invalid Tag Number<br/>`1` = Required Tag Missing<br/>`2` = Tag not defined for this message type<br/>`3` = Undefined tag<br/>`4` = Tag specified without a value<br/>`5` = Value is incorrect (out of range) for this tag<br/>`6` = Incorrect data format for value<br/>`8` = Signature problem<br/>`9` = `CompID` problem<br/>`10` = `SendingTime` Accuracy Problem<br/>`11` = Invalid `MsgType`<br/>`13` = Tag appears more than once<br/>`14` = Tag specified out of required order<br/>`15` = Repeating group fields out of order<br/>`16` = Incorrect `NumInGroup` count for repeating group<br/>`17` = Non "Data" value includes field delimiter (&lt;SOH&gt; character)<br/>`18` = Invalid/Unsupported Application Version<br/>`99` = Other |
| 58  | Text                | String | N        | A message explaining why the message was rejected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

### Logout (35=5)

Sent by either side to initiate session termination. The side which receives this message first should reply with the same message type to confirm session termination.

| Tag | Name | Type   | Required | Description                              |
| :-- | :--- | :----- | :------- | :--------------------------------------- |
| 58  | Text | String | N        | Description of the disconnection reason. |

## Trading

### NewOrderSingle (35=D)

Used to submit a new spot order to the Exchange matching engine.

:::info
For more information on specific order variants see [Iceberg Orders](./fix-msg-oe-iceberg.mdx), [TPSL Orders](./fix-msg-oe-tpsl.md), and [Limit With Funds Orders](./fix-msg-oe-lwf.mdx).
:::

| Tag  | Name                  | Type         | Required | Description                                                                                                                                                                                                                                                                                                                                                                    |
| :--- | :-------------------- | :----------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11   | ClOrdID               | UUID         | Y        | An identifier specified by the sender to uniquely identify other messages correlating to this request. It must be a variant 1 UUIDv4 that follows the standard format. This means all lowercase and hyphens that group the characters in sequences of 8, 4, 4, 4, 12 (e.g. `1985ca2d-61ef-49f1-bfce-6c39d8462914`). Failure to follow this formatting will result in a reject. |
| 18   | ExecInst              | Char         | N        | The execution instruction flags for the order.<br/><br/><b>Supported values:</b><br/>`A` = Add Liquidity Only (Post Only)                                                                                                                                                                                                                                                      |
| 38   | OrderQty              | Decimal      | C        | The amount of the base asset to be transacted. Required except unless `CashOrderQty` is specified.                                                                                                                                                                                                                                                                             |
| 1138 | DisplayQty            | Decimal      | C        | Maximum size within an order to be displayed. Must be > 10% of OrderQty                                                                                                                                                                                                                                                                                                        |
| 152  | CashOrderQty          | Decimal      | C        | Order size in quote units (e.g., USD) (Market or [Limit order](./fix-msg-oe-lwf.mdx) only).                                                                                                                                                                                                                                                                                                                 |
| 40   | OrdType               | Char         | Y        | The type of order for the request which can be.<br/><br/><b>Supported values:</b><br/>`1` = Market<br/>`2` = Limit<br/>`4` = Stop Limit<br/>`O` = [Take Profit Stop Loss](./fix-msg-oe-tpsl.md)                                                                                                                                                                               |
| 44   | Price                 | Decimal      | C        | The limit price for limit orders of the quote asset. The decimal precision must fall within the requirements for each market, see the REST API for precision and decimal limits.                                                                                                                                                                                               |
| 54   | Side                  | Char         | Y        | Side of the order.<br/><br/><b>Supported values:</b><br/>`1` = Buy<br/>`2` = Sell                                                                                                                                                                                                                                                                                              |
| 55   | Symbol                | String       | Y        | Symbol of the instrument being traded (e.g. `BTC-USDC`)                                                                                                                                                                                                                                                                                                                        |
| 59   | TimeInForce           | Char         | Y        | Specifies how long the order remains in effect.<br/><br/><b>Supported values:</b><br/>`1` = Good Till Cancel (GTC)<br/>`3` = Immediate Or Cancel (IOC)<br/>`4` = Fill Or Kill (FOK)<br/>`6` = Good Till Date (GTD)                                                                                                                                                             |
| 126  | ExpireTime            | UTCTimestamp | C        | Required when `TimeInForce` (59) is set to `GTD` (6). Specifies the time when a GTD order expires. Required for GTD orders and should not be set for other orders. The order expires within one second after the specified time.                                                                                                                                               |
| 99   | StopPx                | Decimal      | C        | Specifies the quote price at which the order activates for Stop Limit order types (40=4)                                                                                                                                                                                                                                                                                       |
| 1109 | TriggerPriceDirection | Char         | N        | <b>Supported values:</b><br/>`U` = Trigger if market price goes UP to or through `StopPx` (default if `StopPx` is greater than current market price)<br/>`D` = Trigger if market price goes DOWN to or through `StopPx` (default if `StopPx` is less than current market price)<br/><br/><i>For stop-limit orders, this field is optional but recommended.</i>                 |
| 7928 | SelfTradeType         | Char         | N        | The following values specify what to do when two orders are submitted by the same user attempt to match:<br/><br/>`D` = Decrement and Cancel (default if not specified)<br/>`O` = Cancel Oldest (resting order)<br/>`N` = Cancel Newest (aggressing order)<br/>`B` = Cancel Both                                                                                               |

### NewOrderBatch (35=U6)

Used to submit new spot orders to the Exchange matching engine. Clients should use this message to submit multiple orders to the Exchange matching engine at the same time. Currently, all the orders submitted in a batch must be for the same symbol.

| Tag    | Name          | Type         | Required | Description                                                                                                                                                                                                                                                                                                                                                                    |
| :----- | :------------ | :----------- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 8014   | BatchID       | UUID         | Y        | An identifier specified by the sender to uniquely identify other messages correlating to this request. It must be a variant 1 UUIDv4 that follows the standard format. This means all lowercase and hyphens that group the characters in sequences of 8, 4, 4, 4, 12 (e.g. `1985ca2d-61ef-49f1-bfce-6c39d8462914`). Failure to follow this formatting will result in a reject. |
| 73     | NoOrders      | Int          | Y        | Number of orders in the request.                                                                                                                                                                                                                                                                                                                                               |
| =>11   | ClOrdID       | UUID         | Y        | An identifier specified by the sender to uniquely identify other messages correlating to this request. It must be a variant 1 UUIDv4 that follows the standard format. This means all lowercase and hyphens that group the characters in sequences of 8, 4, 4, 4, 12 (e.g. `1985ca2d-61ef-49f1-bfce-6c39d8462914`). Failure to follow this formatting will result in a reject. |
| =>18   | ExecInst      | Char         | N        | The execution instruction flags for the order.<br/><br/><b>Supported values:</b><br/>`A` = Add Liquidity Only (Post Only)                                                                                                                                                                                                                                                      |
| =>38   | OrderQty      | Decimal      | C        | The amount of the base asset to be transacted. Required except for market orders with `CashOrderQty` specified.                                                                                                                                                                                                                                                                |
| =>152  | CashOrderQty  | Decimal      | C        | The order size in quote units (e.g., USD) (Market order only).                                                                                                                                                                                                                                                                                                                 |
| =>40   | OrdType       | Char         | Y        | The type of order for the request which can be.<br/><br/><b>Supported values:</b><br/>`1` = Market<br/>`2` = Limit<br/>`4` = Stop Limit                                                                                                                                                                                                                                        |
| =>44   | Price         | Decimal      | C        | The limit price for limit orders of the quote asset. The decimal precision must fall within the requirements for each market, see the REST API for precision and decimal limits.                                                                                                                                                                                               |
| =>54   | Side          | Char         | Y        | Side of the order.<br/><br/><b>Supported values:</b><br/>`1` = Buy<br/>`2` = Sell                                                                                                                                                                                                                                                                                              |
| =>55   | Symbol        | String       | Y        | Symbol of the instrument being traded (e.g. `BTC-USDC`)                                                                                                                                                                                                                                                                                                                        |
| =>59   | TimeInForce   | Char         | Y        | Specifies how long the order remains in effect.<br/><br/><b>Supported values:</b><br/>`1` = Good Till Cancel (GTC)<br/>`3` = Immediate Or Cancel (IOC)<br/>`4` = Fill Or Kill (FOK)<br/>`6` = Good Till Date (GTD)                                                                                                                                                             |
| =>126  | ExpireTime    | UTCTimestamp | C        | Required when `TimeInForce` (59) is set to GTD (6). Specifies the time when a GTD order expires. Required for GTD orders and should not be set for other orders. The order expires within one second after the specified time.                                                                                                                                                 |
| =>99   | StopPx        | Decimal      | C        | Specifies the quote price at which the order activates for Stop Limit order types (40=4).                                                                                                                                                                                                                                                                                      |
| =>7928 | SelfTradeType | Char         | N        | Represents type of cancel instruction when two orders submitted by the same user attempt to match.<br/><br/><b>Supported values:</b><br/>`D`=Decrement and Cancel (default if not specified)<br />`O`=Cancel Oldest (resting order)<br />`N`=Cancel Newest (aggressing order)<br />`B`=Cancel Both                                                                             |

### NewOrderBatchReject (35=U7)

This message is sent by Coinbase Exchange back to clients when all the orders in a [New Order Batch](#neworderbatch-35u6) (35=U6) Request are rejected. When only some of the orders are rejected, Execution Report - Rejected messages are sent out for each of the orders individually.

| Tag  | Name    | Type   | Required | Description                                                 |
| :--- | :------ | :----- | :------- | :---------------------------------------------------------- |
| 8014 | BatchID | UUID   | Y        | Client-supplied ID identifying the new order batch request. |
| 58   | Text    | String | Y        | The reason the batch of orders was rejected.                |

### OrderCancelRequest (35=F)

:::tip Coinbase Recommends
For order cancel requests, Coinbase recommends that you use the same FIX connection that was used to place the order.
:::

Used to cancel an order that is still live on the Exchange matching engine.

| Tag | Name        | Type   | Required | Description                                                                                                                                                                                                                                                                                                                                                                    |
| :-- | :---------- | :----- | :------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11  | ClOrdID     | UUID   | Y        | An identifier specified by the sender to uniquely identify other messages correlating to this request. It must be a variant 1 UUIDv4 that follows the standard format. This means all lowercase and hyphens that group the characters in sequences of 8, 4, 4, 4, 12 (e.g. `1985ca2d-61ef-49f1-bfce-6c39d8462914`). Failure to follow this formatting will result in a reject. |
| 37  | OrderID     | UUID   | Y        | The exchange order ID of the order to be canceled.                                                                                                                                                                                                                                                                                                                             |
| 41  | OrigClOrdID | UUID   | Y        | The client order ID of the order to be canceled.<br/><br/>At least one of `OrigClOrdID` or `OrderID` must be specified.                                                                                                                                                                                                                                                        |
| 55  | Symbol      | String | Y        | Must match the message that the `OrigClOrdID` references.                                                                                                                                                                                                                                                                                                                      |

### OrderCancelReject (35=9)

This message is sent by Coinbase Exchange back to clients to reflect that an order could not be canceled on the matching engine in the following situations:

- When an [Order Cancel Request](#ordercancelrequest-35f) (35=F) is rejected (CxlRejResponseTo 434=1)
- When an [Order Cancel/Replace Request](#ordercancelreplacerequest-35g) (35=G) is rejected (CxlRejResponseTo 434=2)
- When an [Order Cancel Batch](#ordercancelbatch-35u4) (35=U4) is partially rejected (CxlRejResponseTo 434=1)

| Tag | Name             | Type   | Required | Description                                                                                    |
| :-- | :--------------- | :----- | :------- | :--------------------------------------------------------------------------------------------- |
| 11  | ClOrdID          | UUID   | Y        | Echoed back from the client request.                                                           |
| 37  | OrderID          | UUID   | C        | Echoed back from the client request.                                                           |
| 41  | OrigClOrdID      | UUID   | Y        | Echoed back from the client request.                                                           |
| 58  | Text             | String | N        | Description of why the order could not be canceled.                                            |
| 39  | OrdStatus        | Char   | Y        | <b>Always:</b><br/>`8` = Rejected                                                              |
| 102 | CxlRejReason     | Int    | N        | <b>Supported values:</b><br/>`1` = Unknown Order<br/>`2` = Broker                              |
| 434 | CxlRejResponseTo | Char   | Y        | <b>Supported values:</b><br/>`1` = Order Cancel Request<br/>`2` = Order Cancel/Replace Request |

### OrderCancelBatch (35=U4)

:::tip Coinbase Recommends
For order cancel batch requests, Coinbase recommends that you use the same FIX connection that was used to place the order.
:::

Clients should use this message to cancel multiple orders on the Exchange matching engine at the same time. Currently, all the orders canceled in a batch must be for the same symbol.

| Tag  | Name        | Type   | Required | Description                                                                                                             |
| :--- | :---------- | :----- | :------- | :---------------------------------------------------------------------------------------------------------------------- |
| 8014 | BatchID     | UUID   | Y        | Client-supplied ID identifying the order cancel batch request.                                                          |
| 73   | NoOrders    | Int    | Y        | Number of orders in the request.                                                                                        |
| =>11 | ClOrdID     | UUID   | Y        | Client-supplied ID identifying the order cancel request.                                                                |
| =>37 | OrderID     | UUID   | Y        | The exchange order ID of the order to be canceled.                                                                      |
| =>41 | OrigClOrdID | UUID   | Y        | The client order ID of the order to be canceled.<br/><br/>At least one of `OrigClOrdID` or `OrderID` must be specified. |
| =>55 | Symbol      | String | Y        | Must match the message that the `OrigClOrdID` references.                                                               |

### OrderCancelBatchReject (35=U5)

This message is sent by Coinbase Exchange back to clients when all the orders in an [Order Cancel Batch](#ordercancelbatch-35u4) (35=U4) Request could not be canceled. When only some of the orders could not be canceled, [Order Cancel Reject](#ordercancelreject-359) (35=9) messages are sent out for the orders individually.

| Tag  | Name    | Type   | Required | Description                                                    |
| :--- | :------ | :----- | :------- | :------------------------------------------------------------- |
| 8014 | BatchID | UUID   | Y        | Client-supplied ID identifying the order cancel batch request. |
| 58   | Text    | String | N        | The reason the order cancel batch request was rejected.        |

### OrderCancelReplaceRequest (35=G)

:::caution Use Original FIX Connection
You must send order cancel replace requests via the same FIX connection through which the original order was placed.
:::

Clients should use this message to modify a single order on the Exchange matching engine (only order price and order size can be modified). If order quantity is increased or order price is modified, queue priority is lost. Queue priority is maintained when order quantity is decreased.

Modified orders share the same exchange `OrderID`(37) as the parent order.

Orders are modified with "in-flight mitigation" - i.e. any partially filled quantity on the parent order is carried over to the child order and is reflected in the new order's remaining quantity `LeavesQty`(151).

| Tag | Name        | Type    | Required | Description                                                                                                                                                                                                             |
| :-- | :---------- | :------ | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11  | ClOrdID     | UUID    | Y        | The client order ID of the new order (that will replace an existing order).                                                                                                                                             |
| 37  | OrderID     | UUID    | Y        | An identifier matching the `OrderID` from the [NewOrderSingle](#newordersingle-35d), [NewOrderBatch](#neworderbatch-35u6), or [OrderCancelReplaceRequest](#ordercancelreplacerequest-35g) that this request applies to. |
| 41  | OrigClOrdID | String  | Y        | An identifier matching the `ClOrdID` from the [NewOrderSingle](#newordersingle-35d), [NewOrderBatch](#neworderbatch-35u6), or [OrderCancelReplaceRequest](#ordercancelreplacerequest-35g) that this request applies to. |
| 38  | OrderQty    | Decimal | Y        | The new amount of the base asset to be transacted.                                                                                                                                                                      |
| 44  | Price       | Decimal | Y        | The new desired limit price of the order.                                                                                                                                                                               |
| 55  | Symbol      | String  | Y        | Must match the symbol on the message that the `OrigClOrdID` references.                                                                                                                                                 |
| 40  | OrdType     | Char    | Y        | <b>Must be:</b><br/> `2` = Limit                                                                                                                                                                                        |

### OrderMassCancelRequest (35=q)

Sent by customer to Coinbase to request mass cancellation of all orders on a FIX session previously submitted by customer.

:::info
At this time, only mass cancels for Trading Sessions are supported (`530=6`).
:::

{/* <!--- PENDING FEATURE UPDATE:
Customers can mass cancel all order placed

- On a given FIX session.
- On the profile associated with the API key used to authenticate to FIX.
- On the profile associated with the API key for a given product.


For profile-based mass cancels, customers will receive an **"Execution Report - Canceled"**  only when orders were canceled on _all sessions_ on which the orders were placed, not only on the session submitting the mass cancel request.
---> */}

| Tag | Name                  | Type         | Required | Description                                                                                  |
| :-- | :-------------------- | :----------- | :------- | :------------------------------------------------------------------------------------------- |
| 11  | ClOrdID               | UUID         | Y        | Identifier of the Mass Cancel request (not the order ID to be canceled)                      |
| 530 | MassCancelRequestType | Char         | Y        | Type of orders to be canceled: <ul> <li>`6` - Cancel Orders for a Trading Session</li> </ul> |
| 60  | TransactTime          | UTCTimestamp | Y        | Request timestamp                                                                            |

{/* <!--- PENDING FEATURE UPDATE:
| 530  | MassCancelRequestType | Char         | Y        | <ul> <li>`3` - Cancel Orders for a Product on Profile</li> <li>`6` - Cancel Orders for a Trading Session</li> <li>`7 `- Cancel All Orders on Profile</li></ul> |
| 55   | Symbol                | String       | N        | If MassCancelRequestType = `3`, the product to be canceled (e.g. BTC-USD) |
---> */}

:::danger not guaranteed
Like [Cancel on Disconnect](/exchange/docs/fix-msg-order-entry-50#:~:text=8013,CancelOrdersOnDisconnect), orders that were sent by the customer, but not yet acknowledged by the exchange, are not guaranteed to be canceled.
:::

### OrderMassCancelReport (35=r)

Sent by Coinbase to the customer as an acknowledgement of an Order Mass Cancel Request for processing or a rejection of the request.

Receipt of a successful Order Mass Cancel Report does not imply that orders were canceled until "Execution Report - Canceled" is sent to customer.

| Tag | Name                  | Type   | Required | Description                                                                                                                                                                                                                                                                                     |
| :-- | :-------------------- | :----- | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11  | ClOrdID               | UUID   | Y        | ID echoed from the Order Mass Cancel Request                                                                                                                                                                                                                                                    |
| 530 | MassCancelRequestType | Char   | Y        | Echoed from the Order Mass Cancel Request: `6` - Cancel Orders for a Trading Session                                                                                                                                                                                                            |
| 531 | MassCancelResponse    | Char   | Y        | If the Order Mass Cancel Request was rejected: <ul> <li>`0` - Request Rejected</li></ul> If successful, echoed from the request: <ul> <li>`3` - Cancel Orders for a Product on Profile</li> <li>`6` - Cancel Orders for a Trading Session</li> <li>`7` - Cancel All Orders on Profile</li></ul> |
| 58  | Text                  | String | N        | A message explaining why the request was rejected                                                                                                                                                                                                                                               |

{/* <!--- PENDING FEATURE UPDATE:
| 530  | MassCancelRequestType | Char         | Y        | Echoed from the Order Mass Cancel Request: <ul> <li>`3` - Cancel Orders for a Product on Profile</li> <li>`6` - Cancel Orders for a Trading Session</li> <li>`7 `- Cancel All Orders on Profile</li></ul> |
---> */}

### ExecutionReport (35=8)

This message is sent by Coinbase Exchange back to clients to reflect changes to an order's state (accepted, replaced, restated, partially filled, filled, expired, or canceled).

| Tag   | Name                  | Type         | Required | Description                                                                                                                                                                                                                                                                                                                      |
| :---- | :-------------------- | :----------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 11    | ClOrdID               | UUID         | Y        | The client order ID of the (new) order.                                                                                                                                                                                                                                                                                          |
| 37    | OrderID               | UUID         | Y        | A unique identifier assigned by the exchange for the order.                                                                                                                                                                                                                                                                      |
| 41    | OrigClOrdID           | String       | C        | The client order ID of the parent order for [Order Cancel/Replace Requests](#ordercancelreplacerequest-35g).                                                                                                                                                                                                                     |
| 6     | AvgPx                 | Decimal      | C        | The volume-weighted average price of all fills on the order.                                                                                                                                                                                                                                                                     |
| 14    | CumQty                | Decimal      | C        | The cumulative base quantity (e.g. in BTC) filled on the order.                                                                                                                                                                                                                                                                  |
| 151   | LeavesQty             | Decimal      | C        | The remaining base quantity (e.g. in BTC) on the order.<br/><br/>Not sent for market orders that were sent using `CashOrderQty`.                                                                                                                                                                                                 |
| 17    | ExecID                | UUID         | Y        | ID identifying this execution report.                                                                                                                                                                                                                                                                                            |
| 39    | OrdStatus             | Char         | Y        | <b>Supported values:</b><br/>`0` = New<br/>`1` = Partially Filled<br/>`2` = Filled<br/>`4` = Canceled<br/>`5` = Replaced<br/>`8` = Rejected<br/>`C` = Expired (For IOC expirations)                                                                                                                                              |
| 150   | ExecType              | Char         | Y        | <b>Supported values:</b><br/>`0` = New<br/>`4` = Canceled<br/>`5` = Replaced<br/>`8` = Rejected<br/>`C` = Expired (For IOC expirations)<br/>`D` = Restated (in cases where orders are partially canceled unsolicited due to self-trade prevention)<br/>`F` = Trade<br/>`I` = Order Status (in response to Order Status Requests) |
| 55    | Symbol                | String       | Y        | The symbol of the order (e.g. BTC-USD).                                                                                                                                                                                                                                                                                          |
| 54    | Side                  | Char         | C        | <b>Supported values:</b><br/>`1` = Buy<br/>`2` = Sell                                                                                                                                                                                                                                                                            |
| 40    | OrdType               | Char         | C        | <b>Supported values:</b><br/>`1` = Market<br/>`2` = Limit<br/>`4` = Stop Limit                                                                                                                                                                                                                                                   |
| 32    | LastQty               | Char         | C        | The base quantity (e.g. in BTC) of the most recent fill on the order when `ExecType` is `F` (Trade).                                                                                                                                                                                                                             |
| 31    | LastPx                | Decimal      | C        | The price of the most recent fill on the order when `ExecType` is `F` (Trade).                                                                                                                                                                                                                                                   |
| 44    | Price                 | Decimal      | C        | The limit price of the order.                                                                                                                                                                                                                                                                                                    |
| 38    | OrderQty              | Decimal      | C        | The base quantity (e.g. in BTC) of the order.                                                                                                                                                                                                                                                                                    |
| 1138  | DisplayQty            | Decimal      | C        | Maximum size within an order to be displayed. Must be > 10% of OrderQty                                                                                                                                                                                                                                                          |
| 198   | SecondaryOrderID      | String       | C        | Assigned by party that accepts the order. Can be used to provide the OrderID (37) used by an exchange or executing system.                                                                                                                                                                                                       |
| 152   | CashOrderQty          | Decimal      | C        | The quote quantity (e.g. in USD) of the order.<br/><br/>For market orders that were submitted using `CashOrderQty` instead of `OrderQty`, this is the remaining quote quantity of the order.                                                                                                                                     |
| 58    | Text                  | String       | N        | Description of why the order was rejected, canceled, or expired.                                                                                                                                                                                                                                                                 |
| 60    | TransactTime          | UTCTimestamp | Y        | Matching engine timestamp.                                                                                                                                                                                                                                                                                                       |
| 103   | OrdRejReason          | Int          | N        | <b>Supported values:</b><br/>`0` = Broker<br/>`1` = Unknown Symbol<br/>`5` = Unknown Order                                                                                                                                                                                                                                       |
| 378   | ExecRestatementReason | Int          | N        | <b>Supported values:</b><br/>`5` = Partial Decline of `OrderQty` (in cases where orders are partially canceled unsolicited due to self-trade prevention).                                                                                                                                                                        |
| 1003  | TradeID               | String       | C        | Trade ID for a given fill used for reporting.                                                                                                                                                                                                                                                                                    |
| 1057  | AggressorIndicator    | Boolean      | C        | <b>Supported values:</b><br/>`Y` = Taker (if aggressor or auction trade)<br/>`N` = Maker                                                                                                                                                                                                                                         |
| 59    | TimeInForce           | Char         | C        | <b>Supported values:</b><br/>`1` = GTC<br/>`3` = IOC<br/>`4` = FOK<br/>`6` = GTD                                                                                                                                                                                                                                                 |
| 99    | StopPx                | Decimal      | C        | For stop-limit orders, the stop price of the order.                                                                                                                                                                                                                                                                              |
| 1109  | TriggerPriceDirection | Char         | N        | For stop-limit orders.<br/><br/><b>Supported values:</b><br/>`U` = Trigger if market price goes UP to or through `StopPx`<br/>`D` = Trigger if market price goes DOWN to or through `StopPx`                                                                                                                                     |
| 18    | ExecInst              | Char         | N        | <b>Supported values:</b><br/>`A` = Add Liquidity Only.                                                                                                                                                                                                                                                                           |
| 7928  | SelfTradeType         | Char         | N        | <b>Supported values:</b><br/>`D` = Decrement and Cancel (default if not specified)<br/>`O` = Cancel Oldest (resting order)<br/>`N` = Cancel Newest (aggressing order)<br/>`B` = Cancel Both                                                                                                                                      |
| 126   | ExpireTime            | UTCTimestamp | C        | Timestamp at which a GTD order would expire.                                                                                                                                                                                                                                                                                     |
| 136   | NoMiscFees            | Int          | C        | Repeating group for fees charged.<br/><br/>Always `1` on an order partial fill or fill.                                                                                                                                                                                                                                          |
| =>137 | MiscFeeAmt            | Decimal      | C        | See `MiscFeeBasis`.                                                                                                                                                                                                                                                                                                              |
| =>138 | MiscFeeCurr           | String       | C        | The currency that the fee is charged in.                                                                                                                                                                                                                                                                                         |
| =>139 | MiscFeeType           | String       | C        | <b>Always:</b><br/>`4` = Exchange Fees.                                                                                                                                                                                                                                                                                          |
| =>891 | MiscFeeBasis          | Int          | C        | <b>Supported values:</b><br/>`0` = Absolute (`MiscFeeAmt` is in `MiscFeeCurr` terms)<br/>`2` = Percentage (`MiscFeeAmt` should be multiplied by the fill quantity in `MiscFeeCurr` terms to calculate the fee in `MiscFeeCurr` terms)                                                                                            |

### BusinessMessageReject (35=j)

An application level reject message sent when the FIX session can't process a message.

| Tag | Name                 | Type   | Required | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| :-- | :------------------- | :----- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 45  | RefSeqNum            | Int    | N        | The `MsgSeqNum` of the referenced message that was rejected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 372 | RefMsgType           | Int    | Y        | The message type that this reject message applies to.<br/><br/><b>Supported values include:</b><br/><u>Admin Messages</u><br/>`A` = Logon<br/>`0` = Heartbeat<br/>`1` = TestRequest<br/>`3` = Reject<br/>`5` = Logout<br/><br/><u>Application Messages</u><br/>`D` = NewOrderSingle<br/>`F` = OrderCancelRequest<br/>`G` = OrderCancelReplaceRequest<br/>`H` = OrderStatusRequest<br/>`j` = BusinessMessageReject<br/>`8` = ExecutionReport<br/>`9` = OrderCancelReject<br/>`U4` = OrderCancelBatch<br/>`U5` = OrderCancelBatchReject<br/>`U6` = NewOrderBatch<br/>`U7` = NewOrderBatchReject |
| 379 | BusinessRejectRefID  | String | N        | The `ClOrdID`, `OrderID`, `BatchID`, or other identifying ID on the failed request.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 380 | BusinessRejectReason | Int    | N        | A code to quickly identify common reasons for a reject.<br/><br/><b>Supported values include:</b><br/>`1` = Other<br/>`2` = Unsupported Message Type                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 58  | Text                 | String | N        | A message explaining why the message was rejected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |

## RFQ

### Quote Request (R)

A Quote Request (R) is the start of the RFQ process. Coinbase sends a Quote Request to Liquidity Providers (LPs) on behalf of a customer looking to participate in an RFQ trade. LPs respond to a Quote Request with a [Quote](#quote-s).

| Tag | Name             | Type         | Required | Notes                                                                                                                                                                                                                                                           |
| :-- | :--------------- | :----------- | :------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 131 | QuoteReqID       | UUID         | Y        | Unique identifier for RFQ                                                                                                                                                                                                                                       |
| 146 | NoRelatedSym     | NumInGroup   | Y        | Always 1                                                                                                                                                                                                                                                        |
| 55  | Symbol           | String32     | Y        | Example: `BTC-AVAX`                                                                                                                                                                                                                                             |
| 38  | OrderQty         | Float64      | Y        | The quantity the customer is looking to trade via RFQ                                                                                                                                                                                                           |
| 62  | ValidUntilTime   | UTCTimestamp | Y        | The time by which quotes must be submitted for the RFQ                                                                                                                                                                                                          |
| 303 | QuoteRequestType | Char         | Y        | Always 2 = Automatic Acceptance                                                                                                                                                                                                                                 |
| 126 | ExpireTime       | UTCTimestamp | Y        | The time by which the RFQ expires if there is no match                                                                                                                                                                                                          |
| 136 | NoMiscFees       | NumInGroup   | Y        | Always 1                                                                                                                                                                                                                                                        |
| 137 | MiscFeeAmt       | Float64      | Y        | Fee as a percentage that Liquidity Providers are charged on a winning Quote. <br /><br /> The fee is charged in the currency the LP receives (e.g., in BTC if LP is buying BTC-AVAX, or in AVAX if LP is selling BTC-AVAX). <br /><br />Example: 0.0005 (5 bps) |
| 139 | MiscFeeType      | Int32        | Y        | Always 4 = Exchange Fees                                                                                                                                                                                                                                        |
| 891 | MiscFeeBasis     | Int32        | Y        | Always 2 = Percentage                                                                                                                                                                                                                                           |

### Quote (S)

Quote (S) messages are submitted by Liquidity Providers (LP) in response to a [Quote Request](#quote-request-r) in order to participate in the competitive RFQ auction.

Quotes can be submitted as either a one-way or two-way quote, and must be received by the `ValidUntilTime (62)` specified in the Quote Request. Only one side is traded if the Liquidity Provider wins the RFQ.

| Tag | Name       | Type     | Required | Notes                                                                       |
| :-- | :--------- | :------- | :------- | :-------------------------------------------------------------------------- |
| 131 | QuoteReqID | UUID     | Y        | Unique identifier for RFQ echoed from Quote Request                         |
| 117 | QuoteID    | UUID     | Y        | Unique identifier for Quote specified by Liquidity Provider                 |
| 55  | Symbol     | String32 | Y        | Example: `BTC-AVAX`                                                         |
| 132 | BidPx      | Float64  | C        | Required if submitting bid                                                  |
| 133 | OfferPx    | Float64  | C        | Required if submitting offer                                                |
| 134 | BidSize    | String32 | C        | Required if submitting bid. Must match `OrderQty (38)` from Quote Request   |
| 135 | OfferSize  | String32 | C        | Required if submitting offer. Must match `OrderQty (38)` from Quote Request |

### Quote Status Report (AI)

Quote Status Reports are sent to Liquidity Providers with [Quote](#quote-s) statuses and expired [Quote Requests](#quote-request-r).

- If the [Quote](#quote-s) is rejected b/c validation checks failed or it was sent too late, the response to the quoter is `297=5` (QuoteStatus = Rejected).
- If the [Quote](#quote-s) is accepted and eligible to participate in an RFQ auction, the response to the quoter is `297=16` (QuoteStatus = Active).
- If the [Quote](#quote-s) is accepted but not selected for execution, the response to the quoter is `297=17` (QuoteStatus = Canceled).
- If the [Quote](#quote-s) is accepted and selected for execution, the response to the quoter is `297=19` (QuoteStatus = Pending End Trade), followed by Execution Report - Filled.
- If the [Quote Request](#quote-request-r) is unmatched by `ExpireTime (126)` on the Quote Request, `297=7` (QuoteStatus = Expired) is broadcast to all LPs.

| Tag | Name           | Type         | Required | Notes                                                                                                                                                                                                                                                                                                                                                                |
| :-- | :------------- | :----------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 131 | QuoteReqID     | UUID         | Y        | Unique identifier for RFQ echoed from Quote Request                                                                                                                                                                                                                                                                                                                  |
| 117 | QuoteID        | UUID         | C        | Unique identifier for Quote specified unless QuoteStatus = Expired (`297=7`)                                                                                                                                                                                                                                                                                         |
| 55  | Symbol         | String32     | Y        | Example: `BTC-AVAX`                                                                                                                                                                                                                                                                                                                                                  |
| 54  | Side           | Char         | C        | Buy: `54=1`, Sell: `54=2`<br /> Specified if QuoteStatus=Pending End Trade (`297=19`)                                                                                                                                                                                                                                                                                |
| 38  | OrderQty       | Float64      | Y        | Echoed from Quote Request                                                                                                                                                                                                                                                                                                                                            |
| 132 | BidPx          | Float64      | C        | Echoed from Quote                                                                                                                                                                                                                                                                                                                                                    |
| 133 | OfferPx        | Float64      | C        | Echoed from Quote                                                                                                                                                                                                                                                                                                                                                    |
| 134 | BidSize        | Float64      | C        | Echoed from Quote                                                                                                                                                                                                                                                                                                                                                    |
| 135 | OfferSize      | Float64      | C        | Echoed from Quote                                                                                                                                                                                                                                                                                                                                                    |
| 62  | ValidUntilTime | UTCTimestamp | Y        | Echoed from Quote Request                                                                                                                                                                                                                                                                                                                                            |
| 126 | ExpireTime     | UTCTimestamp | Y        | Echoed from Quote Request                                                                                                                                                                                                                                                                                                                                            |
| 297 | QuoteStatus    | Int32        | Y        | `5` = <b>Rejected</b>: Quote failed validation checks or was sent too late<br /> `7` = <b>Expired</b>: Quote Request expired w/no match<br /> `16` = <b>Active</b>: Quote was acknowledged<br /> `17` = <b>Canceled</b>: Quote not selected b/c LP did not win auction or had insufficient funds<br /> `19` = <b>Pending End Trade</b>: Quote selected for execution |
| 58  | Text           | String       | C        | Reason the Quote was rejected if QuoteStatus=5<br /><br /> Can also be “Unable to hold funds” if QuoteStatus=17                                                                                                                                                                                                                                                      |

### RFQ Request (AH)

Request For Quote (RFQ) allows Liquidity Providers to respond to, and interact with, real-time RFQ requests. The RFQ process begins with [Quote Request (R)](#quote-request-r).

RFQ is enabled for users who have been approved by Coinbase as a Liquidity Provider. Once approved, clients must send an RFQ Request message (`35=AH`) after each successful Logon message (`35=A`) for any session in which they are interested in receiving Quote Requests.

| Tag | Name     | Type | Required | Notes                             |
| :-- | :------- | :--- | :------- | :-------------------------------- |
| 644 | RFQReqID | UUID | Y        | Unique identifier for RFQ Request |

:::tip
_Not_ receiving a response is expected and indicative of a successful RFQ Request.
:::



<!-- File: /Users/tinahe/docs/projects/exchange/docs/_snippet-fix5-auto-logout.mdx -->

:::caution FIX5 Resets Saturdays at 1PM ET
FIX5 Order Entry and Market Data customers will be logged out every Saturday at 1PM ET.
:::


<!-- File: /Users/tinahe/docs/projects/exchange/docs/getting-started.mdx -->

---
title: "Getting Started with Exchange APIs"
sidebar_label: "Getting Started"
slug: "getting-started"
---

To get started with Exchange APIs, generate an API key at [exchange.coinbase.com](https://exchange.coinbase.com).

1. Go to [exchange.coinbase.com/apikeys](https://exchange.coinbase.com/apikeys) to create an API key. 

   <img src={require('../assets/images/create-api-key.png').default} width="600" alt="Create an API Key at exchange.coinbase.com." />

2. See [REST API Authentication](./rest-auth.md) to learn about signing a request with your API key. 

3. Select an API:
   - [REST API](./rest-requests.md) for lower-frequency trading and general requests.
   - [FIX Order Entry API](fix-msg-order-entry-50.mdx) for higher-frequency trading.
   - [WebSocket Feed](./websocket-overview.md) for market data.
   - [FIX Market Data API](./fix-msg-market-data.mdx) for latency sensitive market data feeds.

4. View Python examples of REST, WebSocket, and FIX APIs on the [Coinbase Samples](https://github.com/coinbase-samples/exchange-scripts-py) GitHub.

:::info 
By accessing the Exchange Market Data API, you agree to be bound by the [Market Data Terms of Use](https://www.coinbase.com/legal/market_data).
:::






<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-msg-oe-lwf.mdx -->

---
title: "Exchange Limit With Funds Orders"
sidebar_label: Limit With Funds Orders
slug: "fix-msg-oe-lwf"
hide_table_of_contents: false
---

Limit With Funds (LWF) orders allow users to fully execute an order up to a notional value specified in the product quote currency.

:::info
LWF orders are supported in [FIX 4.2](./fix-msg-order-entry.mdx#new-order-single-d) and [FIX 5.0](./fix-msg-order-entry-50.mdx#newordersingle-35d).
:::


## Parameters

| Tag  | Name         | Type    | Required | Description                          |
| :--- | :----------- | :------ | :------- | :----------------------------------- |
| 40   | OrdType      | Char    | Y        | Order Type must be `2` (Limit)       |
| 152  | CashOrderQty | Decimal | Y        | The notional value you wish to trade |

All values for `TimeInForce`, `SelfTradePrevention`, and `PostOnly` are supported.

:::caution
You must not define `OrderQty` when submitting a limit order with `CashOrderQty`.
:::


## Summary

:::note
`CashOrderQty` on limit orders is available for both buy and sell orders despite the following example featuring a buy order.
:::

Today, if you want to trade $30,000 worth of BTC, you might submit a market order:

`OrdType=1|Side=1|CashOrderQty=30000`

However, a market order leaves the executed price out of the client's control.

With the following market state:

| Bid Size | Bid    | Ask    | Ask Size |
| :------- | :----- | :----- | :------- |
|          |        | 60,000 | 10       |
| 10       | 59,000 |        |          |

You can try to trade $30,000 of BTC by placing a limit buy order. To do this you must perform the `notional/price` division to calculate the necessary `OrderQty`. The resulting order would look like:

`OrdType=2|Side=1|Price=60000|OrderQty=0.5`

If this order is filled at $2,000, then everything works as intended. In actuality, the market may change from the time in between when the user submits the order and when it is received by the exchange.

To illustrate, consider the case where the market state has changed to the following at the time when the exchange receives your order:

| Bid Size | Bid    | Ask    | Ask Size |
| :------- | :----- | :----- | :------- |
|          |        | 59,000 | 10       |
| 10       | 58,999 |        |          |

Your order now fills at $59,000 for quantity `0.5`. The resulting notional for this trade is $29,500, which is less than what you originally wanted.

To solve this issue, you can specify `CashOrderQty` instead of `OrderQty`:

`OrdType=2|Side=1|Price=60000|CashOrderQty=30000`

Given the same market state:

| Bid Size | Bid    | Ask    | Ask Size |
| :------- | :----- | :----- | :------- |
|          |        | 59,000 | 10       |
| 10       | 58,999 |        |          |

The order will be filled as taker with quantity `0.50847457`, making the total notional of this order $29,999.9996.

In a separate example, with the following market state:

| Bid Size | Bid    | Ask    | Ask Size |
| :------- | :----- | :----- | :------- |
|          |        | 60,500 | 1        |
|          |        | 59,500 | 0.3      |
| 10       | 59,999 |        |          |

Your order will fill as a taker at price $59,500 with quantity `0.3`. Thus only $17850 notional will be filled. The remaining $12,150 notional will then rest on the book at price $60,000 with quantity `0.2025`.


## Caveats

- Orders may be filled at less than the notional specified due to fees and truncation of product base increment.
- [TPSL](./fix-msg-oe-tpsl.md) / [Iceberg](./fix-msg-oe-iceberg.mdx) / [Stop](/exchange/reference/exchangerestapi_postorders/#stop-orders) / [Batch](./fix-msg-order-entry-50.mdx#neworderbatch-35u6) orders are not be supported with this feature.
- [OrderCancelReplaceRequest](./fix-msg-order-entry-50.mdx#ordercancelreplacerequest-35g) with `CashOrderQty` is not supported.


## Market Data

- `OrderQty`/`CumQty`/`LeavesQty` is supplied in all Execution Reports. In particular `OrderQty` is calculated after the order has been processed as a taker (i.e., it is **NOT** calculated with `CashOrderQty / Price`), such that all quantity tags are consistent with one another.
- `Size` field is populated in all WebSocket feed messages. No changes are expected from the perspective of a WebSocket consumer.


## Examples

In the following examples, all irrelevant tags are omitted.

<details>
<summary><b>Example 1 - A buy GTC order partially fills before resting</b></summary>
<div>

```json
$> -> BeginString=FIX.4.2 MsgType=ORDER_SINGLE OrdType=LIMIT Price=2952 Side=BUY Symbol=ETH-USD TimeInForce=GOOD_TILL_CANCEL CashOrderQty=1000 CheckSum=026

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT CumQty=0 ExecID=07debc62-aa75-4734-b1b5-91eb9ce8d49c ExecTransType=NEW OrderID=fa5d17b0-8344-4237-ab33-8c658595f960 OrderQty=0.33740512 OrdStatus=NEW Price=2952 Side=BUY Symbol=ETH-USD TransactTime=20240529-20:59:24.039 ExecType=NEW LeavesQty=0.33740512 CashOrderQty=996.01591424 CheckSum=091
```

Note that the value of `CashOrderQty` in the ExecutionReport is not $1,000 due to fees and base increment truncation.

```json
$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT AvgPx=2951.81 CumQty=0.01 ExecID=d7b9d643-5567-5ba1-ae59-eca93bc15723 ExecTransType=NEW LastPx=2951.81 LastShares=0.01 OrderID=fa5d17b0-8344-4237-ab33-8c658595f960 OrderQty=0.33740512 OrdStatus=PARTIALLY_FILLED Price=2951.81 Side=BUY Symbol=ETH-USD TransactTime=20240529-20:59:24.039 ExecType=PARTIAL_FILL LeavesQty=0.32740512 1003=1267476 AggressorIndicator=YES

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT AvgPx=2951.8666666666666667 CumQty=0.03 ExecID=83a0385b-96f4-532b-a704-cc8fbcbfecd8 ExecTransType=NEW LastPx=2951.92 LastShares=0.006 OrderID=fa5d17b0-8344-4237-ab33-8c658595f960 OrderQty=0.33740512 OrdStatus=PARTIALLY_FILLED Price=2951.92 Side=BUY Symbol=ETH-USD TransactTime=20240529-20:59:24.039 NoMiscFees=1 MiscFeeAmt=0.004 MiscFeeCurr=USD MiscFeeType=EXCHANGE_FEES ExecType=PARTIAL_FILL LeavesQty=0.30740512 MiscFeeBasis=Percentage 1003=1267479 AggressorIndicator=YES CheckSum=124
```

Your order fills as a taker with a notional of `0.03 * $2951.86666... = $88.556`.

The remaining notional of `$996.01591412 - $88.556 = $907.45991412` will rest on the book with a quantity of `$907.45991412 / $2952 = 0.30740512`.

Note that `OrderQty = CumQty + LeavesQty`. In the case of this specific order we have: `0.03 + 0.30740512 = 0.33740512`.

The order is now rested on the book and be filled as passive.

```json
$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT AvgPx=2951.9 CumQty=0.04 ExecID=ef6a5354-e928-5815-b55b-46361fea6423 ExecTransType=NEW LastPx=2952 LastShares=0.01 OrderID=fa5d17b0-8344-4237-ab33-8c658595f960 OrderQty=0.33740512 OrdStatus=PARTIALLY_FILLED Price=2952 Side=BUY Symbol=ETH-USD TransactTime=20240529-20:59:51.230 NoMiscFees=1 MiscFeeAmt=0.0025 MiscFeeCurr=USD MiscFeeType=EXCHANGE_FEES ExecType=PARTIAL_FILL LeavesQty=0.29740512 MiscFeeBasis=Percentage AggressorIndicator=NO
```
</div>
</details>

<details>
<summary><b>Example 2 - A buy IOC order that results in no fills</b></summary>
<div>

```json
$> -> BeginString=FIX.4.2 MsgType=ORDER_SINGLE ClOrdID=a79d33c4-7cc1-4948-b318-b878b5fbcc72 OrdType=LIMIT Price=1 Side=BUY Symbol=ETH-USD TimeInForce=IMMEDIATE_OR_CANCEL TransactTime=20240530-14:40:07.180 CashOrderQty=1000

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT ClOrdID=a79d33c4-7cc1-4948-b318-b878b5fbcc72 CumQty=0 ExecID=087c5712-6805-4e66-83b6-81c9fc92a78e ExecTransType=NEW OrderID=34cf5775-eee6-462b-8db0-9ec51f212663 OrderQty=0 OrdStatus=NEW Price=1 Side=BUY Symbol=ETH-USD TransactTime=20240530-14:40:07.245 ExecType=NEW LeavesQty=0 CashOrderQty=0 CheckSum=003

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT SenderCompID=Coinbase SendingTime=20240530-14:40:07.247 CumQty=0 ExecID=fcce5dea-9e83-492a-909c-30253e0b0d2f ExecTransType=NEW OrderID=34cf5775-eee6-462b-8db0-9ec51f212663 OrderQty=0 OrdStatus=CANCELED Price=1 Side=BUY Symbol=ETH-USD Text=101:Time In Force TransactTime=20240530-14:40:07.245 ExecType=CANCELED LeavesQty=0 CheckSum=214
```

Note that `OrderQty` is `0` in this case and this order will not be published in public WebSocket channels. It appears in the user channel only for this particular client.

</div>
</details>

<details>
<summary><b>Example 3 - A sell GTC order with Self Trade Preventnion (decrement and cancel)</b></summary>
<div>

```json
$> -> BeginString=FIX.4.2 MsgType=ORDER_SINGLE MsgSeqNum=41 ClOrdID=26dbf769-d812-4b0a-892a-bdf226387c0c OrdType=LIMIT Price=39944 Side=SELL Symbol=BTC-USD TimeInForce=GOOD_TILL_CANCEL TransactTime=20240531-14:24:32.566 CashOrderQty=10000 SelfTradePrevention=DECREMENT_AND_CANCEL CheckSum=225

$> <- BeginString=FIX.4.2 BodyLength=367 MsgType=EXECUTION_REPORT MsgSeqNum=48 SenderCompID=Coinbase SendingTime=20240531-14:24:32.705 ClOrdID=26dbf769-d812-4b0a-892a-bdf226387c0c CumQty=0 ExecID=f4054875-f834-409b-824a-2466bd3c066c ExecTransType=NEW OrderID=e19138ee-f97b-4bce-8cbe-ac8f6105ce30 OrderQty=0.2503 OrdStatus=NEW Price=39944 Side=SELL Symbol=BTC-USD TransactTime=20240531-14:24:32.702 ExecType=NEW LeavesQty=0.2503 CashOrderQty=9998.273235 CheckSum=061

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT MsgSeqNum=49 AvgPx=39949.3007 CumQty=0.05 ExecID=0aaee39c-fc85-5d82-b6f2-07d9b5b9d02a ExecTransType=NEW LastPx=39949.3007 LastShares=0.05 OrderID=e19138ee-f97b-4bce-8cbe-ac8f6105ce30 OrderQty=0.2503 OrdStatus=PARTIALLY_FILLED Price=39949.3007 Side=SELL Symbol=BTC-USD TransactTime=20240531-14:24:32.702 ExecType=PARTIAL_FILL LeavesQty=0.2003 MiscFeeBasis=Percentage 1003=23863011 AggressorIndicator=YES CheckSum=130

$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT MsgSeqNum=50 AvgPx=39949.3007 CumQty=0.05 ExecID=30e4d848-a18b-469e-925a-1dbc83c17aea ExecTransType=NEW OrderID=e19138ee-f97b-4bce-8cbe-ac8f6105ce30 OrderQty=0.2253 OrdStatus=PARTIALLY_FILLED Price=39945 Side=SELL Symbol=BTC-USD TransactTime=20240531-14:24:32.702 ExecType=RESTATED LeavesQty=0.1753 ExecRestatementReason=PARTIAL_DECLINE_OF_ORDERQTY CheckSum=044
```

And this is the buy order with `LeavesQty` of `0.025` that was self trade cancelled:

```json
$> <- BeginString=FIX.4.2 MsgType=EXECUTION_REPORT MsgSeqNum=51 CumQty=0 ExecID=0f4f96ad-160a-49a3-add0-eb25196fed70 ExecTransType=NEW OrderID=ca7e5097-cb6f-4381-8da8-629bc2656217 OrderQty=0.025 OrdStatus=CANCELED Price=39945 Side=BUY Symbol=BTC-USD Text=102:Self Trade Prevention TransactTime=20240531-14:24:32.702 ExecType=CANCELED LeavesQty=0 CheckSum=055
```

</div>
</details>


<!-- File: /Users/tinahe/docs/projects/exchange/docs/changelog-upcoming.mdx -->

---
title: "Exchange Upcoming Changes"
sidebar_label: "Upcoming Changes"
slug: "upcoming-changes"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This page provides information about upcoming changes to Coinbase Exchange.

{/*
## FEATURE SHORTNAME

_Added: YYYY-MON-DD_ or _Updated: YYYY-MON-DD_

Description
*/}

## FIX 4.2/5.0 Institutional RFQ Auctions

_Added: 2024-Sep-20_

* We are introducing RFQ functionality directly to our Institutional Prime users, with an 8 second price hold
* Participating LPs may submit firm quotes within the normal quoting window (250ms) as indicated by tag 62 (ValidUntilTime), and quotes will remain valid for an 8 second auction, indicated by tag 126 (ExpireTime)

Please see below a sample FIX message indicating an 8 second auction:

**Sample Quote_Request (R):**

```
8=FIX.4.2|9=234|35=R|34=7|49=<SENDERCOMPID>|52=20240920-12:00:00.000|56=<TARGETCOMPID>|131=a8b094b2-b9ff-42be-9194-2dae145fdf78|146=1|55=BTC-USD|303=2|38=1.0|126=20240920-12:00:08.000|62=20240920-12:00:00.250|891=2|137=0.0001|10=044
```

## FIX 4.2 Order Entry Gateway Deprecation

_Added: 2024-Aug-21_

We will be deprecating the FIX 4.2 Order Entry Gateway on <b>March 3rd, 2025</b>. For FIX based order entry, <b>leverage the newer, more performant</b> [FIX 5 Order Entry Gateway](./fix-msg-order-entry-50.mdx).



<!-- File: /Users/tinahe/docs/projects/exchange/docs/fix-downloads.mdx -->

---
title: "Exchange FIX Dictionary Downloads"
sidebar_label: Dictionary Downloads
slug: "fix-downloads"
hide_table_of_contents: false
---

import Badge from '@components/Badge';

<Badge color="0a639a" url="" label="Tarball updated:2024 FEB 23" />

<br />
<br />

A tarball of the Coinbase Exchange FIX dictionaries is available for download: 

- <a href="/downloads/exchange/cb_exch_fix_dictionaries-latest.tar.gz" download target="blank">cb_exch_fix_dictionaries-latest.tar.gz</a>


```
% tree cb_exch_fix_dictionaries-latest
cb_exch_fix_dictionaries-latest
├── market-data
│   ├── FIX50-prod-sand.xml
│   └── FIXT11-prod-sand.xml
└── order-entry
    ├── FIX42-prod-sand.xml
    ├── FIX50-prod-sand.xml
    └── FIXT11-prod-sand.xml
```

:::tip Unzip tar.gz file
- Mac: Double-click file
- Linux: `tar -xzf cb_exch_fix_dictionaries-latest.tar.gz`
:::


## Archive

{/* *** NOTE: 
Update Archive:  
(1) Rename the current tarball from latest to the date it was released, which you can see in the commented record below. 
(2) Add it to the archive by uncommenting the item below. 
(3) Add a new comment with today's release date in preparation for the next archiving. 

Create New Tarball: 
(1) Download new FIX files
  FIX5 MD - https://github.cbhq.net/dcm/fairx/tree/main/fix-api/src/main/resources/moonbase/marketdata
  FIX5 OE - https://github.cbhq.net/dcm/fairx/tree/main/fix-api/src/main/resources/moonbase/order
  FIX4 OE - https://github.cbhq.net/exchange/repo/blob/master/eng/exchange/api_fix/pkg/fix/FIX42_production.xml
(2) Diff against old files (if you feel like it)
(3) Create a new "latest" tarball: tar -czvf cb_exch_fix_dictionaries-latest.tar.gz cb_exch_fix_dictionaries-latest
***  */}

{/* 
- 2024-FEB-23: <a href="/downloads/exchange/archive/cb_exch_fix_dictionaries-20240223.tar.gz" download target="blank">cb_exch_fix_dictionaries-20240223.tar.gz</a> */}
- 2023-OCT-06: <a href="/downloads/exchange/archive/cb_exch_fix_dictionaries-20231006.tar.gz" download target="blank">cb_exch_fix_dictionaries-20231006.tar.gz</a>
- 2023-AUG-03: <a href="/downloads/exchange/archive/cb_exch_fix_dictionaries-20230803.tar.gz" download target="blank">cb_exch_fix_dictionaries-20230803.tar.gz</a>



<!-- File: /Users/tinahe/docs/projects/learn/docs/mass-payments.mdx -->

---
title: Automated Mass Payouts
sidebar_label: Automated Mass Payouts
slug: mass-payments
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Box, HStack } from "@cbhq/cds-web/layout";
import { Divider } from "@cbhq/cds-web/layout/Divider";

import { IconLink } from "@components/VideoTutorials/IconLink";
import { tutorialItems } from "@components/VideoTutorials";

import VideoPlayer from "@components/VideoPlayer"

<HStack spacingBottom={3} gap={3} flexWrap="wrap">
  {tutorialItems
    .find((item) => item.id === "mass-payments")
    .links
    .filter((link) => link.title !== "Guide")
    .map((link) => (
      <IconLink key={link.title} {...link} />
    ))}
</HStack>

With MPC Wallet APIs, you can distribute payments to hundreds or even millions of recipients with just a few lines of code. 

MPC Wallets empower you to orchestrate complex financial operations with ease and security, opening the doors to applications that were previously impractical. 

<Divider spacingTop={0.5} />
<Box spacingTop={5}>
  <VideoPlayer
    title="Automated mass payouts"
    description="Distribute payments to millions of recipients with a few lines of code."
    videoId="-yMaaYtdlVg"
    imgCover="/img/learn/mass-payout.svg" />
</Box>

## Key Benefits

- **Enhance security:** Leverage Multi-Party Computation (MPC) for secure asset custody.
- **Scale without limits:** Send payments multiple recipients in one batch&mdash;and free when transferring USDC.
- **Reduce overhead:** Automate repetitive payment tasks and minimize manual errors.
- **Integrate seamlessly:** Easily incorporate mass payments into your existing systems.


## Example Use Cases

- **Distributed payments:** Programmatically distribute payments for completed gigs to rideshare drivers and freelance workers. Or, set up daily payments to employees.
- **Autonomous profit sharing:** Implement flexible revenue sharing models for joint ventures, automatically distributing earnings to stakeholders based on real-time performance metrics.
- **Automated content creator compensation:** Instantly reward content creators based on user engagement, views, or other metrics.
- **Virtual economies:** Programmatically distribute payouts in virtual game economies based on real-time player actions.
- **Insurance payouts:** Automatically process claims and distribute payouts to policyholders based on smart contract-triggered events, such as flight delays and crop yields.


## What You'll Learn

This tutorial explains how to use the CDP SDK to programmatically send payments from a CSV file (for example, to reward a an audience with a little crypto) on [Base Sepolia Testnet](https://docs.base.org/docs/network-information/#base-testnet-sepolia) using a [Developer-Managed wallet](/mpc-wallet/docs/wallet-types/#developer-managed-1-of-1--wallets). 

- How to install the CDP SDK
- How to create a Developer-Managed Wallet
- How to fund your wallet with testnet ETH
- How to transfer funds to multiple wallet addresses in a CSV file

:::info wallet types
[Developer-Managed wallets](/mpc-wallet/docs/wallet-types/#developer-managed-1-of-1--wallets) _do not_ use [ServerSigner](/mpc-wallet/docs/serversigners) to store wallet keys; [Coinbase-Managed (2-of-2) wallets](/mpc-wallet/docs/wallet-types/#coinbase-managed-2-of-2-wallets) do, and are recommended for production environments. See [Securing a Wallet](/mpc-wallet/docs/wallets#securing-a-wallet) to learn more. 
:::


## Prerequisites

- Install the [CDP SDK](/mpc-wallet/docs/quickstart#installation).

The CDP SDK provides a quickstart template called [mass-payout.js](https://github.com/coinbase/coinbase-sdk-nodejs/blob/master/quickstart-template/mass-payout.js) that demonstrates sending batched payments. Python developers should use this [Replit Template](https://replit.com/@CoinbaseDev/Python-Onchain-Payments?v=1#README.md) 

<Tabs groupId="programming-language">
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript title="Installation" 
    git clone git@github.com:coinbase/coinbase-sdk-nodejs.git
    //git clone https://github.com/coinbase/coinbase-sdk-nodejs.git 
    cd coinbase-sdk-nodejs/quickstart-template 
    npm install 
    ```
  </TabItem>
  <TabItem value="Ruby" label="Ruby">
    ```ruby title="Installation for irb" 
    gem install coinbase-sdk csv 
    ```
  </TabItem>
  <TabItem value="Python" label="Python">
    ```python title="Installation" 
    pip install coinbase-sdk
    ```
  </TabItem>
</Tabs>


## Sending a mass payout

The steps in this tutorial walk you through the template, [mass-payout.js](https://github.com/coinbase/coinbase-sdk-nodejs/blob/master/quickstart-template/mass-payout.js), available in [coinbase-sdk-nodejs](https://github.com/coinbase/coinbase-sdk-nodejs). Ruby users can find the [full code sample](#how-to-run-the-full-script) below.

The mass-payout template does the following (with **step 4** demonstrating this particular use case):

> [Step 1.](#step-1-import-required-modules) Import the necessary modules.<br /><br />
> [Step 2.](#step-2-create-wallets-and-write-to-file) Create 5 wallets for receiving payments and write their addresses to a CSV file.<br /><br /> 
> [Step 3.](#step-3-create-wallet-and-fund) Create 1 wallet to send payments and fund it from the Base Sepolia testnet faucet.<br /><br /> 
> [Step 4.](#step-4-read-file-and-send-payments) Parse the addresses in the CSV file and create a transfer to each of our receiving wallets.<br /><br /> 
> [Step 5.](#step-5-manage-authentication) Manage authentication using the CDP API key.

<br />

### How to run the full script

<Tabs groupId="programming-language">
  <TabItem value="Typescript" label="Typescript" default>
    ```typescript 
    cd coinbase-sdk-nodejs/quickstart-template 
    node mass-payout.js 
    ```
  </TabItem>
  <TabItem value="Ruby" label="Ruby">
    ```ruby title="Save full code sample as mass-payout.rb"
    irb -r ./mass-payout.rb 
    ```
  </TabItem>
  <TabItem value="Python" label="Python">
    ```python title="Save full code sample as main.py"
    python main.py 
    ```
  </TabItem>
</Tabs>

<details>
<summary><b>Expand to copy the full Ruby code sample</b></summary>

```ruby
require "coinbase"
require "csv"

# Create receiving Wallets.
def create_receiving_wallets(user)
  addresses = []

  (1..5).each do |i|
    receiving_wallet = user.create_wallet
    puts "Receiving Wallet#{i} successfully created: #{receiving_wallet}"

    receiving_address = receiving_wallet.default_address
    puts "Default address for Wallet#{i}: #{receiving_address}"

    addresses.push([receiving_address.id]) # Storing Address as an array.
  end

  addresses
end

# Write to CSV file with receiving Wallet Addresses.
def write_receiving_addresses_to_csv(addresses)
  CSV.open("wallet-array.csv", "w") do |csv|
    addresses.each do |address|
      csv << address
    end
  end

  puts "The CSV file was written successfully without headers."
end

# Create and fund a sending Wallet.
def create_and_fund_sending_wallet(user)
  sending_wallet = user.create_wallet
  puts "sendingWallet successfully created: #{sending_wallet}"

  sending_address = sending_wallet.default_address
  puts "Default address for sendingWallet: #{sending_address}"

  faucet_transaction = sending_wallet.faucet
  puts "Faucet transaction successfully completed: #{faucet_transaction}"

  sending_wallet
end

# Read from CSV file and send mass payout.
def send_mass_payout(sending_wallet)
  transfer_amount = 0.000002

  asset_id = :eth

  CSV.foreach("./wallet-array.csv", headers: false) do |row|
    address = row[0]
    if address
      begin
        sending_wallet.transfer(
          transfer_amount,
          asset_id,
          address
        ).wait!
        puts "Transfer to #{address} successful"
      rescue => error
        puts "Error transferring to #{address}: #{error}"
      end
    end
  end

  puts "Finished processing CSV file"
end

begin
  # Manage CDP API Key for CDP SDK.
  # Configure location to CDP API Key.
  Coinbase.configure_from_json(
    "#{Dir.home}/Downloads/cdp_api_key.json"
  )

  user = Coinbase.default_user
  addresses = create_receiving_wallets(user)
  write_receiving_addresses_to_csv(addresses)
  sending_wallet = create_and_fund_sending_wallet(user)
  send_mass_payout(sending_wallet)
rescue => error
  puts "Error in sending mass payout: #{error}"
end
```

</details>

<br />

### Step 1. Import required modules

Import the following modules:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript title="mass-payout.js"
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk"; // Use CDP SDK
        import { createArrayCsvWriter } from "csv-writer"; // Write to CSV file
        import os from "os"; // Dynamically determine homedir of CDP API key
        import fs from "fs"; // Enable reading of CSV file
        import { parse } from "csv-parse"; // Read and parse CSV file
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby title="mass-payout.rb"
        require "coinbase"
        require "csv"
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python title="main.py"
        import os
        import json
        from cdp import Cdp, Wallet
        from decimal import Decimal
        from dotenv import load_dotenv
        ```
    </TabItem>
</Tabs>


### Step 2. Create wallets and write to file

1. Create 5 wallets for receiving payments and testing a mass payout.
2. Write the wallet addresses to a CSV file.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript title="mass-payout.js"
        // Create receiving Wallets.
        async function createReceivingWallets() {
          // Create 5 receiving Wallets and only store Wallet Addresses.
          const addresses = [];

          for (let i = 1; i <= 5; i++) {
            let receivingWallet = await Wallet.create();
            console.log(`Receiving Wallet${i} successfully created: `, receivingWallet.toString());

            let receivingAddress = await receivingWallet.getDefaultAddress();
            console.log(`Default address for Wallet${i}: `, receivingAddress.getId());
            addresses.push([receivingAddress.getId()]); // Storing Address as an array.
          }

          return addresses;
        }

        // Write to CSV file with receiving Wallet Addresses.
        async function writeReceivingAddressesToCsv(addresses) {
          // Define CSV file.
          const csvWriter = createArrayCsvWriter({
            path: "wallet-array.csv",
            header: false,
          });

          // Write Wallet Addresses to CSV file.
          await csvWriter.writeRecords(addresses);
          console.log("The CSV file was written successfully without headers.");
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby title="mass-payout.rb"
        # Create receiving Wallets.
        def create_receiving_wallets
          (1..5).map do |i|
            receiving_wallet = Coinbase::Wallet.create
            puts "Receiving Wallet#{i} successfully created: #{receiving_wallet}"

            receiving_address = receiving_wallet.default_address
            puts "Default address for Wallet#{i}: #{receiving_address}"

            receiving_address.id
          end
        end

        # Write to CSV file with receiving Wallet Addresses.
        def write_receiving_addresses_to_csv(addresses)
          CSV.open("wallet-array.csv", "w") do |csv|
            addresses.each do |address|
              csv << address
            end
          end

          puts "The CSV file was written successfully without headers."
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python title="main.py"
        # Specify the receiving addresses on Base Sepolia below. One is pre-populated
        # as an example. 
        receiving_addresses = ["yuga.base.eth"]
        ```
    </TabItem>
</Tabs>

<details>
<summary><b>Expand to see output</b></summary>

```js
Receiving Wallet1 successfully created:  Wallet{id: `{wallet1-id}`, networkId: 'base-sepolia'}
Default address for Wallet1:  {wallet1-address}
Receiving Wallet2 successfully created:  Wallet{id: `{wallet2-id}`, networkId: 'base-sepolia'}
Default address for Wallet2:  {wallet2-address}
Receiving Wallet3 successfully created:  Wallet{id: `{wallet3-id}`, networkId: 'base-sepolia'}
Default address for Wallet3:  {wallet3-address}
Receiving Wallet4 successfully created:  Wallet{id: `{wallet4-id}`, networkId: 'base-sepolia'}
Default address for Wallet4:  {wallet4-address}
Receiving Wallet5 successfully created:  Wallet{id: `{wallet5-id}`, networkId: 'base-sepolia'}
Default address for Wallet5:  {wallet5-address}
The CSV file was written successfully without headers.
```

</details>


### Step 3. Create wallet and fund

1. Create 1 wallet for sending payments.
2. Fund the sending wallet with the [Base Sepolia faucet](https://portal.cdp.coinbase.com/products/faucet).

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript title="mass-payout.js"
        // Create and fund a sending Wallet.
        async function createAndFundSendingWallet() {
          // Create sending Wallet.
          let sendingWallet = await Wallet.create();
          console.log(`sendingWallet successfully created: `, sendingWallet.toString());

          // Get sending Wallet Address.
          let sendingAddress = await sendingWallet.getDefaultAddress();
          console.log(`Default address for sendingWallet: `, sendingAddress.toString());

          // Fund sending Wallet.
          const faucetTransaction = await sendingWallet.faucet();
          console.log(`Faucet transaction successfully completed: `, faucetTransaction.toString());

          return sendingWallet;
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby title="mass-payout.rb"
        # Create and fund a sending Wallet.
        def create_and_fund_sending_wallet()
          sending_wallet = Coinbase::Wallet.create
          puts "sendingWallet successfully created: #{sending_wallet}"

          sending_address = sending_wallet.default_address
          puts "Default address for sendingWallet: #{sending_address}"

          faucet_transaction = sending_wallet.faucet
          puts "Faucet transaction successfully completed: #{faucet_transaction}"

          sending_wallet
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python title="main.py"
        # Create a sending Wallet
        def create_sending_wallet():
            print("Creating wallet...")
            sending_wallet = Wallet.create()
            print(f"Wallet successfully created: {sending_wallet}")

            # Persist the wallet locally
            print("Persisting wallet...")
            wallet_id_string = json.dumps(sending_wallet.id)
            with open(wallet_file_name, 'w') as f:
                f.write(wallet_id_string)
            sending_wallet.save_seed(seed_file_name)
            print("Wallet successfully persisted.")

            sending_address = sending_wallet.default_address
            print(f"Default address for wallet: {sending_address}")
            print("Funding sending wallet...")
            return sending_wallet


        # Or import an existing wallet
        def import_existing_wallet():
            print("Importing existing wallet...")
            # Get the wallet ID
            with open(wallet_file_name, 'r') as f:
                wallet_data = f.read()
            wallet_id = json.loads(wallet_data)

            # Get the wallet
            wallet = Wallet.fetch(wallet_id)

            # Load the seed on the wallet
            wallet.load_seed(seed_file_name)
            print(f"Imported existing wallet: {wallet_id}")

            # Fetch the addresses on the wallet
            wallet.addresses

            return wallet


        # Attempts to fund a wallet if it does not have enough ETH
        def maybe_fund_wallet(sending_wallet):
            eth_balance = sending_wallet.balance(asset_id)
            print(f"Current ETH balance: {eth_balance}")

            eth_required = transfer_amount * len(receiving_addresses)
            print(f"ETH required: {eth_required}")

            if eth_balance < eth_required:
                print(
                    f"Need {eth_required} ETH; attempting to fund wallet with faucet. This may take ~1 minute..."
                )
                faucet_transaction = sending_wallet.faucet()
                print(
                    f"Faucet transaction successfully completed: {faucet_transaction}")

                new_eth_balance = sending_wallet.balance(asset_id)
                print(f"New ETH balance: {new_eth_balance}")
        ```
    </TabItem>
</Tabs>


<details>
<summary><b>Expand to see output</b></summary>

```js
sendingWallet successfully created:  Wallet{id: '{wallet-id}', networkId: 'base-sepolia'}
Default address for sendingWallet:  WalletAddress{ addressId: '{wallet-address}', networkId: 'base-sepolia', walletId: '{wallet-id}}' }
Faucet transaction successfully completed:  Coinbase::FaucetTransaction{transaction_hash: '{transaction-hash}', transaction_link: 'https://sepolia.basescan.org/tx/{transaction-hash}'}
```

</details>


### Step 4. Read file and send payments

1. Read each wallet address from the CSV file.
2. Create a transfer for each wallet address and transfer (in this case) 0.00002 ETH.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript title="mass-payout.js"
        // Read from CSV file and send mass payout.
        async function sendMassPayout(sendingWallet) {
          // Define amount to send.
          const transferAmount = 0.000002;
          const assetId = Coinbase.assets.Eth;

          try {
            const parser = fs
              .createReadStream("./wallet-array.csv")
              .pipe(parse({ delimiter: ",", from_line: 1 }));

            for await (const row of parser) {
              const address = row[0];
              if (address) {
                try {
                  const transfer = await sendingWallet.createTransfer({
                    // Send payment to each Address in CSV.
                    amount: transferAmount,
                    assetId: assetId,
                    destination: address,
                  });

                  await transfer.wait()

                  // Check if transfer successfully completed on-chain
                  if (transfer.getStatus() === 'complete') {
                    console.log(`Transfer to ${address} successful`);
                  } else {
                    console.error('Transfer failed on-chain: ', transfer.toString());
                  }
                } catch (error) {
                  console.error(`Error transferring to ${address}: `, error);
                }
              }
            }
          } catch (error) {
            console.error(`Error processing CSV file: `, error);
          }

          console.log("Finished processing CSV file");
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby title="mass-payout.rb"
        # Read from CSV file and send mass payout.
        def send_mass_payout(sending_wallet)
          transfer_amount = 0.000002
          asset_id = :eth

          CSV.foreach("./wallet-array.csv", headers: false) do |row|
            address = row[0]
            if address
              begin
                sending_wallet.transfer(
                  transfer_amount,
                  asset_id,
                  address
                ).wait!
                puts "Transfer to #{address} successful"
              rescue => error
                puts "Error transferring to #{address}: #{error}"
              end
            end
          end

          puts "Finished processing CSV file"
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
    ```python title="main.py"
    # Send the payouts to the receiving addresses
    def send_mass_payout(sending_wallet):
        if len(receiving_addresses) == 0:
            print("No receiving addresses specified; quitting.")
            return

        print("Beginning mass payouts...")
        for address in receiving_addresses:
            try:
                print(f"Sending to {address}...")
                transfer = sending_wallet.transfer(amount=transfer_amount,
                                                   asset_id=asset_id,
                                                   destination=address)
                transfer.wait()
                print(f"Transfer to {address} successful")
                print(f"Transaction link: {transfer.transaction_link}")
                print(f"Transaction hash: {transfer.transaction_hash}")
            except Exception as error:
                print(f"Error sending to {address}: {error}")
    ```
    </TabItem>
</Tabs>


<details>
<summary><b>Expand to see output</b></summary>

```js
Transfer to {wallet1-address} successful
Transfer to {wallet2-address} successful
Transfer to {wallet3-address} successful
Transfer to {wallet4-address} successful
Transfer to {wallet5-address} successful
Finished processing CSV file
```

</details>


### Step 5. Manage authentication

The bottom of [mass-payout.js](https://github.com/coinbase/coinbase-sdk-nodejs/blob/master/quickstart-template/mass-payout.js) demonstrates how you might configure authentication with your CDP API key.

Notice that each task is "awaited" to ensure that it completes before moving on to the next task. This is important as each subsequent step in our tutorial depends on previous results.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript title="mass-payout.js"
        (async () => {
          try {
            // Configure location to CDP API Key.
            let coinbase = Coinbase.configureFromJson({
              filePath: `${os.homedir()}/Downloads/cdp_api_key.json`,
            });

            const addresses = await createReceivingWallets();
            await writeReceivingAddressesToCsv(addresses);
            const sendingWallet = await createAndFundSendingWallet();
            await sendMassPayout(sendingWallet);
          } catch (error) {
            console.error(`Error in sending mass payout: `, error);
          }
        })();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby title="mass-payout.rb"
        begin
          # Manage CDP Api Key for CDP SDK.
          # Configure location to CDP API Key.
          Coinbase.configure_from_json(
            "#{Dir.home}/Downloads/cdp_api_key.json"
          )

          addresses = create_receiving_wallets()
          write_receiving_addresses_to_csv(addresses)
          sending_wallet = create_and_fund_sending_wallet()
          send_mass_payout(sending_wallet)
        rescue => error
          puts "Error in sending mass payout: #{error}"
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python title="main.py"
        # Constants
        asset_id = "eth"
        transfer_amount = Decimal('0.000002')
        seed_file_name = "./encrypted_seed.json"
        wallet_file_name = "./wallet.json"

        # Main function
        def main():
            try:
                load_dotenv()  # Load environment variables from .env file

                api_key_name = os.environ.get('CDP_API_KEY_NAME')
                api_key_private_key = os.environ.get('CDP_API_KEY_PRIVATE_KEY')

                if not api_key_name or not api_key_private_key:
                    raise ValueError(
                        "CDP API Key Name or CDP API Key Private Key is missing")

                # Configure the CDP SDK
                private_key = api_key_private_key.replace('\\n', '\n')
                Cdp.configure(api_key_name, private_key)

                if os.path.exists(seed_file_name) and os.path.exists(wallet_file_name):
                    print("Using existing wallet...")
                    sending_wallet = import_existing_wallet()
                else:
                    # Create a file with seed_file_name and add an empty JSON object to it
                    with open(seed_file_name, 'w') as f:
                        f.write('{}')
                    sending_wallet = create_sending_wallet()

                maybe_fund_wallet(sending_wallet)
                send_mass_payout(sending_wallet)

                print("Finished sending mass payouts!")
            except Exception as error:
                print(f"Error in sending mass payouts: {error}")


        # Run the main function
        if __name__ == "__main__":
            main()
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/learn/docs/welcome.mdx -->

---
title: "Learn"
hide_title: true
sidebar_label: "Introduction"
slug: "welcome"
---
import { Divider } from "@cbhq/cds-web/layout/Divider";
import ProductHeader from "@site/src/components/ProductHeader";
import VideoTutorials from "@site/src/components/VideoTutorials";
import ShareBanner from '@site/src/components/ShareBanner'
import { ProductDemoSection } from '@components/Learn/ProductDemoSection';
import { BuilderAppsSection } from '@components/Learn/BuilderAppsSection';

<div>
  <ProductHeader
    title="Learn by building"
    subtitle="Browse tutorials, demo apps, and projects from the onchain community."
  />
</div>

<Divider spacingVertical={6} />
<VideoTutorials />
<Divider spacingVertical={6} />
<ProductDemoSection />
<Divider spacingVertical={6} />
<BuilderAppsSection />
<Divider spacingVertical={6} />
<ShareBanner />



<!-- File: /Users/tinahe/docs/projects/learn/docs/basename-registration.mdx -->

---
title: "Basename Registration"
sidebar_label: "Basename Registration"
slug: "basename-registration"
---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { HStack } from "@cbhq/cds-web/layout";

import { IconLink } from "@components/VideoTutorials/IconLink";
import { tutorialItems } from "@components/VideoTutorials";
import {basenameRegistrationLinks} from "@site/src/constants"

<HStack spacingBottom={3} gap={3} flexWrap="wrap">
  {basenameRegistrationLinks.map((link) => (
      <IconLink key={link.title} {...link} />
    ))}
</HStack>

MPC Wallets support registering a Basename using the arbitrary smart contract invocation feature. [Basenames](https://base.org/names) are the Base Layer 2’s human-readable address naming system that makes sending transactions simpler and helps you curate your onchain identity.

This solutions guide explains how you can register a Basename for your MPC Wallet, allowing anyone to easily send assets to your wallet and engage with your onchain identity.

See the [GitHub repo](https://github.com/coinbase/coinbase-sdk-nodejs/blob/master/quickstart-template/register-basename.js) for more information about cloning this quick start.

See the [Replit template](https://replit.com/@CoinbaseDev/Onchain-Agent-Registration?v=1#README.md) for more information about running the quick start on Base Sepolia testnet.

:::tip Replit for easy deployments
Replit is an AI-powered software development & deployment platform for building, sharing, and shipping software fast. 
Coinbase has partnered with Replit to create a template that enables developers to register their AI agent onchain 
in just minutes.

Get started with our [Basename registration template](https://replit.com/@CoinbaseDev/Onchain-Agent-Registration?v=1#README.md).
If you plan to deploy this template publicly, read [Securing a Wallet](/mpc-wallet/docs/wallets#securing-a-wallet) to learn
how to protect your wallets. 
:::

## Prerequisites

- Install the [CDP SDK](https://www.npmjs.com/package/@coinbase/coinbase-sdk).
- Have a persisted funded MPC Wallet on the Base network (minimum of 0.005 Base mainnet ETH). See [creating a wallet](./quickstart#creating-a-wallet) to quickly spin up a 1-of-1 Developer-Managed wallet, and refer to [persisting a wallet](./wallets#developer-managed-wallets) for more information on how to save it.

## Step-by-Step guide

### Step 1. Import Required Modules
```typescript title="register-basename.js"
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";
import { encodeFunctionData, namehash } from "viem";
import { normalize } from "viem/ens";
import os from "os";
```

### Step 2. Define Contract ABIs and Addresses
Set up the ABIs for the L2 Resolver and Registrar contracts, and define the `BaseNamesRegistrarControllerAddress`.

The Registrar contract is responsible for registering Basenames. By calling the contract alongside an ETH payment, you buy the name and associate it with your address on the Resolver.

The Resolver is what allows wallets to resolve a certain Basename to its proper address.

<Tabs>
  <TabItem value="base-mainnet" label="Base Mainnet">
    ```typescript title="register-basename.js"
    // Base Mainnet Registrar Controller Contract Address.
    const BaseNamesRegistrarControllerAddress = "0x4cCb0BB02FCABA27e82a56646E81d8c5bC4119a5";

    // Base Mainnet L2 Resolver Contract Address.
    const L2ResolverAddress = "0xC6d566A56A1aFf6508b41f6c90ff131615583BCD";

    // The regular expression to validate a Basename on Base Mainnet.
    const baseNameRegex = /\.base\.eth$/;

    // Relevant ABI for L2 Resolver Contract.
    const l2ResolverABI = [
      {
        inputs: [
          { internalType: "bytes32", name: "node", type: "bytes32" },
          { internalType: "address", name: "a", type: "address" },
        ],
        name: "setAddr",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          { internalType: "bytes32", name: "node", type: "bytes32" },
          { internalType: "string", name: "newName", type: "string" },
        ],
        name: "setName",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
    ];

    // Relevant ABI for Basenames Registrar Controller Contract.
    const registrarABI = [
      {
        inputs: [
          {
            components: [
              {
                internalType: "string",
                name: "name",
                type: "string",
              },
              {
                internalType: "address",
                name: "owner",
                type: "address",
              },
              {
                internalType: "uint256",
                name: "duration",
                type: "uint256",
              },
              {
                internalType: "address",
                name: "resolver",
                type: "address",
              },
              {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
              },
              {
                internalType: "bool",
                name: "reverseRecord",
                type: "bool",
              },
            ],
            internalType: "struct RegistrarController.RegisterRequest",
            name: "request",
            type: "tuple",
          },
        ],
        name: "register",
        outputs: [],
        stateMutability: "payable",
        type: "function",
      },
    ];
    ```
  </TabItem>
  <TabItem value="base-sepolia" label="Base Sepolia">
    ```typescript title="register-basename.js"
    // Base Sepolia Registrar Controller Contract Address.
    const BaseNamesRegistrarControllerAddress = "0x49aE3cC2e3AA768B1e5654f5D3C6002144A59581";

    // Base Sepolia L2 Resolver Contract Address.
    const L2ResolverAddress = "0x6533C94869D28fAA8dF77cc63f9e2b2D6Cf77eBA";

    // The regular expression to validate a Basename on Base Sepolia.
    const baseNameRegex = /\.basetest\.eth$/;

    // Relevant ABI for L2 Resolver Contract.
    const l2ResolverABI = [
      {
        inputs: [
          { internalType: "bytes32", name: "node", type: "bytes32" },
          { internalType: "address", name: "a", type: "address" },
        ],
        name: "setAddr",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          { internalType: "bytes32", name: "node", type: "bytes32" },
          { internalType: "string", name: "newName", type: "string" },
        ],
        name: "setName",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
    ];

    // Relevant ABI for Basenames Registrar Controller Contract.
    const registrarABI = [
      {
        inputs: [
          {
            components: [
              {
                internalType: "string",
                name: "name",
                type: "string",
              },
              {
                internalType: "address",
                name: "owner",
                type: "address",
              },
              {
                internalType: "uint256",
                name: "duration",
                type: "uint256",
              },
              {
                internalType: "address",
                name: "resolver",
                type: "address",
              },
              {
                internalType: "bytes[]",
                name: "data",
                type: "bytes[]",
              },
              {
                internalType: "bool",
                name: "reverseRecord",
                type: "bool",
              },
            ],
            internalType: "struct RegistrarController.RegisterRequest",
            name: "request",
            type: "tuple",
          },
        ],
        name: "register",
        outputs: [],
        stateMutability: "payable",
        type: "function",
      },
    ];
    ```
  </TabItem>
</Tabs>

### Step 3. Create Register Contract Method Arguments
Here, we create the arguments for the register contract method using the Resolver and Registrar ABIs.

```typescript title="register-basename.js"
// Create register contract method arguments.
function createRegisterContractMethodArgs(baseName, addressId) {
  const addressData = encodeFunctionData({
    abi: l2ResolverABI,
    functionName: "setAddr",
    args: [namehash(normalize(baseName)), addressId],
  });
  const nameData = encodeFunctionData({
    abi: l2ResolverABI,
    functionName: "setName",
    args: [namehash(normalize(baseName)), baseName],
  });

  const registerArgs = {
    request: [
      baseName.replace(baseNameRegex, ""),
      addressId,
      "31557600",
      L2ResolverAddress,
      [addressData, nameData],
      true,
    ],
  };
  console.log(`Register contract method arguments constructed: `, registerArgs);

  return registerArgs;
}
```
### Step 4. Implement Basename Registration Function
This function will handle the registration of the Basename.

```typescript title="register-basename.js"
async function registerBaseName(wallet, registerArgs) {
  try {
    const contractInvocation = await wallet.invokeContract({
      contractAddress: BaseNamesRegistrarControllerAddress,
      method: "register",
      abi: registrarABI,
      args: registerArgs,
      amount: 0.002,
      assetId: Coinbase.assets.Eth,
    });

    await contractInvocation.wait();

    console.log(`Successfully registered Basename ${registerArgs[0]} for wallet: `, wallet);
  } catch (error) {
    console.error(`Error registering a Basename for ${wallet}: `, error);
  }
}
```

### Step 5. Main Execution Flow
Here, we'll be using the information returned when persisting the wallet to import the wallet and register a Basename. Save these values as environment variables by running the following commands:

<Tabs>
  <TabItem value="base-mainnet" label="Base Mainnet">
    ```bash
    export BASE_NAME="your-basename.base.eth"
    export WALLET_ID="your-wallet-id"
    export SEED_FILE_PATH="/path-to-your-seed-file"
    ```
  </TabItem>
  <TabItem value="base-sepolia" label="Base Sepolia">
    ```bash
    export BASE_NAME="your-basename.basetest.eth"
    export WALLET_ID="your-wallet-id"
    export SEED_FILE_PATH="/path-to-your-seed-file"
    ```
  </TabItem>
</Tabs>

```typescript title="register-basename.js"
async () => {
  try {
    const { BASE_NAME, WALLET_ID, SEED_FILE_PATH } = process.env;

    // Manage CDP Secret API Key for Coinbase SDK.
    // Configure location to CDP Secret API Key.
    Coinbase.configureFromJson({
      filePath: `${os.homedir()}/Downloads/cdp_api_key.json`,
    });

    // Fetch funded Wallet.
    const wallet = await fetchWalletAndLoadSeed(WALLET_ID, SEED_FILE_PATH);
    const defaultAddress = await wallet.getDefaultAddress();

    // Register Basename.
    const registerArgs = createRegisterContractMethodArgs(BASE_NAME, defaultAddress.getId());
    await registerBaseName(wallet, registerArgs);
  } catch (error) {
    console.error(`Error in registering a Basename for my wallet: `, error);
  }
};
```

Now that you have registered a Basename for your MPC Wallet, reach out to us in the [CDP Discord](https://discord.gg/Ext5Xf4tZa) if you have any questions or would like to see more solutions guides!



<!-- File: /Users/tinahe/docs/projects/learn/docs/telegram-trading-bot.mdx -->

---
title: Telegram Trading Bot
sidebar_label: Telegram Trading Bot
slug: telegram-trading-bot
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { HStack } from "@cbhq/cds-web/layout";

import { IconLink } from "@components/VideoTutorials/IconLink";
import {telegramTradingBotLinks} from "@site/src/constants";

<HStack spacingBottom={3} gap={3} flexWrap="wrap">
  {telegramTradingBotLinks
    .map((link) => (
      <IconLink key={link.title} {...link} />
    ))}
</HStack>

This solutions guide explains how to create a Telegram trading bot using the Coinbase Developer Platform (CDP) SDK and MPC Wallet APIs. The bot will allow users to check balances, deposit and withdraw ETH, and perform buy and sell operations directly from Telegram.

This is a great template for building your own Telegram bot with additional features from the CDP SDK, such as [deploying tokens](https://x.com/MurrLincoln/status/1837203508178624862) or interacting with [smart contracts](./smart-contract-interactions)!

:::tip Replit for easy deployment
Replit is an AI-powered software development & deployment platform for building, sharing, and shipping software fast. Coinbase has partnered with Replit to create a template that enables developers to register their AI agent onchain in just minutes.

Use the [Replit template](https://replit.com/@CoinbaseDev/Onchain-Trading-Bot?v=1#README.md) for an easier cloning and deployment experience.
:::

:::warning
This sample app is for demonstration purposes only. Make sure to persist your private keys, and deposit only small amounts of ETH to reduce the risk of losing your funds. Secure your wallet using [best practices](https://docs.cdp.coinbase.com/mpc-wallet/docs/wallets#securing-a-wallet). In production, you should [use the 2-of-2 CDP Server-Signer](/mpc-wallet/docs/serversigners) with [IP whitelisting for your Secret API key](/get-started/docs/cdp-key-security) for increased security.
:::

## Prerequisites

- Install the [CDP SDK](https://www.npmjs.com/package/@coinbase/coinbase-sdk).
- Provision a CDP Secret API Key.
- Provision a [Telegram Bot Token](https://core.telegram.org/bots/tutorial) and register your Bot.
- Generate a 32-byte encryption key using OpenSSL:
  ```bash
  openssl rand -hex 32 # Save the output to use as the encryption key in Step 5.
  ```

## Step-by-Step Guide

### Step 1. Import Required Modules

First, we need to import the necessary modules for our bot. This includes the `grammy` library for interacting with Telegram, the `coinbase-sdk` for interacting with the CDK SDK, and other utility libraries.

```javascript title="index.js"
const { Bot, InlineKeyboard } = require("grammy");
const { Coinbase, Wallet } = require("@coinbase/coinbase-sdk");
const Database = require("@replit/database");
const Decimal = require("decimal.js");
const Web3 = require("web3");
const crypto = require("crypto");
```

### Step 2. Ensure Environment Variables are Set

Next, we ensure that all required environment variables are set. These variables include the Telegram bot token, Coinbase secret API key name and secret, and the encryption key.

```javascript title="index.js"
// Ensure environment variables are set.
const requiredEnvVars = [
  "TELEGRAM_BOT_TOKEN",
  "COINBASE_API_KEY_NAME",
  "COINBASE_API_KEY_SECRET",
  "ENCRYPTION_KEY",
];

requiredEnvVars.forEach((env) => {
  if (!process.env[env]) {
    throw new Error(`missing ${env} environment variable`);
  }
});
```

### Step 3. Create a Bot Object

We create a bot object using the `grammy` library and set up in-memory storage for user states and a database for storing wallets.

```javascript title="index.js"
// Create a bot object
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);

// In-memory storage for user states
const userStates = {};

// Database for storing wallets
const db = new Database();
```

### Step 4. Initialize Coinbase SDK

We initialize the Coinbase SDK with the provided secret API key name and secret.

```javascript title="index.js"
// Initialize Coinbase SDK
const privateKey = process.env.COINBASE_API_KEY_SECRET.replace(/\\n/g, "\n");
Coinbase.configure({
  apiKeyName: process.env.COINBASE_API_KEY_NAME,
  privateKey: privateKey,
});
```

### Step 5. Define Helper Functions

We define several helper functions to manage user states, send replies, and handle user interactions.

```javascript title="index.js"
// Helper functions
const updateUserState = (user, state) => {
  userStates[user.id] = { ...userStates[user.id], ...state };
};

const clearUserState = (user) => {
  delete userStates[user.id];
};

const sendReply = async (ctx, text, options = {}) => {
  const message = await ctx.reply(text, options);
  updateUserState(ctx.from, { messageId: message.message_id });
};

const handleUserState = async (ctx, handler) => {
  const userState = userStates[ctx.from.id] || {};
  if (
    ctx.message.reply_to_message &&
    ctx.message.reply_to_message.message_id === userState.messageId
  ) {
    await handler(ctx);
  } else {
    await ctx.reply("Please select an option from the menu.");
  }
};
```

### Step 6. Bot Command Handlers

We define the command handlers for the bot. The `/start` command initializes the bot and presents the user with a menu of options.

```javascript title="index.js"
// Bot command handlers
bot.command("start", async (ctx) => {
  const { from: user } = ctx;
  updateUserState(user, {});
  userAddress = await getOrCreateAddress(user);

  const keyboard = new InlineKeyboard()
    .text("Check Balance", "check_balance")
    .row()
    .text("Deposit ETH", "deposit_eth")
    .row()
    .text("Withdraw ETH", "withdraw_eth")
    .row()
    .text("Buy", "buy")
    .text("Sell", "sell")
    .row()
    .text("Export key", "export_key")
    .text("Pin message", "pin_message");

  const welcomeMessage = `
  *Welcome to your Onchain Trading Bot!*
  Your Base address is ${userAddress.getId()}.
  Select an option below:`;

  await sendReply(ctx, welcomeMessage, {
    reply_markup: keyboard,
    parse_mode: "Markdown",
  });
});
```

### Step 7. Callback Query Handlers

We define the callback query handlers for the bot. These handlers respond to user interactions with the menu options.

```javascript title="index.js"
// Callback query handlers
const callbackHandlers = {
  check_balance: handleCheckBalance,
  deposit_eth: handleDeposit,
  withdraw_eth: handleInitialWithdrawal,
  buy: handleInitialBuy,
  sell: handleInitialSell,
  pin_message: handlePinMessage,
  export_key: handleExportKey,
};

bot.on("callback_query:data", async (ctx) => {
  const handler = callbackHandlers[ctx.callbackQuery.data];
  if (handler) {
    await ctx.answerCallbackQuery();
    await handler(ctx);
  } else {
    await ctx.reply("Unknown button clicked!");
  }
  console.log(
    `User ID: ${ctx.from.id}, Username: ${ctx.from.username}, First Name: ${ctx.from.first_name}`,
  );
});
```

### Step 8. Handle User Messages

We handle user messages by checking the current state of the user and calling the appropriate handler function.

```javascript title="index.js"
// Handle user messages
bot.on("message:text", async (ctx) =>
  handleUserState(ctx, async () => {
    const userState = userStates[ctx.from.id] || {};
    if (userState.withdrawalRequested) await handleWithdrawal(ctx);
    else if (userState.buyRequested) await handleBuy(ctx);
    else if (userState.sellRequested) await handleSell(ctx);
  }),
);
```

### Step 9. Get or Create the User's Address

We define a function to get or create the user's address. If the user does not have an address, a new wallet is created and stored in the database.

```javascript title="index.js"
// Get or create the user's address
async function getOrCreateAddress(user) {
  if (userStates.address) {
    return userStates.address;
  }

  const result = await db.get(user.id.toString());

  let wallet;
  if (result?.value) {
    const { ivString, encryptedWalletData } = result.value;
    const iv = Buffer.from(ivString, "hex");
    const walletData = JSON.parse(decrypt(encryptedWalletData, iv));
    wallet = await Wallet.import(walletData);
  } else {
    wallet = await Wallet.create({ networkId: "base-mainnet" });
    const iv = crypto.randomBytes(16);
    const encryptedWalletData = encrypt(JSON.stringify(wallet.export()), iv);
    await db.set(user.id.toString(), {
      ivString: iv.toString("hex"),
      encryptedWalletData,
    });
  }

  updateUserState(user, { address: await wallet.getDefaultAddress() });

  return await wallet.getDefaultAddress();
}
```

### Step 10. Handle Checking Balance

We define a function to handle checking the user's balance. This function retrieves the user's address and lists their balances.

```javascript title="index.js"
// Handle checking balance
async function handleCheckBalance(ctx) {
  const userAddress = await getOrCreateAddress(ctx.from);
  const balanceMap = await userAddress.listBalances();
  const balancesString =
    balanceMap.size > 0
      ? balanceMap.toString().slice(11, -1)
      : "You have no balances.";
  await sendReply(
    ctx,
    `Your current balances are as follows:\n${balancesString}`,
  );
}
```

### Step 11. Handle Deposits

We define a function to handle deposits. This function provides the user with their address and instructions for depositing ETH.

```javascript title="index.js"
// Handle deposits
async function handleDeposit(ctx) {
  const userAddress = await getOrCreateAddress(ctx.from);
  await sendReply(
    ctx,
    "_Note: As this is a test app, make sure to deposit only small amounts of ETH!_",
    { parse_mode: "Markdown" },
  );
  await sendReply(
    ctx,
    "Please send your ETH to the following address on Base:",
  );
  await sendReply(ctx, `${userAddress.getId()}`, { parse_mode: "Markdown" });
}
```

### Step 12. Handle Initial Withdrawal Request

We define a function to handle the initial withdrawal request. This function prompts the user to enter the amount of ETH they want to withdraw.

```javascript title="index.js"
// Handle initial withdrawal request
async function handleInitialWithdrawal(ctx) {
  updateUserState(ctx.from, { withdrawalRequested: true });
  await sendReply(
    ctx,
    "Please respond with the amount of ETH you want to withdraw.",
    { reply_markup: { force_reply: true } },
  );
}
```

### Step 13. Handle Withdrawals

We define a function to handle withdrawals. This function processes the user's withdrawal request and initiates the transfer.

```javascript title="index.js"
// Handle withdrawals
async function handleWithdrawal(ctx) {
  const userState = userStates[ctx.from.id] || {};

  if (!userState.withdrawalAmount) {
    const withdrawalAmount = parseFloat(ctx.message.text);
    if (isNaN(withdrawalAmount)) {
      await ctx.reply("Invalid withdrawal amount. Please try again.");
      clearUserState(ctx.from);
    } else {
      const userAddress = await getOrCreateAddress(ctx.from);
      const currentBalance = await userAddress.getBalance(Coinbase.assets.Eth);
      if (new Decimal(withdrawalAmount).greaterThan(currentBalance)) {
        await ctx.reply("You do not have enough ETH to withdraw that amount.");
        clearUserState(ctx.from);
      } else {
        await sendReply(
          ctx,
          "Please respond with the address, ENS name, or Base name at which you would like to receive the ETH.",
          { reply_markup: { force_reply: true } },
        );
        updateUserState(ctx.from, {
          withdrawalAmount,
        });
      }
    }
  } else {
    const destination = ctx.message.text;
    if (!Web3.utils.isAddress(destination) && !destination.endsWith(".eth")) {
      await ctx.reply("Invalid destination address. Please try again.");
      clearUserState(ctx.from);
      return;
    }

    const userAddress = await getOrCreateAddress(ctx.from);

    try {
      await sendReply(ctx, "Initiating withdrawal...");
      const transfer = await userAddress.createTransfer({
        amount: userState.withdrawalAmount,
        assetId: Coinbase.assets.Eth,
        destination: destination,
      });
      await transfer.wait();
      await sendReply(
        ctx,
        `Successfully completed withdrawal: [Basescan Link](${transfer.getTransactionLink()})`,
        { parse_mode: "Markdown" },
      );
      clearUserState(ctx.from);
    } catch (error) {
      await ctx.reply("An error occurred while initiating the transfer.");
      console.error(error);
      clearUserState(ctx.from);
    }
  }
}
```

### Step 14. Handle Buy Request

We define functions to handle buy requests. These functions prompt the user to enter the asset they want to buy and the amount of ETH they want to spend.

```javascript title="index.js"
// Handle buy request
async function handleInitialBuy(ctx) {
  await handleTradeInit(ctx, "buy");
}

// Handle buys
async function handleBuy(ctx) {
  await executeTrade(ctx, "buy");
}
```

### Step 15. Handle Sell Request

We define functions to handle sell requests. These functions prompt the user to enter the asset they want to sell and the amount they want to sell.

```javascript title="index.js"
// Handle sell request
async function handleInitialSell(ctx) {
  await handleTradeInit(ctx, "sell");
}

// Handle sells
async function handleSell(ctx) {
  await executeTrade(ctx, "sell");
}
```

### Step 16. Initialize Trade (Buy/Sell)

We define functions to initialize and execute trades. These functions handle the user input and perform the trade operations.

```javascript title="index.js"
// Initialize trade (Buy/Sell)
async function handleTradeInit(ctx, type) {
  const prompt =
    type === "buy"
      ? "Please respond with the asset you would like to buy (ticker or contract address)."
      : "Please respond with the asset you would like to sell (ticker or contract address).";
  updateUserState(ctx.from, { [`${type}Requested`]: true });
  await sendReply(ctx, prompt, { reply_markup: { force_reply: true } });
}

// Generalized function to execute trades
async function executeTrade(ctx, type) {
  const userState = userStates[ctx.from.id] || {};
  if (!userState.asset) {
    // Prevent sale of ETH and log asset to user state
    if (ctx.message.text.toLowerCase() === "eth" && type === "sell") {
      await ctx.reply(
        "You cannot sell ETH, as it is the quote currency. Please try again.",
      );
      clearUserState(ctx.from);
      return;
    }

    updateUserState(ctx.from, { asset: ctx.message.text.toLowerCase() });

    const prompt =
      type === "buy"
        ? "Please respond with the amount of ETH you would like to spend."
        : "Please respond with the amount of the asset you would like to sell.";
    await sendReply(ctx, prompt, { reply_markup: { force_reply: true } });
  } else {
    const amount = new Decimal(parseFloat(ctx.message.text));
    const userAddress = await getOrCreateAddress(ctx.from);
    const currentBalance = await userAddress.getBalance(
      type === "buy" ? Coinbase.assets.Eth : userState.asset,
    );
    if (amount.isNaN() || amount.greaterThan(currentBalance)) {
      await ctx.reply(
        "Invalid amount or insufficient balance. Please try again.",
      );
      clearUserState(ctx.from);
    } else {
      const tradeType =
        type === "buy"
          ? { fromAssetId: Coinbase.assets.Eth, toAssetId: userState.asset }
          : { fromAssetId: userState.asset, toAssetId: Coinbase.assets.Eth };
      await sendReply(ctx, `Initiating ${type}...`);
      try {
        const userAddress = await getOrCreateAddress(ctx.from);
        const trade = await userAddress.createTrade({ amount, ...tradeType });
        await trade.wait();
        await sendReply(
          ctx,
          `Successfully completed ${type}: [Basescan Link](${trade.getTransaction().getTransactionLink()})`,
          { parse_mode: "Markdown" },
        );
        clearUserState(ctx.from);
      } catch (error) {
        await ctx.reply(`An error occurred while initiating the ${type}.`);
        console.error(error);
        clearUserState(ctx.from);
      }
    }
  }
}
```

### Step 17. Handle Pinning the Start Message

We define a function to handle pinning the start message. This function pins the welcome message to the chat.

```javascript title="index.js"
// Handle pinning the start message
async function handlePinMessage(ctx) {
  try {
    await ctx.api.pinChatMessage(
      ctx.chat.id,
      userStates[ctx.from.id].messageId,
    );
    await ctx.reply("Message pinned successfully!");
  } catch (error) {
    console.error("Failed to pin the message:", error);
    await ctx.reply(
      "Failed to pin the message. Ensure the bot has the proper permissions.",
    );
  }
  clearUserState(ctx.from);
}
```

### Step 18. Handle Exporting the Key

We define a function to handle exporting the key. This function provides the user with their private key and instructions for storing it safely.

```javascript title="index.js"
// Handle exporting the key
async function handleExportKey(ctx) {
  const userAddress = await getOrCreateAddress(ctx.from);
  const privateKey = userAddress.export();
  await sendReply(
    ctx,
    "Your private key will be in the next message. Do NOT share it with anyone, and make sure you store it in a safe place.",
  );
  await sendReply(ctx, privateKey);
}
```

### Step 19. Encrypt and Decrypt Functions

We define functions to encrypt and decrypt data. These functions use the AES-256-CBC encryption algorithm.

```javascript title="index.js"
// Encrypt and Decrypt functions
function encrypt(text, iv) {
  const encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, "hex");
  const cipher = crypto.createCipheriv("aes-256-cbc", encryptionKey, iv);
  return cipher.update(text, "utf8", "hex") + cipher.final("hex");
}

function decrypt(encrypted, iv) {
  const encryptionKey = Buffer.from(process.env.ENCRYPTION_KEY, "hex");
  const decipher = crypto.createDecipheriv("aes-256-cbc", encryptionKey, iv);
  return decipher.update(encrypted, "hex", "utf8") + decipher.final("utf8");
}
```

### Step 20. Start the Bot

Finally, we start the bot using long polling.

```javascript title="index.js"
// Start the bot (using long polling)
bot.start();

console.log("Trading bot is running...");
```

## Conclusion

Now that you have set up your Telegram trading bot, you can interact with it by sending commands and messages. The bot will handle checking balances, deposits, withdrawals, and trading operations. If you have any questions or need further assistance, feel free to reach out to us in the [CDP Discord](https://discord.gg/cdp).



<!-- File: /Users/tinahe/docs/projects/learn/docs/usdc-bridging.mdx -->

---
title: "USDC Bridging Guide"
sidebar_label: "USDC Bridging"
slug: "usdc-bridging"
---

This solutions guide explains how to bridge USDC (USD Coin) between Base and Arbitrum networks using the CDP SDK and [Circle's Cross-Chain Transfer Protocol (CCTP)](https://www.circle.com/en/cross-chain-transfer-protocol).

## Prerequisites
Before you begin, make sure you have the following:

- Installed the [CDP SDK](https://www.npmjs.com/package/@coinbase/coinbase-sdk).
- A CDP Secret API Key (configured in a JSON file).
- Node.js and npm installed on your system.
- Have a persisted funded MPC Wallet on the Base network (minimum of 0.005 Base mainnet ETH and some amount of USDC) and another on Arbitrum (minimum of 0.005 Arbitrum mainnet ETH). See [creating a wallet](./quickstart#creating-a-wallet) to quickly spin up a 1-of-1 Developer-Managed wallet, and refer to [persisting a wallet](./wallets#developer-managed-wallets) for more information on how to save it.

## Step-by-Step Guide

### Step 1: Set Up the Project
First, let's set up our project, import the necessary dependencies, and declare the required variables including contract ABIs:

```typescript
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";
import { createPublicClient, decodeAbiParameters, http, keccak256, toBytes } from 'viem';
import { base } from 'viem/chains'
import os from "os";
import dotenv from "dotenv";

dotenv.config();

// https://developers.circle.com/stablecoins/evm-smart-contracts contains the CCTP contract addresses 
const BASE_TOKEN_MESSENGER_ADDRESS = "0x1682Ae6375C4E4A97e4B583BC394c861A46D8962";
const ARBITRUM_MESSAGE_TRANSMITTER_ADDRESS = "0xC30362313FBBA5cf9163F0bb16a0e01f01A896ca";

// https://developers.circle.com/stablecoins/usdc-on-main-networks contains the USDC contract addresses on chains
const USDC_BASE_ADDRESS = "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913";

const tokenMessengerAbi = [
  {
    inputs: [
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint32", name: "destinationDomain", type: "uint32" },
      { internalType: "bytes32", name: "mintRecipient", type: "bytes32" },
      { internalType: "address", name: "burnToken", type: "address" },
    ],
    name: "depositForBurn",
    outputs: [
      { internalType: "uint64", name: "_nonce", type: "uint64" },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
];

const messageTransmitterAbi = [
  {
    inputs: [
      { internalType: "bytes", name: "message", type: "bytes" },
      { internalType: "bytes", name: "attestation", type: "bytes" },
    ],
    name: "receiveMessage",
    outputs: [
      { internalType: "bool", name: "success", type: "bool" },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
];
```


### Step 3: Create Bridging Function and Helper Functions
Using existing Base and Arbitrum mainnet wallets, we'll create a function to bridge USDC between the two networks.

```typescript
async function bridgeUSDC(baseWallet, arbitrumWallet, usdcAmount) {
    const baseUSDCBalance = await baseWallet.getBalance("usdc");
    const arbitrumUSDCBalance = await arbitrumWallet.getBalance("usdc");
    console.log("Base USDC initial balance:", baseUSDCBalance, "| Arbitrum USDC initial balance:", arbitrumUSDCBalance);

    // pad the recipient address
    const arbitrumRecipientAddress = padAddress((await arbitrumWallet.getDefaultAddress()).getId());
    
    // step 1 - approve  TokenMessenger as the spender on base
    const approveTx = await baseWallet.invokeContract({
        contractAddress: USDC_BASE_ADDRESS,
        method: "approve",
        args: {
            spender: BASE_TOKEN_MESSENGER_ADDRESS,
            value: usdcAmount.toString()
        },
    });
    await approveTx.wait();
    console.log("Approve transaction completed:", approveTx.getTransactionHash());
    
    // step 2 - call depositForBurn
    const depositTx = await baseWallet.invokeContract({
        contractAddress: BASE_TOKEN_MESSENGER_ADDRESS,
        method: "depositForBurn",
        args: {
            amount: usdcAmount.toString(), // uint256 as string
            destinationDomain: "3", // uint32 as string
            mintRecipient: arbitrumRecipientAddress, // already padded bytes32 as hex string
            burnToken: USDC_BASE_ADDRESS
        },
        abi: tokenMessengerAbi
    });
    await depositTx.wait();
    console.log("Deposit transaction completed:", depositTx.getTransactionHash());
    
    // step 3 - get the messageHash from the transaction receipt logs
    const transactionReceipt = await getTransactionReceipt(depositTx.getTransactionHash());
    const eventTopic = keccak256(toBytes('MessageSent(bytes)'));
    const log = transactionReceipt.logs.find((l) => l.topics[0] === eventTopic);
    if (!log) {
        throw new Error('MessageSent event not found in transaction logs');
    }
    const messageBytes = decodeAbiParameters([{ type: 'bytes' }], log.data)[0];
    const messageHash = keccak256(messageBytes)
    console.log("Message hash:", messageHash);

    // step 4 - wait for attestation on the message. Note that this step could take 15-30 minutes
    let attestationResponse = { status: 'pending' }
    while (attestationResponse.status != 'complete') {
    const response = await fetch(
        `https://iris-api.circle.com/attestations/${messageHash}`,
    )
    attestationResponse = await response.json()
    await new Promise((r) => setTimeout(r, 2000))
    }

    const attestationSignature = attestationResponse.attestation;
    console.log("Received attestation signature from Circle's Iris service:", attestationSignature);

    // step 5 - call receiveMessage on the arbitrum wallet MessageTransmitter
    const receiveMessageTx = await arbitrumWallet.invokeContract({
        contractAddress: ARBITRUM_MESSAGE_TRANSMITTER_ADDRESS   ,
        method: "receiveMessage",
        args: {
            message: messageBytes,
            attestation: attestationSignature
        },
        abi: messageTransmitterAbi
    });
    await receiveMessageTx.wait();
    console.log("Receive message transaction completed:", receiveMessageTx.getTransactionHash());

    const finalBaseUSDCBalance = await baseWallet.getBalance("usdc");
    const finalArbitrumUSDCBalance = await arbitrumWallet.getBalance("usdc");
    console.log("Base USDC final balance:", finalBaseUSDCBalance, "| Arbitrum USDC final balance:", finalArbitrumUSDCBalance);
}

function padAddress(address) {
    address = address.replace(/^0x/, '');
    return '0x' + address.padStart(64, '0');
}

// Helper function to fetch transaction receipt
async function getTransactionReceipt(txHash) {
    const publicClient = createPublicClient({
        chain: base,
        transport: http(),
      })
    const receipt = await publicClient.getTransactionReceipt({ 
        hash: txHash
      })
    return receipt;
}

// Helper function to fetch and load a wallet from a seed file
async function fetchWalletAndLoadSeed(walletId, seedFilePath) {
    try {
        const wallet = await Wallet.fetch(walletId);
        await wallet.loadSeed(seedFilePath);

        console.log(`Successfully loaded funded wallet: `, wallet.getId());
        return wallet;
    } catch (error) {
        console.error(
        `Error loading funded wallet ${walletId} from seed file ${seedFilePath}: `,
        error,
        );
    }
}
```

### Step 4: Create the Main Function
Finally, let's create the main function to orchestrate the entire process:

```typescript
async function main() {
    try {
      const { BASE_WALLET_ID, ARBITRUM_WALLET_ID, SEED_FILE_PATH } = process.env;

      // Configure location to CDP Secret API Key.
      Coinbase.configureFromJson({
        filePath: `${os.homedir()}/Downloads/cdp_api_key.json`,
      });
  
      // Fetch funded Wallet.
      const baseWallet = await fetchWalletAndLoadSeed(BASE_WALLET_ID, SEED_FILE_PATH);
      const arbitrumWallet = await fetchWalletAndLoadSeed(ARBITRUM_WALLET_ID, SEED_FILE_PATH);

      // bridge 1 wei of USDC from base to arbitrum (0.000001 USDC)
      await bridgeUSDC(baseWallet, arbitrumWallet, 1);
      console.log("Bridge USDC completed");
    } catch (error) {
      console.error(`Error in bridging USDC: `, error);
    }
};

main();
```

:::caution
This sample app is for demonstration purposes only. Make sure to secure your wallets and only use small amounts of USDC for testing to minimize risks.
:::

## Helpful Tips

- **Gas Fees**: Ensure you have enough ETH on both Base and Arbitrum networks to cover gas fees for the transactions.
- **USDC Decimals**: Remember that USDC uses 6 decimal places. When specifying amounts, multiply by 10^6 (e.g., 1 USDC = 1000000).
- **Contract Addresses**: The contract addresses used in this guide are for mainnet. For testnet development, use the appropriate testnet contract addresses.
- **Error Handling**: In a production environment, add more robust error handling and logging to manage potential issues during the bridging process.
- **Wallet Security**: Be cautious with wallet seeds and private keys. Never expose them in your code or commit them to version control.
- **Rate Limiting**: Be aware of rate limits when calling the Circle API for attestations. Implement appropriate waiting mechanisms if necessary.
- **Testing**: Always test your bridging process with small amounts before moving larger sums.
- **Additional Networks**: This guide uses Base and Arbitrum networks. You can use other [networks supported by CCTP](https://developers.circle.com/stablecoins/evm-smart-contracts) by modifying the code.



<!-- File: /Users/tinahe/docs/projects/learn/docs/ai-wallets.mdx -->

---
title: AI Wallets
sidebar_label: AI Wallets
slug: ai-wallets
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Box, HStack } from "@cbhq/cds-web/layout";
import { Divider } from "@cbhq/cds-web/layout/Divider";

import { IconLink } from "@components/VideoTutorials/IconLink";
import { tutorialItems } from "@components/VideoTutorials";

import VideoPlayer from "@components/VideoPlayer";

<HStack spacingBottom={3} gap={3} flexWrap="wrap">
  {tutorialItems
    .find((item) => item.id === "ai-wallets")
    .links
    .filter((link) => link.title !== "Guide")
    .map((link) => (
      <IconLink key={link.title} {...link} />
    ))}
</HStack>

AI agents cannot get bank accounts, but they can get crypto wallets. Coinbase MPC Wallets are a powerful and secure way to give agents crypto wallets and introduce the ability to transfer value to artificial intelligence. Automate complex financial transactions that would be time-consuming for humans to manage at scale, and seamlessly connect AI to the crypto ecosystem.

<Divider spacingTop={0.5} />
<Box spacingVertical={5}>
  <VideoPlayer
    title="Build wallets for AI agents"
    description="A simple app for Reinforcement Learning from Human Feedback"
    videoId="P0py9gATYBA"
    imgCover="/img/learn/ai-agent.svg" />
</Box>

:::tip Replit for easy deployments
Replit is an AI-powered software development & deployment platform for building, sharing, and shipping software fast. 
Coinbase has partnered with Replit to create a template that enables developers to build and deploy AI Wallet applications 
in just minutes.

Get started with our [AI Wallet Replit template](https://replit.com/@CoinbaseDev/Onchain-Machine-Learning#README.md).
If you plan to deploy this template publicly, read [Securing a Wallet](/mpc-wallet/docs/wallets#securing-a-wallet) to learn
how to protect your wallets. 
:::

## Key Benefits

- **Financial Autonomy for AI:** Enable AI agents to make financial decisions and transactions on your behalf.
- **Enhanced Security:** Utilize MPC technology to ensure AI operations remain controlled and secure.
- **Scalability:** Effortlessly handle millions of transactions.

## Example Use Cases

- **Natural Language Financial Transactions:** Allow users to manage their finances through simple text commands, with AI interpreting and executing complex financial operations.
- **AI Financial Concierge:** Personal AI assistants that not only recommend services but also handle payments, booking, and planning.
- **AI-Driven Content Monetization:** Create automated systems that create, publish, and monetize content, and manage earnings as an autonomous entity.
- **Self-Owned Autonomous Vehicle:** A self-driving vehicle that picks up drivers, receives payments, and pays for maintenance? The future may be closer than it seems.

:::info
We use the [Base Sepolia network](https://docs.base.org/docs/network-information/#base-testnet-sepolia) to demonstrate sending crypto from an AI agent to a user.

We will use the AI feedback app [here](https://github.com/coinbase/coinbase-sdk-ai-agent-sample) to demonstrate the solution.
:::

## Overview

After you install the [CDP SDK](#prerequisites), the steps below walk through the [AI agent sample app](https://github.com/coinbase/coinbase-sdk-ai-agent-sample) to do the following:

1. Import required modules.
1. Create the AI agent's wallet.
1. Fund the AI agent's wallet with faucet.
1. Create wallets for end-users to receive payments.
1. Send crypto from the AI agent's wallet to the user wallet.
1. Receive funds from other agents or users.
1. Display the AI agent's wallet balance after sending crypto to the user.

## Prerequisites

- Install the [CDP SDK](https://www.npmjs.com/package/@coinbase/coinbase-sdk).

```typescript title="installation"
npm install @coinbase/coinbase-sdk
```

## Send crypto from the AI agent's wallet to a user

### Step 1. Import required modules

 ```typescript title="app/api/route.ts"
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk"; // Use CDP SDK
 ```

### Step 2. Create the AI agent's wallet

The app takes the following inputs as environment variables:
- `NAME`: Enter the name of your downloaded CDP API key.
- `PRIVATE_KEY`: Enter the private key of your downloaded CDP API key.
- `WALLET_DATA`: Enter the seed data of your wallet, if you have an existing wallet. Leave it empty if you want a new wallet to be created for the agent. Refer to the [persisting wallet](/mpc-wallet/docs/wallets#persisting-locally) section to see how to fetch wallet data.

<details>
<summary><b>Expand to see valid WALLET_DATA</b></summary>

```
{ "WALLET_ID_PLACEHOLDER": { "seed": "SEED_DATA_PLACEHOLDER", "encrypted": false, "auth_tag": "", "iv": "" }}
```
</details>

[Code Reference](https://github.com/coinbase/coinbase-sdk-ai-agent-sample/blob/master/app/api/route.ts)

The code below shows how to import wallet or create a new one if `WALLET_DATA` env var is not set.

```typescript title="app/api/route.ts"
const { NAME, PRIVATE_KEY, WALLET_DATA } = process.env;

// Check if the environment variables are set
if (!NAME || !PRIVATE_KEY) {
  return Response.json(
    { message: "Environment variables are not set" },
    { status: 500 }
  );
}

const body = await request.json();

// Check if the address is provided
if (!body?.address) {
  return Response.json({ message: "Address is required" }, { status: 400 });
}

// Create a new Coinbase instance
const coinbase = new Coinbase({
  apiKeyName: NAME as string,
  privateKey: PRIVATE_KEY.replaceAll("\\n", "\n") as string,
});

let userWallet;

// Check if the wallet data is provided
if (WALLET_DATA && WALLET_DATA?.length > 0) {
  try {
    // Parse the wallet data
    const seedFile = JSON.parse(WALLET_DATA || "{}");

    // Get the wallet ids from the seed file. The seed file is a JSON object with wallet ids as keys.
    const walletIds = Object.keys(seedFile);

    // Get a random wallet id
    const walletId = getRandomItems(walletIds, 1)[0];

    // Get the seed of the wallet
    const seed = seedFile[walletId]?.seed;

    // Import the wallet
    userWallet = await Wallet.import({ seed, walletId });
    await userWallet.listAddresses();
  } catch (e) {
    return Response.json(
      { message: "Failed to import wallet" },
      { status: 500 }
    );
  }
} else {
  // Otherwise, create a new wallet
  userWallet = await Wallet.create();
}
```

### Step 3. Fund the AI agent's Wallet with faucet

To fund the wallet with ETH on Base Sepolia, utilize the `faucet` method.

```typescript title="app/api/route.ts"
// Fund the wallet with faucet if required
try {
  // Request funds from the faucet if it's available
  await userWallet?.faucet();
} catch (e) {
  // Log if the faucet is not available.
  console.log("Faucet is not available");
}
```

### Step 4. Create wallets for end-users to receive payments

Use [Coinbase Smart Wallets](https://www.smartwallet.dev/why) to enable users without an existing wallet to get payments from the AI agent.

Smart Wallets provide a seamless account creation process in seconds, eliminating the need for an app or extension. This is made possible by utilizing passkeys for signing, which are securely generated and stored on users' devices.

The code to integrate Coinbase Smart Wallet in your application can be found [here](https://github.com/coinbase/coinbase-sdk-ai-agent-sample/blob/master/components/WalletConnect.tsx).

### Step 5. Send crypto from the AI agent's wallet to the user wallet

Use `createTransfer` to send crypto from the AI agent's wallet to the user wallet after the user has completed their task.

```typescript title="app/api/route.ts"
// Create a transfer to the destination address
const transfer = await userWallet?.createTransfer({
  amount: 0.00000001,
  assetId: "eth",
  destination: body.address,
});

// Wait for transfer to settle.
await transfer.wait();

  // Return the transaction hash and link
return Response.json(
  {
    transactionHash: transfer?.getTransactionHash()?.substring(0, 10),
    transactionLink: transfer?.getTransactionLink(),
    successful: transfer.getStatus() === 'complete'
  },
  { status: 200 }
);
```

### Step 6. Receive funds from other agents or users

To receive funds from other agents or users, fetch the default address of the AI agent's wallet with the following method:

```typescript
// Get the default address of the wallet
const defaultAddress = await userWallet?.getDefaultAddress();
console.log("AI agent's Wallet's Address: ", defaultAddress);
```

### Step 7. Display the AI agent's wallet balance after sending crypto to the user

Use `balances` to get the balance of the AI agent's wallet after sending crypto to the user.

```typescript
// Get the balance of the wallet
const balances = await userWallet?.balances();
console.log("Balances: ", balances);
```

To see the full code, refer to the [AI agent sample app](https://github.com/coinbase/coinbase-sdk-ai-agent-sample/tree/master).



<!-- File: /Users/tinahe/docs/projects/intx/docs/rest-overview.mdx -->

---
title: "INTX REST API Overview"
sidebar_label: "REST API Overview"
slug: "rest-overview"
---

:::tip REST API Reference
You can access the [REST API docs](/intx/reference) from the navbar above or download the <a href="/intx-public-api-spec.yaml" target="_blank">OpenAPI</a> spec directly.
:::


## Basics

All requests and responses are `application/json` content type and follow typical HTTP response status codes for success and failure.

Request URLs must be lowercase as URLs are [case-sensitive](https://www.w3.org/TR/WD-html40-970708/htmlweb.html).


## Status Codes

### Success

A successful response is indicated by HTTP status code 200 and may contain an optional body. If the response has a body it is documented under each resource.

<img src={require('../assets/images/response-body.png').default} width="500" alt="In the API Reference, click the green 200 to view the response body of a successful response."  />  


### Errors

```json
{
    "message": "Invalid Price"
}
```

Unless otherwise stated, errors to bad requests respond with HTTP 4xx or status codes. The body also contains a `message` parameter indicating the cause. Your language HTTP library should be configured to provide message bodies for non-2xx requests so that you can read the message field from the body.

### Common Error Codes

| Status Code | Reason                                                        |
|:------------|:--------------------------------------------------------------|
| 400         | Bad Request -- Invalid request format                         |
| 401         | Unauthorized -- Invalid API Key                               |
| 403         | Forbidden -- You do not have access to the requested resource |
| 404         | Not Found                                                     |
| 500         | Internal Server Error                                         |



<!-- File: /Users/tinahe/docs/projects/intx/docs/rest-auth.mdx -->

---
title: "INTX REST API Authentication"
sidebar_label: "Authentication"
slug: "rest-auth"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This page explains how to sign and authenticate International Exchange (INTX) REST API endpoints. 

:::info
The INTX FIX API uses its own authentication scheme detailed in the [FIX Overview](/intx/docs/fix-overview).
:::

## Generating an API Key

Certain API endpoints require authentication to access. To interact with these resources, you must create an API key via the Coinbase International Exchange website.


## Signing Requests

The INTX REST API requests must include an access signature header. 

:::caution
* `CB-ACCESS-KEY`: The API key as a string
* `CB-ACCESS-PASSPHRASE`: The Passphrase shown when creating the API key
* `CB-ACCESS-SIGN`: The Base64-encoded signature
* `CB-ACCESS-TIMESTAMP`: A timestamp for your request
:::

### Selecting a Timestamp

The `CB-ACCESS-TIMESTAMP` header MUST be number of seconds since [Unix Epoch](http://en.wikipedia.org/wiki/Unix_time) in UTC. Decimal values are **not** allowed. Make sure to use an integer.

Your timestamp should be within 5 seconds of the API service time or your request is considered expired and will be rejected.

### Creating a Signature

The `CB-ACCESS-SIGN` header is generated by creating an HMAC-SHA-256 using the secret key on the prehash string `timestamp + method + requestPath + body` (where `+` represents string concatenation) and Base64-encode the output.

- `timestamp` is the same as the `CB-ACCESS-TIMESTAMP` header.

- `method` should be UPPER CASE, e.g., `GET` or `POST`.

- `requestPath` should only include the path of the API endpoint. Do NOT include the base URL or query parameters when creating the signature.

  **Valid requestPath example** to include in the string for hashing: 

  ```
  /api/v1/portfolios/<YOUR_PORTFOLIO_ID_HERE>/positions
  ```

  **Invalid requestPath example**: 

  ```
  api.international.coinbase.com/v1/portfolios/<PORTFOLIO_ID>/positions?portfolio=5189861793641175
  ```

- `body` is the request body string or omitted if there is no request body (typically for `GET` requests).

:::tip
Remember to Base64-encode the digest output before sending in the header. That is, the secret should not be Base64 encoded when using HMAC-SHA-256 to sign the request, but the entire resulting message.
:::

## Code Samples

The following examples demonstrate how to sign a message by generating an HMAC signature, setting the headers, and making a GET request to the specified URL.

<Tabs>
<TabItem value="python" label="Python">

```python
import json
import hmac
import hashlib
import time
import base64
import requests
import urllib.parse

method = 'GET'
url = 'url'
secret_key = 'secret'
timestamp = str(int(time.time()))
passphrase = 'password'
access_key = 'access_key'
body = ''

message = timestamp + method + urllib.parse.urlparse(url).path + str(body or '')
hmac_key = base64.b64decode(secret_key)
signature = hmac.new(hmac_key, message.encode('utf-8'), digestmod=hashlib.sha256).digest()
signature_b64 = base64.b64encode(signature).decode()

headers = {
    "CB-ACCESS-TIMESTAMP": timestamp,
    "CB-ACCESS-SIGN": signature_b64,
    "CB-ACCESS-PASSPHRASE": passphrase,
    "CB-ACCESS-KEY": access_key
}

response = requests.get(url, headers=headers)
print(response.json())
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'json'
require 'openssl'
require 'base64'
require 'net/http'
require 'uri'

method = 'GET'
url = 'url'
secret_key = 'secret'
timestamp = Time.now.to_i.to_s
passphrase = 'password'
access_key = 'access_key'
body = ''

message = timestamp + method + URI.parse(url).path + (body || '').to_s
hmac_key = Base64.decode64(secret_key)
signature = OpenSSL::HMAC.digest('sha256', hmac_key, message.encode('utf-8'))
signature_b64 = Base64.strict_encode64(signature)

headers = {
  'CB-ACCESS-TIMESTAMP' => timestamp,
  'CB-ACCESS-SIGN' => signature_b64,
  'CB-ACCESS-PASSPHRASE' => passphrase,
  'CB-ACCESS-KEY' => access_key
}

uri = URI.parse(url)
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = (uri.scheme == 'https')

request = Net::HTTP::Get.new(uri.request_uri)
headers.each { |key, value| request[key] = value }

response = http.request(request)

puts JSON.parse(response.body)
```

</TabItem>
<TabItem value="js" label="JavaScript">

```js
const crypto = require('crypto');
const axios = require('axios');
const querystring = require('querystring');

const method = 'GET';
const url = 'url';
const secret_key = 'secret';
const timestamp = String(Math.floor(Date.now() / 1000));
const passphrase = 'password';
const access_key = 'access_key';
const body = '';

const message = timestamp + method + new URL(url).pathname + (body || '');
const hmac_key = Buffer.from(secret_key, 'base64');
const signature = crypto.createHmac('sha256', hmac_key).update(message).digest();
const signature_b64 = signature.toString('base64');

const headers = {
  'CB-ACCESS-TIMESTAMP': timestamp,
  'CB-ACCESS-SIGN': signature_b64,
  'CB-ACCESS-PASSPHRASE': passphrase,
  'CB-ACCESS-KEY': access_key
};

axios.get(url, { headers })
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    console.error(error);
  });
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/intx/docs/fix-downloads.mdx -->

---
title: "INTX FIX Dictionary Downloads"
sidebar_label: "Dictionary Downloads"
slug: "fix-downloads"
---

import Badge from '@components/Badge';

## Latest

<Badge color="0a639a" url="/intx/docs/changelog#2024-aug-20" label="Latest Tarball Updated:2024 AUG 20" />

<br />
<br />



A tarball of all Coinbase INTX FIX dictionaries is available for download: 

- <a href="/downloads/intx/cb_intx_fix_dictionaries_latest.tar.gz" download target="blank">cb_intx_fix_dictionaries_latest.tar.gz</a>

This tarball includes the following files:

```
% tree cb_intx_fix_dictionaries
cb_intx_fix_dictionaries
├── dropcopy
│   ├── FIX50.xml
│   └── FIXT11.xml
├── marketdata
│   ├── FIX50.xml
│   └── FIXT11.xml
└── order
    ├── FIX50.xml
    └── FIXT11.xml
```

## Archive

{/* <!--- 
*** NOTE: 
How to archive the current tarball:
In static/downloads/intx
(1) Rename the current tarball from "latest" to the date it was released (which you can see in the commented record in ARCHIVE LIST). 
(2) Move the renamed tarball to the archive folder: static/downloads/intx/archive
Under ARCHIVE LIST (below)
(3) Add the renamed tarball to the archive list by uncommenting the item below. 
(4) Add a new comment with today's release date in preparation for the next archiving. 

How to create a new tarball: 
(1) Download new FIX files: https://github.cbhq.net/dcm/fairx/tree/main/util/fix-api/src/main/resources/starbase
(2) Diff against old files (if you feel like it)
(3) Create a new "latest" tarball: tar -czvf cb_intx_fix_dictionaries_latest.tar.gz cb_intx_fix_dictionaries_latest
*** ---> */}


{/* 
*** ARCHIVE LIST: 
<!--- - 2024-AUG-20:  <a href="/downloads/intx/archive/cb_intx_fix_dictionaries_20240820.tar.gz" download target="blank">cb_intx_fix_dictionaries_20240820.tar.gz</a> ---> */}
- 2024-JUN-03:  <a href="/downloads/intx/archive/cb_intx_fix_dictionaries_20240603.tar.gz" download target="blank">cb_intx_fix_dictionaries_20240603.tar.gz</a>
- 2024-MAY-23:  <a href="/downloads/intx/archive/cb_intx_fix_dictionaries_20240523.tar.gz" download target="blank">cb_intx_fix_dictionaries_20240523.tar.gz</a>
- 2024-APR-17:  <a href="/downloads/intx/archive/cb_intx_fix_dictionaries_20240417.tar.gz" download target="blank">cb_intx_fix_dictionaries_20240417.tar.gz</a>
- 2023-JUL-11:  <a href="/downloads/intx/archive/cb_intx_fix_dictionaries_20230711.tar.gz" download target="blank">cb_intx_fix_dictionaries_20230711.tar.gz</a>



<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/NodeJS/installation/requirements.mdx -->

**Node.js 18+**

The Coinbase server-side SDK requires Node.js version 18 or higher and npm version 9.7.2 or higher. To view your currently installed versions of Node.js, run the following from the command-line:

```bash
node -v
npm -v
```

We recommend installing and managing Node.js and npm versions with `nvm`.
See [Installing and Updating](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating) in the `nvm` README for instructions on how to install `nvm`.

Once `nvm` has been installed, you can install and use the latest versions of Node.js and npm by running the following commands:

```bash
nvm install node # "node" is an alias for the latest version
nvm use node
```


<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/NodeJS/installation/installation.mdx -->

To install the CDP SDK, run the following command from your Node project directory:

```bash
npm install @coinbase/coinbase-sdk
```

Alternatively, if you are using Yarn:

```bash
yarn add @coinbase/coinbase-sdk
```


<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/Python/installation/requirements.mdx -->

**Python 3.10+**

Before using the SDK, ensure that you have the correct version of Python installed and the `pip` package manager. The SDK requires Python 3.10 or higher. You can check your Python version and `pip` installation by running the following code:

```bash
python --version
pip --version
```

If you need to upgrade your Python version, you can download and install the latest version of Python from the [official Python website](https://www.python.org/downloads/). For `pip`, refer to the [official pip documentation](https://pip.pypa.io/en/stable/installation/) for installation instructions.


<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/Python/installation/installation.mdx -->

Install the [PyPI CDP SDK Package](https://pypi.org/project/cdp-sdk/)

```bash
pip install cdp-sdk
```


<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/authentication.mdx -->

---
title: Authentication
sidebar_label: Authentication
slug: authentication
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The CDP APIs use [CDP Secret API Keys](/get-started/docs/cdp-keys) for authentication.

After [creating a CDP Secret API Key](https://portal.cdp.coinbase.com/access/api) and securely storing it, 
initialize the CDP SDK by passing your API key name and API key's private key to the Coinbase class constructor:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let apiKeyName = 'Copy your Secret API Key name here.';

        let privateKey = 'Copy your Secret API Key's private key here.';

        Coinbase.configure({ apiKeyName, privateKey });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        api_key_name = "Copy your Secret API key name here."
        api_key_private_key = "Copy your Secret API key's private key here."

        Coinbase.configure do |config|
            config.api_key_name = api_key_name
            config.api_key_private_key = api_key_private_key
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        api_key_name = "Copy your Secret API key name here."
        api_key_private_key = "Copy your Secret API key's private key here."

        Cdp.configure(api_key_name, api_key_private_key)
        ```
    </TabItem>
</Tabs>

Another way to initialize the SDK is by sourcing the API key from the json file that contains your secret API key, downloaded from CDP portal.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' })
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        Coinbase.configure_from_json('~/Downloads/cdp_api_key.json')
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        Cdp.configure_from_json("~/Downloads/cdp_api_key.json")
        ```
    </TabItem>
</Tabs>

:::caution
Never inline your Secret API key information into your code.
Instead, securely store it and retrieve it from an environment variable, a secure database,
or other storage mechanism intended for configuration parameters.
:::



<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/welcome.mdx -->

---
title: Welcome to the CDP SDK
sidebar_label: Welcome
slug: welcome
---

_Leverage Coinbase's technology to build crypto applications_

The CDP (Coinbase Developer Platform) SDK is the entrypoint to our APIs, which encapsulate a large suite of
crypto services built by Coinbase engineers. The SDK lets you easily build crypto applications 
and allow you to focus on your core business logic without worrying about the complexities of the blockchain.

The SDK is currently available in *[TypeScript](https://github.com/coinbase/coinbase-sdk-nodejs)*,
*[Ruby](https://github.com/coinbase/coinbase-sdk-ruby)*, and *[Python](https://github.com/coinbase/cdp-sdk-python)*, with more languages coming soon.

If you are interested in a language that is not listed, please reach out to us in the 
[#cdp-sdk channel](https://discord.com/channels/1220414409550336183/1232677295546957919) in the CDP Discord.

:::info
The CDP SDK v0 is a pre-alpha release, which means that the APIs and SDK methods are subject to change.
We will continuously release updates to support new capabilities and improve the developer experience.
:::

## Get Started

After [installing the SDK](/cdp-sdk/docs/installation) and [provisioning your Secret API key](/cdp-sdk/docs/authentication),
you can immediately start building applications like the following:

- [Create secure wallets for your users](/mpc-wallet/docs/quickstart)
- [Send mass payments for free](/learn/docs/mass-payments)
- [Assign crypto wallets to your AI agents](/learn/docs/ai-wallets)
- [Programmatically trade assets](/mpc-wallet/docs/trades)
- [Build custom staking solutions](/staking/docs/quickstart)
- And much more!

## Capabilities

The CDP SDK has different capabilities on different networks.
To see the capabilities of the SDK on different networks, refer to the [Networks](networks) page.





<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/Ruby/installation/requirements.mdx -->


**Ruby 3.2**

Coinbase recommends using Ruby 3.2 or newer for the SDK. The sdk requires Ruby 2.7. To view your currently installed version of Ruby, run
the following from the command-line:

```bash
ruby -v
```

We recommend installing and managing Ruby versions with `rbenv`.
See [Using Package Managers](https://github.com/rbenv/rbenv?tab=readme-ov-file#homebrew) in the rbenv README for instructions on how to install `rbenv`.

Once `rbenv` has been installed, you can install and use the latest stable Ruby release by running the following commands:

```bash
rbenv install 3.3.1
rbenv global 3.3.1
```

**Rbsecp256k1 Gem**

The CDP SDK depends on the `rbsecp256k1` gem, which requires certain dependencies to be installed on your system. Follow the instructions provided [here](https://github.com/etscrivner/rbsecp256k1?tab=readme-ov-file#requirements) to meet these requirements:

- MacOS

On MacOS, run the following command:

```bash
brew install automake openssl libtool pkg-config gmp libffi
```

- Linux

On Linux, run the following command:

```
sudo apt-get install build-essential automake pkg-config libtool \
  libffi-dev libssl-dev libgmp-dev python3-dev
```

:::info
If you installed `libsecp256k1` but the gem cannot find it, run `ldconfig` to update your library load paths.
:::


<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/Ruby/installation/installation.mdx -->


There are two ways of installing the CDP SDK: for use with the Interactive Ruby Shell, or for use
in a Ruby project (e.g. Ruby on Rails).

**For `irb`**

Use the Interactive Ruby Shell (`irb`) to leverage Ruby's built-in REPL and quickly explore the functionality of our SDK.

Run the following from the command line:

```bash
gem install coinbase-sdk
```

After running `irb`, require the Gem:

```ruby
require 'coinbase'
```

**For Ruby on Rails**

Alternatively, if you want to install your CDP SDK gem to your Ruby on Rails project, add the following line to your Gemfile:

```ruby
gem 'coinbase-sdk'
```

Or if you are using a Gemspec:

```ruby
Gem::Specification.new do |spec|
  spec.add_runtime_dependency 'coinbase-sdk'
end
```

Then run:

```bash
bundle install
```

**OpenSSL Gem**

The CDP SDK relies on the `openssl` gem for certain cryptographic operations. If you encounter issues installing the CDP SDK, ensure that OpenSSL 3+ is installed, and that the version used by Ruby matches the version required by the gem.

If you encounter an error like this:

```bash
error: incomplete definition of type 'struct evp_md_ctx_st'
    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
```

re-install the openssl gem with the following command:

```bash
gem install openssl -- --with-openssl-dir=$(brew --prefix openssl@3)
```




<!-- File: /Users/tinahe/docs/projects/cdp-sdk/docs/installation.mdx -->

---
title: Installation
sidebar_label: Installation
slug: installation
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TypescriptRequirements from './NodeJS/installation/requirements.mdx';
import PythonRequirements from './Python/installation/requirements.mdx';
import RubyRequirements from './Ruby/installation/requirements.mdx';
import TypescriptInstallation from './NodeJS/installation/installation.mdx';
import PythonInstallation from './Python/installation/installation.mdx';
import RubyInstallation from './Ruby/installation/installation.mdx';

In the following, you will learn how to install the SDK.

## Requirements

:::info
Make sure that your developer environment satisfies all of the requirements before proceeding through the quickstart.
:::

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptRequirements />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyRequirements />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonRequirements />
    </TabItem>
</Tabs>

## Installation

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptInstallation />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyInstallation />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonInstallation />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/derivatives/docs/fix-msg-order.mdx -->

---
title: "Derivatives FIX Order Entry Messages"
sidebar_label: "Order Entry"
slug: "fix-msg-order"
hide_table_of_contents: false
---

The Coinbase Derivatives Exchange Order Entry FIX API for brokers and market makers allows connected firms to send, modify and cancel orders.

## Order Entry Message Types

The Coinbase Derivatives Exchange Order Entry FIX API supports the following message and execution types: 

<details> 
<summary><b>Client Message Types</b></summary> 
<div>

- [NewOrderSingle (35=D)](#new-order-single-35d): Request to submit new single-legged order.
- [OrderCancelRequest (35=F)](#order-cancel-request-35f): Request to cancel submitted single or multi-leg order.
- [OrderCancel/ReplaceRequest (35=G)](#order-cancelreplace-request-35g): Request to replace single order.

</div> 
</details>

<details> 
<summary><b>System Message and Execution Types</b></summary> 
<div>

- [Execution Report (35=8)](#execution-report-358): System reports in response to client requests. Execution types are:
   - [New/Canceled/Replaced Order (150=0/4/5)](#newcanceledreplaced-order-358-150045): Confirms new, canceled, or replaced order:
      - [New Order (150=0)](#newcanceledreplaced-order-358-150045): Confirms `NewOrderSingle` message.
      - [Canceled Order (150=4)](#newcanceledreplaced-order-358-150045): Confirms `OrderCancelRequest` message or unsolicited cancel.
      - [Replaced Order (150=5)](#newcanceledreplaced-order-358-150045): Confirms `OrderCancel/ReplaceRequest` message.
   - [Rejected Order (150=8)](#rejected-order-358-1508): Relays status that `OrderCancel/ReplaceRequest` is rejected.
   - [Trade (150=F)](#trade-358-150f): Relays information that order is filled completely or partially.
   - [Stop Triggered (150=L)](#stop-triggered-358-150l): Relays status of stop order.
   - [Done for Day (150=3)](#done-for-day-358-1503): Sent for all currently open orders after the trading day closes.
   - [Expired Order (150=C)](#expired-order-358-150c): Confirms day order is expired.
- [OrderCancelReject (35=9)](#order-cancel-reject-359): Rejection of client-originated cancel request.
- [BusinessReject (35=j)](#business-reject-35j): Rejection not reportable with well-formed Execution Report.

</div> 
</details>

<details> 
<summary><b>Admin Message Types</b></summary> 
<div>

- [LastExecIdRequest (35=F1)](#last-execid-request-35f1): Client request for `ExecId` of the last (most recent) event.
- [LastExecId (35=F2)](#last-execid-35f2): System response to F1.
- [EventResendRequest (35=F3)](#event-resend-request-35f3): Client request to resend order events in a specified range.
- [EventResendComplete (35=F4)](#event-resend-complete-35f4): System response to successful F3 request.
- [EventResendReject (35=F5)](#event-resend-reject-35f5): System response to unsuccessful F3 request.

</div> 
</details>


## New Order Single (35=D)

Used to send new single-legged orders for execution.

:::tip 
Messages are comprised of required (`Y`), optional (`N`) and conditionally required (`C`). Conditional fields are "pass-through," or required based on the presence or value of other fields.
:::

| Tag           | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------ | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| <pre>11</pre> | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 38            | OrderQty                    | Int(9)           | Y    | Order quantity. Must be a positive integer.                                                                                                                                                                                                                                           |
| 40            | OrdType                     | Char(1)          | Y    | Order type. Market orders are not accepted during opening auction. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                   |
| 44            | Price                       | Price(20)        | C    | Price per single contract unit. Required for limit or stop-limit orders. <ul><li>For sell OCO: Limit Price must be `>` StopPx</li> <li>For buy OCO: Limit Price must be `<` StopPx </li></ul>                                                                                            |
| 54            | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55            | Symbol                      | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167           | SecurityType                | String(6)        | Y    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59            | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60            | TransactTime                | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 77            | PositionEffect              | Char(1)          | N    | Order position effect. Default is `77=D` (PositionEffect="Default"). See [PositionEffect (77) code set](./fix-msg-code-sets.md#positioneffect-77).                                                                                                                                    |
| 99            | StopPx                      | Price(20)        | C    | Stop price of the order. Required for stop and stop-limit orders.                                                                                                                                                                                                                     |
| 18            | ExecInst                    | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                                                                    |
| 110           | MinQty                      | Int(9)           | N    | Minimum quantity of an order to be executed. Used only when `59=3` ([TimeInForce)](./fix-msg-code-sets.md#timeinforce-59)="Fill and Kill").                                                                                                                                           |
| 528           | OrderCapacity               | Char(1)          | Y    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                                                                                                                      |
| 432           | ExpireDate                  | LocalMktDate(8)  | C    | Order expiration date, or the last day the order can trade. `YYYYMMDD` format. Required only if `59=6` ([TimeInForce](./fix-msg-code-sets.md#timeinforce-59)="Good Till Date").                                                                                                       |
| 1028          | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031          | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 7928          | SelfMatchPreventionID       | Int(8)           | C    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000          | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |
| 582           | CustOrderCapacity           | Int(1)           | Y    | Customer capacity represented by Customer Type Indicator (CTI) Code (1-4). See [CustOrderCapacity (582) code set](./fix-msg-code-sets.md#custordercapacity-582).                                                                                                                      |
| 3040          | StopLimitPx                 | Decimal          | Y    | Limit order price if stop loss triggers                                                                                                                                                                                                                                               |



 <details> 
 <summary><b>LIMIT order example</b></summary> 
 <div>

```sh
### Example: LIMIT order
BeginString = FIX.4.4 
BodyLength = … 
MsgType = D 
MsgSeqNum = 3 
PossDupFlag = 
SenderCompID = EBR123
SenderSubID = smithj 
SendingTime = 20191202-10:15:41.383
TargetCompID = COIND
TargetSubID = TEST 
Account = C123
ClOrdID = 314bb362:109f840f9c0
Symbol=EUM20
SecurityType=FUT
OrderQty = 100
OrdType = 2
Price = 1.10317
Side = 1
TimeInForce = 0
TransactTime = 20171102-10:15:40.383
PositionEffect = O 
CustomerOrFirm = 0
OrderCapacity = A 
ManualOrderIndicator = Y
CustOrderHandlingInst = Y 
SelfMatchPreventionID = 12347565 
SelfMatchPreventionStrategy = N
CTICode = 4
CheckSum = …
```
</div> 
</details>

#### OCO Orders

OCO (One Cancels the Other) orders combine the features of limit and stop orders (and CDE treats them as a single order, not two linked ones). OCO orders let users set predefined limit and stop levels simultaneously depending on their view of the market. Initially, an OCO order acts like a regular limit order, contributing to market data. When its stop price condition is met, it shifts and behaves like a stop limit order.

**Price Rules**
- Sell OCO: Limit Price must be `>` StopPx 
- Buy OCO: Limit Price must be `<` StopPx

**Caveats​**
- DAY, GTC and GTD are supported for TimeInForce
- Like Stop orders, OCO orders cannot be modified. Clients must cancel then submit a new OCO order.
- The Post-Only tag is not supported. It cannot be populated or must be false.

**Parameters**

| Tag  | Name        | FIX Type | Req | Description                                                                                                                                                                                                   |
| :--- | :---------- | :------- | :-- | :-------------------- |
| 40   | OrdType     | Char     | Y   | Order Type must be O (the letter Oh) |
| 44   | Price       |  Decimal | Y   | Limit price (in this context) |
| 99   | StopPx      | Decimal  | Y   | Stop loss trigger price |
| 3040 | StopLimitPx | Decimal  | Y   | Limit order price if stop loss triggers |


####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

## Order Cancel Request (35=F)

A firm may use this message to cancel the remaining quantity of any working single or multi-leg order.

| Tag           | Name                 | FIX Type         | Req  | Description                                                                                                                                                                                                   |
| :------------ | :------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account              | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                           |
| <pre>11</pre> | ClOrdID              | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                      |
| 37            | OrderID              | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                    |
| 41            | OrigClOrdID          | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                   |
| 54            | Side                 | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                         |
| 55            | Symbol               | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                  |
| 167           | SecurityType         | String(6)        | Y    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                    |
| 60            | TransactTime         | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                        |
| 1028          | ManualOrderIndicator | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028). |

 <details> 
 <summary><b>CANCEL order example</b></summary> 
 <div>

```sh
# Example: Cancel order request
BeginString = FIX.4.4 
BodyLength = … 
MsgType = F
MsgSeqNum = 6
PossDupFlag = 
SenderCompID = EBR123
SenderSubID = smithj 
SendingTime = 20191202-10:15:41.383
TargetCompID = COIND
TargetSubID = TEST 
Account = C123
ClOrdID = 65780bfc:901n328943d
OrderID = 5038
OrigClOrdID = 71fa0cda:109f847292d Side = 1
Symbol = EUM20
SecurityType = FUT
TransactTime = 20171102-10:22:24.725
ManualOrderIndicator = Y 
CheckSum = …
```
</div> 
</details>

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Order Cancel/Replace Request (35=G)

A firm may use this message to replace an order. The following restrictions exist:

- Triggered Stop and Stop-Limit orders cannot be replaced, only canceled.
- Time in Force cannot be changed.
- If a field cannot be changed, the replacing order gets rejected.
- If the replaced-OrderQty is less than or equal to Total Fill Qty, then the Order is canceled. 


| Tag           | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------ | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account                     | String(12)       | Y    | Unique ID representing the account. <br />**Caution:** If the Account value is changed from the original value submitted in the New Order message, the order loses priority in the order book.                                                                                        |
| <pre>11</pre> | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 37            | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38            | OrderQty                    | Int(9)           | Y    | Order quantity. Must be a positive integer. <br />**Caution:** If OrderQty is reduced from the original value submitted in the New Order message, the order will maintain priority in the order book. If this value is increased, the order will lose priority on the order book.     |
| 40            | OrdType                     | Char(1)          | Y    | Order type. Market orders are not accepted during opening auction. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                    |
| 41            | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44            | Price                       | Price(20)        | C    | Price per single contract unit. Required for limit or stop-limit orders.                                                                                                                                                                                                              |
| 54            | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55            | Symbol                      | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167           | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59            | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60            | TransactTime                | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 77            | PositionEffect              | Char(1)          | N    | Order position effect. Default is `77=D` (PositionEffect="Default"). See [PositionEffect (77) code set](./fix-msg-code-sets.md#positioneffect-77).                                                                                                                                    |
| 99            | StopPx                      | Price(20)        | C    | Stop price of the order. Required for stop and stop-limit orders. <br />**Caution:** If the StopPx value is changed from the original value submitted in the New Order message, the order loses priority in the order book.                                                           |
| 528           | OrderCapacity               | Char(1)          | Y    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                                                                                                                      |
| 432           | ExpireDate                  | LocalMktDate(8)  | C    | Order expiration date, or the last day the order can trade. `YYYYMMDD` format. Required only if `59=6` ([TimeInForce](./fix-msg-code-sets.md#timeinforce-59)="Good Till Date").                                                                                                       |
| 1028          | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031          | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 7928          | SelfMatchPreventionID       | Int(8)           | C    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000          | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |
| 582           | CustOrderCapacity           | Int(1)           | Y    | Customer capacity represented by Customer Type Indicator (CTI) Code (1-4). See [CustOrderCapacity (582) code set](./fix-msg-code-sets.md#custordercapacity-582).                                                                                                                      |

 <details> 
 <summary><b>Cancel/Replace LIMIT order example</b></summary> 
 <div>

```sh
# Example: Cancel/Replace LIMIT order request
BeginString = FIX.4.4 
BodyLength = … 
MsgType = G 
MsgSeqNum = 15
PossDupFlag = 
SenderCompID = EBR123
SenderSubID = smithj 
SendingTime = 20191202-10:15:41.383
TargetCompID = COIND
TargetSubID = TEST 
Account = C123
ClOrdID = 71fa0cda:109f847292d:-7ffe 
OrderID = 5095
OrderQty = 150
OrdType = 2
OrigClOrdID = 71fa0cda:109f847292d:-7ffd 
Price = 1.10317
Side = 1
Symbol=EUM20
SecurityType=FUT
TimeInForce = 2
TransactTime = 20191102-10:22:21.725
PositionEffect = O 
OrderCapacity = A 
ManualOrderIndicator = Y
CustOrderHandlingInst = Y 
SelfMatchPreventionID = 12345678 
SelfMatchPreventionStrategy = N
CTICode = 4
CheckSum = …

```
</div> 
</details>

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Execution Report (35=8)

### New/Canceled/Replaced Order (35=8, 150=0/4/5)

New (`150=0`),  Canceled (`150=4`), and Replaced (`150=5`) reports share the same subset of Execution Report tags.

- **New** (`150=0`): Confirms new order in response to `NewOrderSingle` message. Sent for every new order, even those matched immediately.
- **Canceled** (`150=4`): Confirms order is canceled in response to `OrderCancelRequest`, or is an unsolicited cancel. A separate message is _not_ sent for the canceled order itself.
- **Replaced** (`150=5`): Confirms order is replaced in response to `OrderCancel/ReplaceRequest`. A separate message is _not_ sent for the replaced order itself.

:::note
These reports were formerly grouped as "Accepted" in the PDF docs. 
:::

| Tag  | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :--- | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1    | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| 11   | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 14   | CumQty                      | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                            |
| 17   | ExecID                      | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                  |
| 37   | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38   | OrderQty                    | Int(9)           | Y    | Order quantity.                                                                                                                                                                                                                                                                       |
| 39   | OrdStatus                   | Char(1)          | Y    | Represents order status, "New", "Canceled", or "Modify" (replaced). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39). <ul><li>`0` = New</li><li>`4` = Canceled</li><li>`5` = Modify</li></ul>                                                                       |
| 40   | OrdType                     | Char(1)          | Y    | Order type. Market orders are not accepted during opening auction. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                    |
| 41   | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44   | Price                       | Price(20)        | C    | Price per single contract unit. Required for limit or stop-limit orders.                                                                                                                                                                                                              |
| 54   | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55   | Symbol                      | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167  | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59   | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60   | TransactTime                | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 99   | StopPx                      | Price(20)        | C    | Stop price of the order. Required for stop and stop-limit orders.                                                                                                                                                                                                                     |
| 110  | MinQty                      | Int(9)           | N    | Minimum quantity of an order to be executed. Used only when `59=3` ([TimeInForce)](./fix-msg-code-sets.md#timeinforce-59)="Fill and Kill").                                                                                                                                           |
| 150  | ExecType                    | Char(1)          | Y    | Represents execution type, New (`150=0`), Canceled (`150=4`),  or Replaced (`150=5`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                             |
| 151  | LeavesQty                   | int(9)           | Y    | Number of contracts remaining for execution.                                                                                                                                                                                                                                          |
| 18   | ExecInst                    | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                                                                    |
| 528  | OrderCapacity               | Char(1)          | C    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). Pass through field from/when present in [New Order Single (35=D)](#new-order-single-35d). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                            |
| 378  | ExecRestatementReason       | Int(3)           | N    | Reason why the order was canceled by the system (e.g., cancel on disconnect, self-match prevention, etc.). See [ExecRestatementReason (378) code set](./fix-msg-code-sets.md#execrestatementreason-378).                                                                              |
| 432  | ExpireDate                  | LocalMktDate(8)  | C    | Order expiration date, or the last day the order could trade.                                                                                                                                                                                                                         |
| 1028 | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031 | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 3040 | StopLimitPx                 | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                                                                         |
| 5979 | RequestTime                 | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                              |
| 7928 | SelfMatchPreventionID       | Int(8)           | C    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000 | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

### Rejected Order (35=8, 150=8)

Message notifies client system of a rejected order. 

| Tag           | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                                |
| :------------ | :-------------------- | :--------------- | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1             | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                        |
| <pre>11</pre> | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                   |
| 14            | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                 |
| 17            | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                       |
| 37            | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                 |
| 38            | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                            |
| 39            | OrdStatus             | Char(1)          | Y    | Represents order status, "Rejected" (`8`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                             |
| 40            | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                     |
| 41            | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                |
| 44            | Price                 | Price(20)        | C    | Price per single contract unit.                                                                                                                                                                                                            |
| 54            | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                      |
| 55            | Symbol                | String(20)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                                              |
| 167           | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                 |
| 58            | Text                  | String(200)      | N    | Error code message. See [OrdRejReason (103) code set](./fix-msg-code-sets.md#ordrejreason-103).                                                                                                                                            |
| 59            | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).            |
| 60            | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                     |
| 75            | TradeDate             | LocalMktDate(8)  | Y    | Date of trading day, local time in `YYYYMMDD` format. When absent, represents the current day.                                                                                                                                             |
| 103           | OrdRejReason          | Int(6)           | N    | Error code. See [OrdRejReason (103) code set](./fix-msg-code-sets.md#ordrejreason-103).                                                                                                                                                    |
| 150           | ExecType              | Char(1)          | Y    | Represents execution type, "Rejected" (`150=8`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                       |
| 151           | LeavesQty             | Int(9)           | C    | Number of contracts remaining for execution. Always `151=0`.                                                                                                                                                                               |
| 18            | ExecInst              | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                         |
| 528           | OrderCapacity         | Char(1)          | C    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). Pass through field from/when present in [New Order Single (35=D)](#new-order-single-35d). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528). |
| 1028          | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                              |
| 1031          | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                          |
| 3040          | StopLimitPx           | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                              |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

### Trade (35=8, 150=F)

Sent by the Coinbase Derivatives Exchange system to report a trade. 

:::note
A [new order](#newcanceledreplaced-order-358-150045) rests on the order book, unmatched. A trade is a matched order, and if totally filled, no longer rests on the order book. 
:::

| Tag  | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| :--- | :-------------------- | :--------------- | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| 11   | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 14   | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 17   | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 880  | TrdMatchID            | String (20)      | Y    | Unique exchange ID representing a match event that results in multiple executions or trades.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 31   | LastPx                | Price(20)        | Y    | Price at which order was filled.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 32   | LastQty               | Int(9)           | Y    | Quantity filled.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 37   | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 38   | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 39   | OrdStatus             | Char(1)          | Y    | Represents order status, "Partial Fill" (`1`) or "Complete Fill" (`2`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                                                                                                                                                                                                                                                                                                      |
| 40   | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 41   | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 44   | Price                 | Price(20)        | C    | Price per single contract unit.<br /><br />For Execution Report messages sent in response to Market or Stop orders (with protection), Price is the Protection Price Limit (best available price +/- protection points).<br /> If the order is not completely filled, the remaining open quantity rests on the order book at the Protection Price Limit.<br /> **Note:** For spread trade Execution Reports, Price (44) is sent in the Execution Report – Fill Notice (35=`8`, 39=`1` or `2`) for the spread only and not the legs of the spread. |
| 6    | AvgPx                 | Price(20)        | C    | Calculated average price of all fills on this order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 54   | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 55   | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 167  | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 59   | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                                                                                                                                                                                                                                                                                  |
| 60   | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                                                                                                                                                                                                                                                                           |
| 75   | TradeDate             | LocalMktDate(8)  | Y    | Date of trading day, local time in `YYYYMMDD` format. When absent, represents the current day.                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 150  | ExecType              | Char(1)          | Y    | Represents execution type, "Trade" (`150=F`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 151  | LeavesQty             | Int(9)           | C    | Number of contracts remaining for execution after this fill.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 393  | TotalNumSecurities    | Int(3)           | N    | Number of leg fill acknowledgment messages sent with spread summary. Sent for spread fill messages only.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 442  | MultiLegReportingType | Int(1)           | N    | Represents acknowledgment of Outright, Leg of Spread, and Spread. See [MultiLegReporting (442) code set](./fix-msg-code-sets.md#multilegreporting-442).                                                                                                                                                                                                                                                                                                                                                                                          |
| 527  | SecondaryExecID       | String(40)       | C    | Unique exchange ID representing link between spread summary fill notice with leg fill notice and trade cancel messages.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 18   | ExecInst              | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 528  | OrderCapacity         | Char(1)          | Y    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                                                                                                                                                                                                                                                                                                                                                                                 |
| 1028 | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                                                                                                                                                                                                                                                                                    |
| 1031 | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                                                                                                                                                                                                                                                                                |
| 1057 | AggressorIndicator    | Char(1)          | C    | Represents the order as incoming or resting for the match event. See [AggressorIndicator (1057) code set](./fix-msg-code-sets.md#aggressorindicator-1057).                                                                                                                                                                                                                                                                                                                                                                                       |
| 3040 | StopLimitPx           | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 5979 | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                                                                                                                                                                                                                                                                                         |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

### Stop Triggered (35=8, 150=L)

Sent when a stop order is triggered. 

| Tag           | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------ | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| <pre>11</pre> | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 14            | CumQty                      | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                            |
| 17            | ExecID                      | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                  |
| 37            | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38            | OrderQty                    | Int(9)           | Y    | Order quantity.                                                                                                                                                                                                                                                                       |
| 39            | OrdStatus                   | Char(1)          | Y    | Represents order status, "New" (accepted), "Canceled", or "Modify" (replaced). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39). <ul><li>`0` = New</li><li>`4` = Canceled</li><li>`5` = Modify</li></ul>                                                            |
| 40            | OrdType                     | Char(1)          | Y    | Order type. Market orders are not accepted during opening auction. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                    |
| 41            | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44            | Price                       | Price(20)        | C    | Price per single contract unit. Required for limit or stop-limit orders.                                                                                                                                                                                                              |
| 54            | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55            | Symbol                      | String(20)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167           | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59            | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60            | TransactTime                | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 99            | StopPx                      | Price(20)        | C    | Stop price of the order. Required for stop and stop-limit orders.                                                                                                                                                                                                                     |
| 150           | ExecType                    | Char(1)          | Y    | Represents execution type, "Stop Triggered" (`150=L`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                                                            |
| 151           | LeavesQty                   | int(9)           | Y    | Number of contracts remaining for execution.                                                                                                                                                                                                                                          |
| 378           | ExecRestatementReason       | Int(3)           | N    | Reason why the order was canceled by the system (e.g., cancel on disconnect, self-match prevention, etc.). See [ExecRestatementReason (378) code set](./fix-msg-code-sets.md#execrestatementreason-378).                                                                              |
| 432           | ExpireDate                  | LocalMktDate(8)  | C    | Order expiration date, or the last day the order could trade.                                                                                                                                                                                                                         |
| 1028          | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031          | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 3040          | StopLimitPx                 | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                                                                         |
| 5979          | RequestTime                 | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                              |
| 7928          | SelfMatchPreventionID       | Int(8)           | C    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000          | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

### Done for Day (35=8, 150=3)

Reports with execution type Done for Day (`150=3`) are sent by the exchange to the firms that need the status of their open orders after the trading session is closed. 

| Tag           | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                     |
| :------------ | :-------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                             |
| <pre>11</pre> | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                        |
| 14            | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                      |
| 17            | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                            |
| 37            | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                      |
| 38            | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                 |
| 39            | OrdStatus             | Char(1)          | Y    | Represents order status, "Done for the Day" (`39=3`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                       |
| 40            | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                          |
| 41            | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                     |
| 44            | Price                 | Price(20)        | C    | Price per single contract unit.                                                                                                                                                                                                 |
| 54            | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                           |
| 55            | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                    |
| 167           | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                      |
| 59            | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59). |
| 60            | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                          |
| 75            | TradeDate             | LocalMktDate(8)  | Y    | Date of trading day, local time in `YYYYMMDD` format. When absent, represents the current day.                                                                                                                                  |
| 150           | ExecType              | Char(1)          | Y    | Represents execution type, "Done for Day" (`150=3`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                        |
| 151           | LeavesQty             | Int(9)           | C    | Number of contracts remaining for execution.                                                                                                                                                                                    |
| 1028          | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                   |
| 1031          | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                               |
| 3040          | StopLimitPx           | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                   |
| 5979          | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                        |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />

### Expired Order (35=8, 150=C)

Reports with execution type Expired (`150=C`) are sent by the exchange to the firms that need the track the expiration of their time-limited orders (such as DAY).

| Tag           | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------ | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1             | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| <pre>11</pre> | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 14            | CumQty                      | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                            |
| 17            | ExecID                      | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                  |
| 37            | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38            | OrderQty                    | Int(9)           | Y    | Order quantity. Must be a positive integer.                                                                                                                                                                                                                                           |
| 39            | OrdStatus                   | Char(1)          | Y    | Represents order status, "Expired" (`C`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                                                                         |
| 40            | OrdType                     | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                                                |
| 41            | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44            | Price                       | Price(20)        | N    | Price per single contract unit.                                                                                                                                                                                                                                                       |
| 54            | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55            | Symbol                      | String(20)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167           | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59            | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60            | TransactTime                | UTCTimestamp(21) | N    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 110           | MinQty                      | Int(9)           | C    | Sent in the Order Elimination message if the originating order was a FAK/FOK/MinQty that contained tag MinQty (110).                                                                                                                                                                  |
| 150           | ExecType                    | Char(1)          | Y    | Represents execution type, "Expired" (`150=C`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                                                                   |
| 151           | LeavesQty                   | Int(9)           | Y    | Number of contracts remaining for execution. Always `151=0`.                                                                                                                                                                                                                          |
| 378           | ExecRestatementReason       | Int(3)           | N    | Reason why the order was canceled by the system (e.g., cancel on disconnect, self-match prevention, etc.). See [ExecRestatementReason (378) code set](./fix-msg-code-sets.md#execrestatementreason-378).                                                                              |
| 528           | OrderCapacity               | Char(1)          | C    | Capacity of the firm placing the order (Agency=`A`/Principal=`P`). Pass through field from/when present in [New Order Single (35=D)](#new-order-single-35d). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                            |
| 1028          | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031          | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 3040          | StopLimitPx                 | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                                                                         |
| 7928          | SelfMatchPreventionID       | Int(8)           | N    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000          | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |
| 5979          | RequestTime                 | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                              |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Order Cancel Reject (35=9)

Sent by the Coinbase Derivatives Exchange system to notify the client on rejection of an Order Cancel Request OR Order Cancel/Replace. 

| Tag           | Name             | FIX Type         | Req  | Description                                                                                                                                                                          |
| :------------ | :--------------- | :--------------- | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1             | Account          | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                  |
| <pre>11</pre> | ClOrdID          | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                             |
| 37            | OrderID          | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                           |
| 39            | OrdStatus        | Char(1)          | Y    | Represents order status, "Undefined" (`U`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                      |
| 41            | OrigClOrdID      | String(20)       | N    | Last accepted `ClOrdID` in the order chain. If a value is included in tag 41 on order entry, the same value is returned. If not, the tag contains `0`.                               |
| 55            | Symbol           | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                         |
| 58            | Text             | String(200)      | N    | Text describing why the cancel request was rejected.                                                                                                                                 |
| 60            | TransactTime     | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                               |
| 102           | CXlRejReason     | Int(6)           | N    | Code representing the cancel reject reason. [See CXRejReason (102) code set](./fix-msg-code-sets.md#cxrejreason-102).                                                                |
| 434           | CxlRejResponseTo | Char(1)          | Y    | Represents the type of request that an Order Cancel Reject (35=9) message is in response to.<ul><li>`1` = Order Cancel Request</li> <li>`2` = Order Cancel/Replace Request</li></ul> |
| 5979          | RequestTime      | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                             |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Business Reject (35=j)

Sent by the Coinbase Derivatives Exchange system to notify the client of application-level rejection of client request which passed session-level validation but has business validation issues and cannot be reported with a well-formed Execution Report with Rejected status.

| Tag           | Name                 | FIX Type    | Req  | Description                                                                                                                                                                                                                                                                                          |
| :------------ | :------------------- | :---------- | :--- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 45            | RefSeqNum            | SeqNum(10)  | Y    | MsgSeqNum `<34>` of rejected message.                                                                                                                                                                                                                                                                  |
| <pre>58</pre> | Text                 | String(200) | N    | Free format text string.                                                                                                                                                                                                                                                                             |
| 379           | BusinessRejectRefID  | String(32)  | N    | Value of business-level "ID" of the message being rejected.                                                                                                                                                                                                                                          |
| 380           | BusinessRejectReason | Int(2)      | Y    | Code identifying reject reason: <br /><br /> `0`=Other<br />`1`=Unknown ID<br />`2`=Unknown security<br />`3`=Unsupported message type<br />`4`=Application not available<br />`5`=Conditionally required field missing<br />`6`=Not authorized<br />`7`=Delivery to firm not available at this time |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Last ExecId Request (35=F1)

Send this message to request the ExecId of the last (most recent) event sent by the trading system to this user/session.  Can be used to determine if the client missed any events while disconnected.  Also serves as a means of validating that the trading system is available and accepting requests.

| Tag  | Name    | FIX Type  | Req  | Description                          |
| :--- | :------ | :-------- | :--- | :----------------------------------- |
| 35   | MsgType | String(2) | Y    | Header tag identifying message type. |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Last ExecId (35=F2)

Sent in response to LastExecIdRequest.

| Tag  | Name      | FIX Type   | Req  | Description                             |
| :--- | :-------- | :--------- | :--- | :-------------------------------------- |
| 45   | RefSeqNum | SeqNum(10) | Y    | MsgSeqNum `<34>` of request message       |
| 17   | ExecID    | String(40) | Y    | ExecId of last event sent to this user. |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Event Resend Request (35=F3)

Send this message to request order events in the specified range be resent.  Since this is an application-level request, resent messages will have new sequence numbers and PossDupFlag (43) will not be set; rather, PossResend (97) will be set.  Rejects (and any other message that does not contain an ExecId) will not be resent.

| Tag   | Name        | FIX Type   | Req  | Description                                                                                    |
| :---- | :---------- | :--------- | :--- | :--------------------------------------------------------------------------------------------- |
| 22003 | BeginExecId | String(40) | Y    | Lower bound (inclusive) of ExecIds.                                                            |
| 22004 | EndExecId   | String(40) | N    | Upper bound (inclusive) of ExecIds.<br />Resend all events up the last known event if not set. |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Event Resend Complete (35=F4)

Sent in response to a successful Event Resend Request following all resent events.

| Tag   | Name             | FIX Type   | Req  | Description                       |
| :---- | :--------------- | :--------- | :--- | :-------------------------------- |
| 45    | RefSeqNum        | SeqNum(10) | Y    | MsgSeqNum `<34>` of request message |
| 22005 | ResentEventCount | Int        | Y    | Total number of events resent.    |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


## Event Resend Reject (35=F5)

Sent in response to an Event Resend Request if the request cannot be fulfilled.

| Tag   | Name                    | FIX Type    | Req  | Description                                                                                                                                                                                      |
| :---- | :---------------------- | :---------- | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 45    | RefSeqNum               | SeqNum(10)  | Y    | MsgSeqNum `<34>` of request message                                                                                                                                                                |
| 22006 | EventResendRejectReason | Int         | Y    | Represents reject reason: <br />`1` = BEGIN_EXEC_ID_TOO_SMALL<br />`2` = END_EXEC_ID_TOO_LARGE<br />`3` = RESEND_ALREADY_IN_PROGRESS<br />`4` = TOO_MANY_RESEND_REQUESTS<br />`5` = SERVER_ERROR |
| 58    | Text                    | String(200) | N    | Free format text string.                                                                                                                                                                         |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Order Entry Message Types](#order-entry-message-types).**
<br />


**See Also:**

- [Order Entry Gateways](./runbook.md#order-entry-gateways)


<!-- File: /Users/tinahe/docs/projects/derivatives/docs/downloads.mdx -->

---
title: "Derivatives Downloads"
sidebar_label: "Downloads"
slug: "downloads"
hide_table_of_contents: false
---

import Badge from '@components/Badge';

<Badge color="0a639a" url="/derivatives/docs/changelog#2024-jun-21" label="Latest Tarball Updated:2024 JUN 21" />

<br /> 
<br /> 

Coinbase Derivatives Exchange (CDE) provides downloads for FIX and SBE:

- <a href="/downloads/derivatives/cde-fix44-xml-dictionaries-latest.tar.gz" download target="blank">cde-fix44-xml-dictionaries-latest.tar.gz</a>
- <a href="/downloads/derivatives/cde-sbe-xml-schemas-latest.tar.gz" download target="blank">cde-sbe-xml-schemas-latest.tar.gz</a>

### FIX Dictionaries

The FIX tarball includes the following files:

```
cde-fix44-xml-dictionaries % tree
.
├── cde-fix44-dropcopy-api.xml
├── cde-fix44-market-api.xml
└── cde-fix44-orders-api.xml
```


### SBE Schemas

The SBE tarball includes the following files:

```
cde-sbe-xml-schemas % tree
.
├── cde-sbe-market-api.xml
├── cde-sbe-orders-api.xml
└── cde-sbe-session-api.xml
```


### Archive

{/* 
*** NOTE: 
How to archive the current tarball:
In static/downloads/intx
(1) Rename the current tarball from "latest" to the date it was released (which you can see in the commented record in ARCHIVE LIST). 
(2) Move the renamed tarball to the archive folder: static/downloads/intx/archive
    - tar -czvf cde-fix44-xml-dictionaries-20231013.tar.gz  cde-fix44-xml-dictionaries-20231013
    - tar -czvf cde-sbe-xml-schemas-20231013.tar.gz         cde-sbe-xml-schemas-20231013


Under ARCHIVE LIST (below)
(3) Add the renamed tarball to the archive list by uncommenting the item below. 
(4) Add a new comment with today's release date in preparation for the next archiving. 

How to create a new tarball: 
(1) Download new files: 
    - [cde-fix44-dropcopy-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/fix-api/src/main/resources/dropcopy/FIX44.xml)
    - [cde-fix44-market-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/fix-api/src/main/resources/marketdata/FIX44.xml)
    - [cde-fix44-orders-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/fix-api/src/main/resources/orders/FIX44.xml)

    - [cde-sbe-market-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/sbe-marketdata-gateway/src/main/resources/market-data-api.xml)
    - [cde-sbe-orders-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/sbe-order-gateway/src/main/resources/sbe-order-api.xml)
    - [cde-sbe-session-api.xml](https://github.cbhq.net/dcm/fairx/blob/main/sbe-session-api/src/main/resources/sbe-session-api.xml)
(2) Diff against old files (if you feel like it)
(3) Create a new "latest" tarball: 
    - tar -czvf cde-fix44-xml-dictionaries-latest.tar.gz cde-fix44-xml-dictionaries
    - tar -czvf cde-sbe-xml-schemas-latest.tar.gz cde-sbe-xml-schemas
*** */}


#### FIX Archive

{/* FIX ARCHIVE LIST: */}
{/* - 2023-JUN-21:  <a href="/downloads/intx/archive/cde-fix44-xml-dictionaries-20240621.tar.gz" download target="blank">cde-fix44-xml-dictionaries-20240621.tar.gz</a> */}
- 2023-OCT-13:  <a href="/downloads/intx/archive/cde-fix44-xml-dictionaries-20231013.tar.gz" download target="blank">cde-fix44-xml-dictionaries-20231013.tar.gz</a> 


#### SBE Archive

{/* SBE ARCHIVE LIST: */}
{/* - 2023-JUN-21:  <a href="/downloads/intx/archive/cde-sbe-xml-schemas.tar-20240621.tar.gz" download target="blank">cde-sbe-xml-schemas.tar-20240621.tar.gz</a> */}
- 2023-OCT-13:  <a href="/downloads/intx/archive/cde-sbe-xml-schemas.tar-20231013.tar.gz" download target="blank">cde-sbe-xml-schemas.tar-20231013.tar.gz</a>





<!-- File: /Users/tinahe/docs/projects/derivatives/docs/fix-msg-copy.mdx -->

---
title: "Derivatives FIX Drop Copy Messages"
sidebar_label: "Drop Copy"
slug: "fix-msg-copy"
hide_table_of_contents: false
---

The FIX Drop Copy session sends Execution Report (`35=8`) messages to the executing parties and client who might want a record of the trade. 

## Drop Copy Message Types

Customers can choose to receive Execution Reports over Drop Copy at two levels: Trade Execution and Order Status.

<details> 
<summary><b>Trade Execution</b></summary> 
<div>

##### Trade Execution Reports

- [Trade (150=F)](#trade-150f): Complete and partial fills.
- [Trade Correction (150=G)](#trade-correction-150g): Trade Correction on previously published fill.
- [Trade Cancel (150=H)](#trade-cancel-150h): Trade Bust message on previously published fill.

</div> 
</details>

<details> 
<summary><b>Order Status</b></summary> 
<div>

##### Order Status Reports

- [New/Canceled/Replaced Order (150=0/4/5)](#newcanceledreplaced-order-358-150045): Confirms new, canceled, or replaced order:
    - [New Order (150=0)](#newcanceledreplaced-order-358-150045): Confirms `NewOrderSingle` message.
    - [Canceled Order (150=4)](#newcanceledreplaced-order-358-150045): Confirms `OrderCancelRequest` message or unsolicited cancel.
    - [Replaced Order (150=5)](#newcanceledreplaced-order-358-150045): Confirms `OrderCancel/ReplaceRequest` message.
- [Rejected Order (150=8)](#rejected-order-1508): Sent in case a new or cancel/replace order message is rejected.
- [Done for Day (150=3)](#done-for-day-1503): Sent for all currently open orders after the trading day closes.
- [Expired Order (150=C)](#expired-order-150c): Sent for expired Day orders.

</div> 
</details>


## Parties Repeating Group (453)

| Tag   | Name          | FIX Type   | Req  | Description                                                                                             |
| :---- | :------------ | :--------- | :--- | :------------------------------------------------------------------------------------------------------ |
| 453   | NoPartyIDs    | NumInGroup | Y    | Number of PartyIDs in repeating group: Always `453=4`.                                                  |
| → 448 | PartyID       | String(20) | Y    | Party identifier/code                                                                                   |
| → 447 | PartyIDSource | Char       | Y    | 447 = D (Proprietary)                                                                                   |
| → 452 | PartyRole     | Int        | Y    | 1 - Subfirm Code<br /> 4 - Clearing Firm Code<br /> 11 - Order Originating Trader<br /> 55 - Session ID |


## Trade Execution

### Trade (150=F)

{/* <!--- NOTE: This table differs from OE by adding 528 and 582 and subtracting 6 ---> */}

Sent by the Coinbase Derivatives Exchange system to report a trade.

| Tag            | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| :------------- | :-------------------- | :--------------- | :--- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1              | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| <pre>453</pre> | NoPartyIDs            | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 11             | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 14             | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 17             | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 880            | TrdMatchID            | String (20)      | Y    | Unique exchange ID representing a match event that results in multiple executions or trades.                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 31             | LastPx                | Price(20)        | Y    | Price at which order was filled.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 32             | LastQty               | Int(9)           | Y    | Quantity filled.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| 37             | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 38             | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 39             | OrdStatus             | Char(1)          | Y    | Represents order status, "Partial Fill" (`1`) or "Complete Fill" (`2`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                                                                                                                                                                                                                                                                                                      |
| 40             | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| 41             | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| 44             | Price                 | Price(20)        | C    | Price per single contract unit.<br /><br />For Execution Report messages sent in response to Market or Stop orders (with protection), Price is the Protection Price Limit (best available price +/- protection points).<br /> If the order is not completely filled, the remaining open quantity rests on the order book at the Protection Price Limit.<br /> **Note:** For spread trade Execution Reports, Price (44) is sent in the Execution Report – Fill Notice (35=`8`, 39=`1` or `2`) for the spread only and not the legs of the spread. |
| 54             | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| 55             | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| 167            | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                                                                                                                                                                                                                                                                                       |
| 59             | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                                                                                                                                                                                                                                                                                  |
| 60             | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                                                                                                                                                                                                                                                                           |
| 18             | ExecInst              | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 75             | TradeDate             | LocalMktDate(8)  | Y    | Indicates date of trade reference in this message in `YYYYMMDD` format.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 150            | ExecType              | Char(1)          | Y    | Represents execution type, "Trade" (`150=F`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                                                                                                                                                                                                                                                                                                                                |
| 151            | LeavesQty             | Int(9)           | C    | Number of contracts remaining for execution after this fill.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 393            | TotalNumSecurities    | Int(3)           | N    | Number of leg fill acknowledgment messages sent with spread summary. Sent for spread fill messages only.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 442            | MultiLegReportingType | Int(1)           | N    | Represents acknowledgment of Outright, Leg of Spread, and Spread. See [MultiLegReporting (442) code set](./fix-msg-code-sets.md#multilegreporting-442).                                                                                                                                                                                                                                                                                                                                                                                          |
| 527            | SecondaryExecID       | String(40)       | C    | Unique exchange ID representing link between spread summary fill notice with leg fill notice and trade cancel messages.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 528            | OrderCapacity         | Int(1)           | Y    | Represents the type of business conducted: <ul><li>`528=0` = Customer/Agency</li><li>`528=1` = Principal</li></ul>                                                                                                                                                                                                                                                                                                                                                                                                                               |
| 1028           | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                                                                                                                                                                                                                                                                                    |
| 1031           | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                                                                                                                                                                                                                                                                                |
| 1057           | AggressorIndicator    | Char(1)          | C    | Represents the order as incoming or resting for the match event. See [AggressorIndicator (1057) code set](./fix-msg-code-sets.md#aggressorindicator-1057).                                                                                                                                                                                                                                                                                                                                                                                       |
| 5979           | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| 828            | TrdType               | Int(1)           | N    | Type of trade, only populated if enabled for blocks. Block trades are set to 1 (`828=1`). For all other trade types, TrdType is null.                                                                                                                                                                                                                                                                                                                                                                                                            |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />

### Trade Correction (150=G)

{/* <!--- NOTE: Seems to be missing OrderQty (38). Also, why is TrdMatchID (880) at the bottom?  ---> */}

| Tag            | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                   |
| :------------- | :-------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                           |
| <pre>453</pre> | NoPartyIDs            | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                    |
| 11             | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                      |
| 14             | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                    |
| 17             | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                          |
| 19             | ExecRefID             | String(40)       | Y    | Unique ID representing the trade being corrected.                                                                                                                                                             |
| 31             | LastPx                | Price(20)        | Y    | Price at which order was filled.                                                                                                                                                                              |
| 32             | LastQty               | Int(9)           | Y    | Quantity filled.                                                                                                                                                                                              |
| 37             | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                    |
| 39             | OrdStatus             | Char(1)          | Y    | Represents order status, "Partial Fill" (`1`) or "Complete Fill" (`2`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                   |
| 41             | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                   |
| 54             | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                         |
| 55             | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                 |
| 167            | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                    |
| 60             | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                        |
| 75             | TradeDate             | LocalMktDate(8)  | Y    | Indicates date of trade reference in this message in `YYYYMMDD` format.                                                                                                                                       |
| 150            | ExecType              | Char(1)          | Y    | Represents execution type, "Trade Correct" (`150=G`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                     |
| 393            | TotalNumSecurities    | Int(3)           | N    | Number of leg fill acknowledgment messages sent with spread summary. Sent for spread fill messages only.                                                                                                      |
| 442            | MultiLegReportingType | Int(1)           | N    | Represents acknowledgment of Outright, Leg of Spread, and Spread. See [MultiLegReporting (442) code set](./fix-msg-code-sets.md#multilegreporting-442).                                                       |
| 527            | SecondaryExecID       | String(40)       | C    | Unique exchange ID representing link between spread summary fill notice with leg fill notice and trade cancel messages.                                                                                       |
| 1028           | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028). |
| 1031           | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                             |
| 5979           | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                      |
| 880            | TradeMatchId          | String(20)       | Y    | Unique exchange identifier to identify both sides of a match                                                                                                                                                  |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />

### Trade Cancel (150=H)

{/* <!--- NOTE: Seems to be missing OrderQty (38)  ---> */}

| Tag            | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                   |
| :------------- | :-------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                           |
| <pre>453</pre> | NoPartyIDs            | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                    |
| 11             | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                      |
| 14             | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                    |
| 17             | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                          |
| 880            | TrdMatchID            | String (20)      | Y    | Unique exchange ID representing a match event that results in multiple executions or trades.                                                                                                                  |
| 19             | ExecRefID             | String(40)       | Y    | Unique ID representing the trade being corrected.                                                                                                                                                             |
| 31             | LastPx                | Price(20)        | Y    | Price at which order was filled.                                                                                                                                                                              |
| 32             | LastQty               | Int(9)           | Y    | Quantity filled.                                                                                                                                                                                              |
| 37             | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                    |
| 39             | OrdStatus             | Char(1)          | Y    | Represents order status, "Partial Fill" (`1`) or "Complete Fill" (`2`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                   |
| 41             | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                   |
| 54             | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                         |
| 55             | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                 |
| 167            | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                    |
| 60             | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                        |
| 75             | TradeDate             | LocalMktDate(8)  | Y    | Indicates date of trade reference in this message in `YYYYMMDD` format.                                                                                                                                       |
| 150            | ExecType              | Char(1)          | Y    | Represents execution type, "Trade Cancel" (`150=H`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                      |
| 393            | TotalNumSecurities    | Int(3)           | N    | Number of leg fill acknowledgment messages sent with spread summary. Sent for spread fill messages only.                                                                                                      |
| 442            | MultiLegReportingType | Int(1)           | N    | Represents acknowledgment of Outright, Leg of Spread, and Spread. See [MultiLegReporting (442) code set](./fix-msg-code-sets.md#multilegreporting-442).                                                       |
| 527            | SecondaryExecID       | String(40)       | C    | Unique exchange ID representing link between spread summary fill notice with leg fill notice and trade cancel messages.                                                                                       |
| 1028           | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028). |
| 1031           | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                             |
| 5979           | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                      |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />

## Order Status

### New/Canceled/Replaced Order (35=8, 150=0/4/5)

{/* <!---NOTE: This table differs from OE by adding 528 and 582 ---> */}

New (`150=0`),  Canceled (`150=4`), and Replaced (`150=5`) reports share the same subset of Execution Report tags.

- **New** (`150=0`): Confirms new order in response to `NewOrderSingle` message. Sent for every new order, even those matched immediately.
- **Canceled** (`150=4`): Confirms order is canceled in response to `OrderCancelRequest`, or is an unsolicited cancel. A separate message is _not_ sent for the canceled order itself.
- **Replaced** (`150=5`): Confirms order is replaced in response to `OrderCancel/ReplaceRequest`. A separate message is _not_ sent for the replaced order itself.

:::note
These reports were formerly grouped as "Accepted" in the PDF docs. 
:::

| Tag            | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------- | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| <pre>453</pre> | NoPartyIDs                  | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                                                                                            |
| 11             | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 14             | CumQty                      | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                            |
| 17             | ExecID                      | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                  |
| 37             | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38             | OrderQty                    | Int(9)           | Y    | Order quantity.                                                                                                                                                                                                                                                                       |
| 39             | OrdStatus                   | Char(1)          | Y    | Represents order status, "New", "Canceled", or "Modify" (replaced). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39). <ul><li>`0` = New</li><li>`4` = Canceled</li><li>`5` = Modify</li></ul>                                                                       |
| 40             | OrdType                     | Char(1)          | Y    | Order type. Market orders are not accepted during opening auction. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                    |
| 41             | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44             | Price                       | Price(20)        | C    | Price per single contract unit. Required for limit or stop-limit orders.                                                                                                                                                                                                              |
| 54             | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55             | Symbol                      | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167            | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59             | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60             | TransactTime                | UTCTimestamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 99             | StopPx                      | Price(20)        | C    | Stop price of the order. Required for stop and stop-limit orders.                                                                                                                                                                                                                     |
| 18             | ExecInst                    | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                                                                                    |
| 110            | MinQty                      | Int(9)           | N    | Minimum quantity of an order to be executed. Used only when `59=3` ([TimeInForce)](./fix-msg-code-sets.md#timeinforce-59)="Fill and Kill").                                                                                                                                           |
| 150            | ExecType                    | Char(1)          | Y    | Represents execution type, New (`150=0`), Canceled (`150=4`),  or Replaced (`150=5`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                             |
| 151            | LeavesQty                   | int(9)           | Y    | Number of contracts remaining for execution.                                                                                                                                                                                                                                          |
| 378            | ExecRestatementReason       | Int(3)           | N    | Reason why the order was canceled by the system (e.g., cancel on disconnect, self-match prevention, etc.). See [ExecRestatementReason (378) code set](./fix-msg-code-sets.md#execrestatementreason-378).                                                                              |
| 432            | ExpireDate                  | LocalMktDate(8)  | C    | Order expiration date, or the last day the order could trade.                                                                                                                                                                                                                         |
| 528            | OrderCapacity               | Int(1)           | C    | Pass through field from/when present in NewOrder. Identifies origin of order (i.e., capacity of firm placing the order). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                                                                |
| 582            | CustOrderCapacity           | Char(1)          | C    | Pass through field from/when present in NewOrder. Customer Type Indicator as defined by NFA. See [CustOrderCapacity (582) code set](./fix-msg-code-sets.md#custordercapacity-582).                                                                                                    |
| 1028           | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031           | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 3040           | StopLimitPx                 | Decimal          | Y    | Limit order price when stop loss is triggered                                                                                                                                                                                                                                         |
| 5979           | RequestTime                 | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                              |
| 7928           | SelfMatchPreventionID       | Int(8)           | C    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000           | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />


### Rejected Order (150=8)

{/* <!--- NOTE: Seems to be missing TradeDate (75) and LeavesQty (151) ---> */}

Message notifies client system of a rejected order. 

| Tag            | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                     |
| :------------- | :-------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                             |
| <pre>453</pre> | NoPartyIDs            | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                                      |
| 11             | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                        |
| 14             | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                      |
| 17             | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                            |
| 37             | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                      |
| 38             | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                 |
| 39             | OrdStatus             | Char(1)          | Y    | Represents order status, "Rejected" (`8`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                  |
| 40             | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                          |
| 41             | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                     |
| 44             | Price                 | Price(20)        | C    | Price per single contract unit.                                                                                                                                                                                                 |
| 54             | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                           |
| 55             | Symbol                | String(20)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                                   |
| 167            | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                      |
| 58             | Text                  | String(200)      | N    | Error code message. See [OrdRejReason (103) code set](./fix-msg-code-sets.md#ordrejreason-103).                                                                                                                                 |
| 59             | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59). |
| 60             | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                          |
| 18             | ExecInst              | Char             | N    | The execution instruction flags for the order.<br/><br/>Supported values:<br/>`6` = Add Liquidity Only (Post Only)                                                                                                              |
| 103            | OrdRejReason          | Int(6)           | N    | Error code. See [OrdRejReason (103) code set](./fix-msg-code-sets.md#ordrejreason-103).                                                                                                                                         |
| 150            | ExecType              | Char(1)          | Y    | Represents execution type, "Rejected" (`150=8`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                            |
| 1028           | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                   |
| 1031           | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                               |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />

### Done for Day (150=3)

{/* <!--- NOTE: Adds: 99, 210, 432, 528, 582, 7928, 8000. Missing: 75, 5979 ---> */}

Reports with execution type Done for Day (`150=3`) are sent by the exchange to the firms that need the status of their open orders after the trading session is closed. 

| Tag            | Name                  | FIX Type         | Req  | Description                                                                                                                                                                                                                     |
| :------------- | :-------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account               | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                             |
| <pre>453</pre> | NoPartyIDs            | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                                      |
| 11             | ClOrdID               | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                        |
| 14             | CumQty                | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                      |
| 17             | ExecID                | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                            |
| 37             | OrderID               | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                      |
| 38             | OrderQty              | Int(9)           | C    | Order quantity.                                                                                                                                                                                                                 |
| 39             | OrdStatus             | Char(1)          | Y    | Represents order status, "Done for the Day" (`39=3`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                       |
| 40             | OrdType               | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                          |
| 41             | OrigClOrdID           | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                     |
| 44             | Price                 | Price(20)        | C    | Price per single contract unit.                                                                                                                                                                                                 |
| 54             | Side                  | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                           |
| 55             | Symbol                | String(24)       | Y    | Represents details of an instrument. Future Example: `EUM20`.                                                                                                                                                                   |
| 167            | SecurityType          | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                      |
| 59             | TimeInForce           | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59). |
| 60             | TransactTime          | UTCTimeStamp(21) | Y    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                          |
| 75             | TradeDate             | LocalMktDate(8)  | Y    | Date of trading day, local time in `YYYYMMDD` format. When absent, represents the current day.                                                                                                                                  |
| 150            | ExecType              | Char(1)          | Y    | Represents execution type, "Done for Day" (`150=3`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                        |
| 151            | LeavesQty             | Int(9)           | C    | Number of contracts remaining for execution.                                                                                                                                                                                    |
| 1028           | ManualOrderIndicator  | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                   |
| 1031           | CustOrderHandlingInst | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                               |
| 5979           | RequestTime           | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                        |


### Expired Order (150=C)

{/* <!--- NOTE: These are missing from the Order Entry table: 99, 210, 378, 432, 528, 582. Should they match?  ---> */}

Reports with execution type Expired (`150=C`) are sent by the exchange to the firms that need the track the expiration of their time-limited orders (such as DAY).

| Tag            | Name                        | FIX Type         | Req  | Description                                                                                                                                                                                                                                                                           |
| :------------- | :-------------------------- | :--------------- | :--- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1              | Account                     | String(12)       | Y    | Unique ID representing the account.                                                                                                                                                                                                                                                   |
| <pre>453</pre> | NoPartyIDs                  | NumInGroup       | Y    | Represents the Parties repeating group. See [Parties Repeating Group (453)](#parties-repeating-group-453).                                                                                                                                                                            |
| 11             | ClOrdID                     | String(20)       | Y    | Unique client ID representing the order. Client system must maintain uniqueness of this value for the life of the order.                                                                                                                                                              |
| 14             | CumQty                      | Int(9)           | Y    | Cumulated traded quantity throughout lifespan of an order.                                                                                                                                                                                                                            |
| 17             | ExecID                      | String(40)       | Y    | Unique exchange ID representing the trade execution.                                                                                                                                                                                                                                  |
| 37             | OrderID                     | String(17)       | Y    | Unique exchange ID representing the order.                                                                                                                                                                                                                                            |
| 38             | OrderQty                    | Int(9)           | Y    | Order quantity. Must be a positive integer.                                                                                                                                                                                                                                           |
| 39             | OrdStatus                   | Char(1)          | Y    | Represents order status, "Expired" (`C`). See [OrdStatus (39) code set](./fix-msg-code-sets.md#ordstatus-39).                                                                                                                                                                         |
| 40             | OrdType                     | Char(1)          | Y    | Order type such as market, limit, etc. See [OrdType (40) code set](./fix-msg-code-sets.md#ordtype-40).                                                                                                                                                                                |
| 41             | OrigClOrdID                 | String(20)       | N    | Last accepted `ClOrdID` in the order chain.                                                                                                                                                                                                                                           |
| 44             | Price                       | Price(20)        | N    | Price per single contract unit.                                                                                                                                                                                                                                                       |
| 54             | Side                        | Char(1)          | Y    | Side of order. See [Side (54) code set](./fix-msg-code-sets.md#side-54--legside-624).                                                                                                                                                                                                 |
| 55             | Symbol                      | String(20)       | Y    | Represents details of an instrument. Future Example: `EUM20`                                                                                                                                                                                                                          |
| 167            | SecurityType                | String(6)        | N    | Represents security type. See [SecurityType (167) code set](./fix-msg-code-sets.md#securitytype-167--legsecuritytype-609).                                                                                                                                                            |
| 59             | TimeInForce                 | Char(1)          | N    | Represents how long the order remains in effect. Default is `59=0` (TimeInForce="Day"). For `59=3` (TimeInForce="FAK"), `MinQty` can also be specified. See [TimeInForce (59) code set](./fix-msg-code-sets.md#timeinforce-59).                                                       |
| 60             | TransactTime                | UTCTimestamp(21) | N    | Time when the order message was submitted. UTC format `YYYYMMDD-HH:MM:SS.sss` in microseconds. <br /> Example: `20091216-19:21:41.109`                                                                                                                                                |
| 110            | MinQty                      | Int(9)           | C    | Sent in the Order Elimination message if the originating order was a FAK/FOK/MinQty that contained tag MinQty (110).                                                                                                                                                                  |
| 150            | ExecType                    | Char(1)          | Y    | Represents execution type, "Expired" (`150=C`). See [ExecType (150) code set](./fix-msg-code-sets.md#exectype-150).                                                                                                                                                                   |
| 151            | LeavesQty                   | Int(9)           | Y    | Number of contracts remaining for execution. Always `151=0`.                                                                                                                                                                                                                          |
| 378            | ExecRestatementReason       | Int(3)           | N    | Reason why the order was canceled by the system (e.g., cancel on disconnect, self-match prevention, etc.). See [ExecRestatementReason (378) code set](./fix-msg-code-sets.md#execrestatementreason-378).                                                                              |
| 528            | OrderCapacity               | Int(1)           | C    | Pass through field from/when present in NewOrder. Identifies origin of order (i.e., capacity of firm placing the order). See [OrderCapacity (528) code set](./fix-msg-code-sets.md#ordercapacity-528).                                                                                |
| 1028           | ManualOrderIndicator        | Boolean(1)       | Y    | Represents whether or not the order was generated manually (`Y`) or automatically (`N`) with trading software. See  [ManualOrderIndicator (1028) code set](./fix-msg-code-sets.md#manualorderindicator-1028).                                                                         |
| 1031           | CustOrderHandlingInst       | String(1)        | Y    | Source of the original order. See [CustOrderHandlingInst (1031) code set](./fix-msg-code-sets.md#customerorderhandlinginst-1031).                                                                                                                                                     |
| 7928           | SelfMatchPreventionID       | Int(8)           | N    | Unique ID (per executing firm) representing two orders that should not match. Required when market participants enable SelfMatch Prevention. Max length is 8 digits.                                                                                                                  |
| 8000           | SelfMatchPreventionStrategy | Char(1)          | N    | Represents type of cancel instruction when SelfMatch Prevention is triggered. Client systems must also include `SelfMatchPreventionID` (7928) on the originating message. See [SelfMatchPreventionStrategy (8000) code set](./fix-msg-code-sets.md#selfmatchpreventionstrategy-8000). |
| 5979           | RequestTime                 | Int(20)          | N    | Time when the request was received by the exchange. UTC format in microseconds: `YYYYMMDD-HH:MM:SS.sss`.                                                                                                                                                                              |

####  <img src={require('../assets/images/arrow-176-512.png').default} width="16" alt="Green Check" /> **Return to [Drop Copy Message Types](#drop-copy-message-types).**
<br />


<!-- File: /Users/tinahe/docs/projects/derivatives/docs/connectivity.mdx -->

---
title: "Derivatives Connectivity"
sidebar_label: "Connectivity"
slug: "connectivity"
---

## CDE Locations

Coinbase Derivatives Exchange (CDE) trading platform is housed in the [CyrusOne CH1](https://www.cyrusone.com/data-centers/north-america/illinois/chi1-chicago) data center in Aurora, Illinois. 

The backup data center is located in the [Equinix NY5](https://www.equinix.com/data-centers/americas-colocation/united-states-colocation/new-york-data-centers/ny5) data center in Secaucus, New Jersey. 

#### **Supported Environments and Network Connectivity**

| Environment       | Data Center  | Connectivity  |
|:------------------|:-------------|:--------------|
| Production        | CyrusOne CH1 | Cross Connect |
| Disaster Recovery | Equinix NY5  | Cross Connect |
| Integration       | Equinix NY5  | Cross Connect |
| Staging           |              | Internet      |

:::note
For detailed information on the network connectivity guide, contact the CDE team at [derivatives@coinbase.com](mailto:derivatives@coinbase.com).
:::

:::info
See the [Runbook](./runbook.md) for information on the FIX API gateways.
:::


## Establishing Connectivity

Coinbase Derivatives Exchange (CDE) participants can [establish cross-connects](#how-to-connect) in the facilities detailed under [CDE Locations](#cde-locations). 

<img src={require('../assets/images/cde-network-architecture.png').default} width="700" alt="Multicast connection using the BGP routing protocol with PIM" />

<br />

#### How to Connect

1. **Contact the CDE team** about establishing a private co-located fiber connection. <br />
   
   _The CDE team will:_

    a. Issue a letter of authorization (LOA) allowing you, the particpant, to connect into CDE equipment.

    :::info Redundant Connections
    Each fiber connects to physical equipment that is completely redundant from the other connections.
    :::

    b. Assign 2 IP address per side:
    - 1 address range for BGP peering.
    - 1 address range for connecting to CDE that is advertised by the participant.

    c. Assign a private ASN for BGP peering. Participants can use a public ASN as long as it is owned by them.

1. **Configure BGP** with all parameters provided by CDE.

2. **Optionally, configure PIM and RP addresses** to receive multicast market data. RP Addresses for each connection are provided by CDE.

:::tip multicast data
You can optionally configure [Protocol Independent Multicast](https://en.wikipedia.org/wiki/Protocol_Independent_Multicast) (PIM) and Rendezvous Point (RP) address to receive multicast data.
:::





<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/json-rpc.mdx -->

---
title: Wallet History JSON RPC
sidebar_label: JSON RPC
slug: json-rpc
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import JSONListBalancesRequest from './JSON/list_balances_req.mdx';
import JSONListBalancesResponse from './JSON/list_balances_resp.mdx';
import JSONListBalanceDetailsRequest from './JSON/list_balance_details_req.mdx';
import JSONListBalanceDetailsResponse from './JSON/list_balance_details_resp.mdx';
import JSONListBalanceHistoriesRequest from './JSON/list_balance_histories_req.mdx';
import JSONListBalanceHistoriesResponse from './JSON/list_balance_histories_resp.mdx';
import JSONListAddressTransactionsRequest from './JSON/list_address_transactions_req.mdx';
import JSONListAddressTransactionsResponse from './JSON/list_address_transactions_resp.mdx';

## How to Make API Requests

You can use the [JSON RPC playground](https://portal.cdp.coinbase.com/products/onchain-data) to make requests to the Data API via JSON RPC.

Alternatively, you can construct your own requests to the Data API via JSON RPC:

1. Log into [CDP](https://portal.cdp.coinbase.com) and go to the [Data](https://portal.cdp.coinbase.com/products/onchain-data) page for your endpoint and API credentials.
1. Construct your API requests with the appropriate network label.
    - Select a [supported network](/onchain-data/docs/networks#capabilities).
    - Identify the network's [JSON RPC network label](/onchain-data/docs/networks#network-labels).
    - Include the label in the [RPC Endpoint URL](https://portal.cdp.coinbase.com/products/onchain-data).
1. Explore the endpoints and parameters available in this API reference.
1. Open a terminal and make your requests.

:::tip cdp access
You can log into your [Coinbase.com](https://www.coinbase.com) (if you have one) and select **Developer Platform** from the app switcher (top right); or you can create a new CDP-only account at [cdp.coinbase.com/create-account](https://cdp.coinbase.com/create-account).
:::

## Data methods

### cdp_listBalances

This endpoint retrieves the latest balances for an address.

#### Parameters

| Name      | Type   | Req | Description                                                                                                                                               |
| :-------- | :----- | :-: | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| address   | string |  Y  | Blockchain address hash (Note that EVM chain address hash should be lowered cased.)                                                                       |
| pageSize  | string |  N  | Number of balances to receive in a page. The default value is 25. The maximum value is 100, and values supplied over this will be coerced to the maximum. |
| pageToken | string |  N  | Provided from a previous response's nextPageToken                                                                                                         |

#### Returns

| Field            | Description                                                                                                                                                                                                                                                                |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| asset.id         | The identity of the asset for querying for details or history.                                                                                                                                                                                                             |
| asset.type       | The type of Asset the definition describes. For example: "native", "erc20", "erc721", "erc1155", "creditAlphanum4", "fa2".                                                                                                                                                 |
| asset.groupId    | The contract address or group identifier for an Asset. For an NFT or a multi-token Asset this may identify a group of Asset. For a native Asset this will not be set.                                                                                                      |
| asset.subGroupId | The identifier that distinguishes the identity of the Asset within the contract address or group. For an NFT or a multi-token Asset that can have many Assets associated with a contract address, this could be a token ID. For a UTXO, this could be the coin identifier. |
| value            | The amount of the balance in the lowest denomination of the asset. Type is in BigInteger in standard base64 encoding.                                                                                                                                                      |
| valueStr         | The string representation of the balance value to avoid precision loss.                                                                                                                                                                                                    |
| decimals         | The number of decimals the asset utilizes.                                                                                                                                                                                                                                 |
| nextPageToken    | A token which can be provided as `pageToken` to retrieve the next page. If this field is omitted, there are no additional pages.                                                                                                                                           |
|                  |

#### Request/Response

<Tabs  groupId="programming-language">
    <TabItem value="request" label="Request (JSON)" default>
        <JSONListBalancesRequest />
    </TabItem>
    <TabItem value="response" label="Response (JSON)">
        <JSONListBalancesResponse />
    </TabItem>
</Tabs>

### cdp_listBalanceDetails

This endpoint lists the latest balance details for an asset for an address.

#### Parameters

| Name      | Type   | Req | Description                                                                                                                                               |
| :-------- | :----- | :-: | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| address   | string |  Y  | Blockchain address hash (Note that EVM chain address hash should be lowered cased.)                                                                       |
| assetId   | string |  Y  | Provided from ListBalances or ListAddressTransations response’s asset field                                                                               |
| pageSize  | string |  N  | Number of balances to receive in a page. The default value is 25. The maximum value is 100, and values supplied over this will be coerced to the maximum. |
| pageToken | string |  N  | Provided from a previous response's nextPageToken                                                                                                         |

#### Returns

| Field            | Description                                                                                                                                                                                                                                                                |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| asset.id         | The identity of the asset for querying for details or history.                                                                                                                                                                                                             |
| asset.type       | The type of Asset the definition describes. For example: "native", "erc20", "erc721", "erc1155", "creditAlphanum4", "fa2".                                                                                                                                                 |
| asset.groupId    | The contract address or group identifier for an Asset. For an NFT or a multi-token Asset this may identify a group of Asset. For a native Asset this will not be set.                                                                                                      |
| asset.subGroupId | The identifier that distinguishes the identity of the Asset within the contract address or group. For an NFT or a multi-token Asset that can have many Assets associated with a contract address, this could be a token ID. For a UTXO, this could be the coin identifier. |
| value            | The amount of the balance in the lowest denomination of the asset. Type is in BigInteger in standard base64 encoding.                                                                                                                                                      |
| valueStr         | The string representation of the balance value to avoid precision loss.                                                                                                                                                                                                    |
| decimals         | The number of decimals the asset utilizes.                                                                                                                                                                                                                                 |
| nextPageToken    | A token which can be provided as `pageToken` to retrieve the next page. If this field is omitted, there are no additional pages.                                                                                                                                           |

#### Request/Response

<Tabs  groupId="programming-language">
    <TabItem value="request" label="Request (JSON)" default>
        <JSONListBalanceDetailsRequest />
    </TabItem>
    <TabItem value="response" label="Response (JSON)">
        <JSONListBalanceDetailsResponse />
    </TabItem>
</Tabs>

### cdp_listBalanceHistories

This endpoint lists the balance histories for an asset for an address. `cdp_listBalanceHistory` is also a valid method name for this method.

#### Parameters

| Name      | Type   | Req | Description                                                                                                                                               |
| :-------- | :----- | :-: | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| address   | string |  Y  | Blockchain address hash (Note that EVM chain address hash should be lowered cased.)                                                                       |
| assetId   | string |  Y  | Provided from ListBalances or ListAddressTransations response’s asset field                                                                               |
| pageSize  | string |  N  | Number of balances to receive in a page. The default value is 25. The maximum value is 100, and values supplied over this will be coerced to the maximum. |
| pageToken | string |  N  | Provided from a previous response's nextPageToken                                                                                                         |

#### Returns

| Field         | Description                                                                                                                      |
| :------------ | :------------------------------------------------------------------------------------------------------------------------------- |
| blockHash     | The hash of the block this transaction was included in.                                                                          |
| blockHeight   | The height of the block this transaction was included in.                                                                        |
| value         | The amount of the balance in the lowest denomination of the asset. Type is in BigInteger in standard base64 encoding.            |
| valueStr      | The string representation of the balance value to avoid precision loss.                                                          |
| nextPageToken | A token which can be provided as `pageToken` to retrieve the next page. If this field is omitted, there are no additional pages. |

#### Request/Response

<Tabs  groupId="programming-language">
    <TabItem value="request" label="Request (JSON)" default>
        <JSONListBalanceHistoriesRequest />
    </TabItem>
    <TabItem value="response" label="Response (JSON)">
        <JSONListBalanceHistoriesResponse />
    </TabItem>
</Tabs>

### cdp_listAddressTransactions

This endpoint lists the transactions for an address. `cdp_listTransactions` is also a valid method name for this method.

#### Parameters

| Name      | Type   | Req | Description                                                                                                                                               |
| :-------- | :----- | :-: | :-------------------------------------------------------------------------------------------------------------------------------------------------------- |
| address   | string |  Y  | Blockchain address hash (Note that EVM chain address hash should be lowered cased.)                                                                       |
| pageSize  | string |  N  | Number of balances to receive in a page. The default value is 25. The maximum value is 100, and values supplied over this will be coerced to the maximum. |
| pageToken | string |  N  | Provided from a previous response's nextPageToken                                                                                                         |

#### Returns

| Field       | Description                                                                                                                                                       |
| :---------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name        | A unique identifier for the transaction, which cannot be changed once created.In the format of `networks/{network}/indexers/{indexer}/transactions/{transaction}` |
| hash        | The transaction hash                                                                                                                                              |
| blockHash   | The hash of the block this transaction was included in.                                                                                                           |
| blockHeight | The height of the block this transaction was included in.                                                                                                         |
| status      | The status of the transaction                                                                                                                                     |
| content     | The transaction content in either ethereum or rosetta format.                                                                                                     |

#### Request/Response

<Tabs  groupId="programming-language">
    <TabItem value="request" label="Request (JSON)" default>
        <JSONListAddressTransactionsRequest />  
    </TabItem>
    <TabItem value="response" label="Response (JSON)">
        <JSONListAddressTransactionsResponse />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/overview.mdx -->

---
title: Wallet History
sidebar_label: Overview
slug: overview
---

The Wallet History API provides indexed on-chain data across multiple blockchain networks, offering comprehensive information on asset transactions and balance histories. Key features include: 

- Multi-chain support
- Asset transaction history
- Balance history tracking
- Indexed data for efficient queries

There are various ways to query wallet history data, including:

- [JSON-RPC](./json-rpc.mdx)
- [CDP API](/cdp-sdk/reference) e.g. [ListBalanceHistories](/cdp-sdk/reference/listaddresshistoricalbalance)
- [CDP SDK](/cdp-sdk/docs/welcome) e.g. [NodeJS address.listHistoricalBalance](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address.Address.html#listHistoricalBalances)

Here are some [quickstart examples](https://github.com/coinbase/coinbase-sdk-nodejs/tree/master/quickstart-template) 
for using the Wallet History API.



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balances_req.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "cdp_listBalances",
  "params": [
    {
      "address": "0x0e73fc61bb9d6b7588910c2d14e83bae68222c5d",
      "pageToken": "",
      "pageSize": 2
    }
  ]
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balances_resp.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "balances": [
      {
        "asset": {
          "id": "08122fa4-510f-5ae4-9675-792c378b0018",
          "type": "erc20",
          "groupId": "0x6BE5830023b84f1C9B5BABB0Ca2B2a9DC5b9eD79",
          "subGroupId": ""
        },
        "value": 52333187000000000000000000,
        "valueStr": "52333187000000000000000000",
        "decimals": 18
      },
      {
        "asset": {
          "id": "1ddd4cf2-18ca-5c11-a7d5-d293330b19c7",
          "type": "erc20",
          "groupId": "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA",
          "subGroupId": ""
        },
        "value": 1173345,
        "valueStr": "1173345",
        "decimals": 6
      }
    ],
    "nextPageToken": "Y2ZfUXRhTUpYeTZGZ......M2I3LTY5MmJiMmM1ZTEzNCJ9"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balance_details_req.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "cdp_listBalanceDetails",
  "params": [
    {
      "address": "0x0e73fc61bb9d6b7588910c2d14e83bae68222c5d",
      "assetId": "08122fa4-510f-5ae4-9675-792c378b0018",
      "pageToken": "",
      "pageSize": 1
    }
  ]
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_address_transactions_resp.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "addressTransactions": [
      {
        "name": "networks/polygon-mainnet/indexers/default/transactions/0x8e9a4e099a8453e71b31b6c2c23b25926aadedf096bfb39071f1c84be0a8a06b",
        "hash": "0x8e9a4e099...9071f1c84be0a8a06b",
        "blockHash": "0xa6a7435ad5cc...13405fd38f5d85f",
        "blockHeight": "56393424",
        "status": "CONFIRMED",
        "ethereum": {
          "blockHash": "0xa6a7435ad5cc...13405fd38f5d85f",
          "blockNumber": "56393424",
          "from": "0xa83bd46d2757800bc8314a2cc14714c4afe272b5",
          "gas": "105257",
          "gasPrice": "125953591812",
          "hash": "0x8e9a4e099a8...1f1c84be0a8a06b",
          "input": "0xef6c59...000000000",
          "nonce": "119022",
          "to": "0xf6d1b85af155229acd7b523601148585a1ff67c6",
          "index": "8",
          "value": "0",
          "receipt": {
            "transactionHash": "0x8e9a4e09...f1c84be0a8a06b",
            "transactionIndex": "8",
            "blockHash": "0xa6a7435ad5c...9713405fd38f5d85f",
            "blockNumber": "56393424",
            "from": "0xa83bd46d2757800bc8314a2cc14714c4afe272b5",
            "to": "0xf6d1b85af155229acd7b523601148585a1ff67c6",
            "cumulativeGasUsed": "893833",
            "gasUsed": "105257",
            "contractAddress": "",
            "logs": [
              {
                "removed": false,
                "logIndex": "27",
                "transactionHash": "0x8e9a4e09...c84be0a8a06b",
                "transactionIndex": "8",
                "blockHash": "0xa6a743...3405fd38f5d85f",
                "blockNumber": "56393424",
                "address": "0x5d666f2...7ecd2c8cc44e6",
                "data": "0x",
                "topics": [
                  "0xddf252ad1be2c...4a11628f55a4df523b3ef",
                  "0x00000000000000...00000000000000",
                  "0x0000000000...2d14e83bae68222c5d",
                  "0x00000000000...0000000000020c669e"
                ]
              }
            ],
            "logsBloom": "0x0000000000...00000100000",
            "root": "",
            "status": "1",
            "type": "0",
            "effectiveGasPrice": "125953591812"
          },
          "tokenTransfers": [
            {
              "tokenAddress": "0x5d666f...ecd2c8cc44e6",
              "fromAddress": "0x000000000...00000000",
              "toAddress": "0x0e73fc6...bae68222c5d",
              "value": "",
              "transactionIndex": "8",
              "transactionHash": "0x8e9a4e0..e0a8a06b",
              "logIndex": "27",
              "blockHash": "0xa6a7435ad5..9713405fd38f5d85f",
              "blockNumber": "56393424",
              "erc721": {
                "fromAddress": "0x000000000..0000",
                "toAddress": "0x0e73fc61b..e68222c5d",
                "tokenId": "34367134"
              }
            }
          ],
          "type": "0",
          "priorityFeePerGas": "82907832252",
          "flattenedTraces": [
            {
              "error": "",
              "type": "CALL",
              "from": "0xa83bd46d2...fe272b5",
              "to": "0xf6d1b85af155229acd7b523601148585a1ff67c6",
              "value": "0",
              "gas": "105257",
              "gasUsed": "105257",
              "input": "0xef6c599600...000000000000",
              "output": "",
              "subtraces": "2",
              "traceAddress": [],
              "traceType": "CALL",
              "callType": "CALL",
              "traceId": "CALL_0x8e9a4e099a...1c84be0a8a06b",
              "status": "1",
              "blockHash": "0xa6a7435ad5...713405fd38f5d85f",
              "blockNumber": "56393424",
              "transactionHash": "0x8e9a4e099a...f1c84be0a8a06b",
              "transactionIndex": "8"
            }
          ],
          "blockTimestamp": "2024-04-29T18:08:30Z"
        }
      }
    ],
    "nextPageToken": "RlZ6VFBwc2lDSVd...IzEiLCJpZHgiOjB9"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balance_histories_req.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "cdp_listBalanceHistories",
  "params": [
    {
      "address": "0x0e73fc61bb9d6b7588910c2d14e83bae68222c5d",
      "assetId": "123d82ca-b3f4-527c-ace7-559d5791a564",
      "pageToken": "",
      "pageSize": 2
    }
  ]
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_address_transactions_req.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "cdp_listAddressTransactions",
  "params": [
    {
      "address": "0x0e73fc61bb9d6b7588910c2d14e83bae68222c5d",
      "pageToken": "",
      "pageSize": 2
    }
  ]
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balance_histories_resp.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "balanceHistories": [
      {
        "blockHeight": 2767233,
        "blockHash": "0x980773f020fea...70ee1a2f349241df338",
        "value": 4999990000000000000000,
        "valueStr": "4999990000000000000000"
      }
    ],
    "nextPageToken": ""
  }
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/wallet-history/JSON/list_balance_details_resp.mdx -->

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "balances": [
      {
        "asset": {
          "id": "08122fa4-510f-5ae4-9675-792c378b0018",
          "type": "erc20",
          "groupId": "0x6BE5830023b84f1C9B5BABB0Ca2B2a9DC5b9eD79",
          "subGroupId": ""
        },
        "value": 52333187000000000000000000,
        "valueStr": "52333187000000000000000000",
        "decimals": 18
      }
    ],
    "nextPageToken": ""
  }
}
```



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/smart-contract-events/NodeJS/list_smart_contract_events.mdx -->

```typescript
import { Coinbase } from "@coinbase/coinbase-sdk";
const coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });
```

This will allow you to authenticate with the Platform APIs.

```typescript
// Below is an example of list smart contract events call
SmartContract.listEvents(
  "base-mainnet", // networkId
  "public", // protocolName
  "0x940181a94a35a4569e4529a3cdfb74e38fd98631", // contractAddress
  "AERO", // contractName
  "Transfer", // eventName
  18341291, // fromBlockHeight
  18341292 // toBlockHeight
).then(events => {
    console.log(`Smart Contract Events: `, events);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```


<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/smart-contract-events/overview.mdx -->

---
title: Smart Contract Events  
sidebar_label: Overview 
slug: overview  
---

The **Smart Contract Events Indexer** is a powerful tool designed to generate API for events parsed from smart contracts that you are interested in monitoring. 
It simplifies the retrieval of event data from specific smart contracts, 
making it easier to integrate blockchain data into your application.

Here are some [quickstart examples](https://github.com/coinbase/coinbase-sdk-nodejs/tree/master/quickstart-template) 
for using the Smart Contract Events API.

## Configuration Options

You can retrieve smart contract events using either:

- **[CDP API](/cdp-sdk/reference/listcontractevents)**: Offers direct access to event data via RESTful APIs.
- **[CDP SDK](/onchain-data/docs/smart-contract-events/cdp-sdk)**: Enables developers to interact programmatically with smart contracts through a specialized SDK.

Both methods support various blockchain [networks](/onchain-data/docs/networks) and allow seamless integration into your infrastructure. 

## Sample Smart Contract Event

The following is an example of a parsed smart contract event. This is typically returned when you query for events using the indexer.
```json
{
    "networkId": "base-mainnet",
    "protocolName": "public",
    "contractName": "AERO",
    "eventName": "Transfer",
    "sig": "Transfer(address,address,uint256)",
    "fourBytes": "0xddf252ad",
    "contractAddress": "0x940181a94a35a4569e4529a3cdfb74e38fd98631",
    "blockTime": "2024-06-25T06:53:35Z",
    "blockHeight": 16254534,
    "txHash": "0x3d4e1443d71ed1fabe05832b769fbdd317e498bd6532aabd6dae02997c53a4d5",
    "txIndex": 47,
    "eventIndex": 242,
    "data": "{\"value\": 1221397094922564891, \"from\": \"0xfb5d7540faf21a3a0db0da41fd2fe923f93c74ea\", \"to\": \"0x2223f9fe624f69da4d8256a7bcc9104fba7f8f75\"}"
}
```

#### Smart Contract Event Fields

| Field             | Description                                                                                                                                                                                                                       |
|-------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `networkId`       | Blockchain network for the smart contract, e.g., `base-mainnet`.                                                                                                                                                                  |
| `protocolName`    | Name of the blockchain protocol, e.g., `public`.                                                                                                                                                                                  |
| `contractName`    | Name of the smart contract, e.g., `AERO`.                                                                                                                                                                                         |
| `eventName`       | Type of event, e.g., token transfer.                                                                                                                                                                                              |  
| `sig`             | The event signature for the smart contract event.                                                                                                                                                                                 |
| `fourBytes`       | The first 4 bytes (8 hex characters) of the Keccak-256 hash of the event signature (also known as the event topic).                                                                                                               |               
| `contractAddress` | Address of the smart contract.                                                                                                                                                                                                    |
| `blockTime`       | Timestamp when the block was mined.                                                                                                                                                                                               |
| `blockHeight`     | Number of the block containing the transaction.                                                                                                                                                                                   |
| `txHash`          | Hash of the transaction that triggered the event.                                                                                                                                                                                 |
| `txIndex`         | Position of the transaction within the block.                                                                                                                                                                                     |
| `eventIndex`      | Position of the event log within the transaction.                                                                                                                                                                                 |
| `data`            | The event-specific data emitted during the event in JSON format, e.g., - `from`: Address of the sender in the token transfer. - `to`: Address of the recipient. - `value`: Amount of tokens transferred.                          |



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/smart-contract-events/smart-contracts.mdx -->

---
title: SupportedSmart Contracts  
sidebar_label: Smart Contracts 
slug: smart-contracts  
---

## Supported Smart Contracts

Below is a table of supported smart contracts. If you're interested in tracking additional contracts, 
please reach out to us on [Discord](https://discord.gg/zR8FKSsxxX) for assistance.

| **Contract Name**  | **Network**             | **Contract Address**                                | **Protocol Name**   |
|--------------------|-------------------------|-----------------------------------------------------|---------------------|
| **AERO**           | `base-mainnet`          | `0x940181a94a35a4569e4529a3cdfb74e38fd98631`        | public              |
| **USDC**           | `ethereum-mainnet`      | `0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48`        | public              |



<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/smart-contract-events/cdp-sdk.mdx -->

---
title: Smart Contract Event SDK
sidebar_label: CDP SDK
slug: cdp-sdk
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TypescriptListSmartContractEvents from './NodeJS/list_smart_contract_events.mdx';
import RubyListSmartContractEvents from './Ruby/list_smart_contract_events.mdx';

In this document, you will learn how to retrieve smart contract events using the CDP SDK.

You can also retrieve smart contract events via [CDP API](/cdp-sdk/reference/listcontractevents).

To learn more about smart contracts options, 
please follow this [document](/onchain-data/docs/smart-contract-events/overview).

## What You'll Learn

- How to retrieve smart contracts events

## Prerequisites

Before you get started, please follow this [guide](/cdp-sdk/docs/installation) to install CDP SDK.

## List Smart Contract Events

To start, [create a CDP API key](https://portal.cdp.coinbase.com/access/api).
Then, initialize the CDP SDK by passing your downloaded API key file,
and retrieve smart contracts events.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptListSmartContractEvents />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyListSmartContractEvents />
    </TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/smart-contract-events/Ruby/list_smart_contract_events.mdx -->

```ruby
require "coinbase"
api_key_name = "Copy your API key name here."
api_key_private_key = "Copy your API key's private key here."

Coinbase.configure do |config|
    config.api_key_name = api_key_name
    config.api_key_private_key = api_key_private_key
end

puts "Coinbase SDK has been successfully configured with CDP API key."
```
This will allow you to authenticate with the Platform APIs.

```ruby
# Create new clients
api_client = Coinbase::Client::ApiClient.new
api_client.default_headers["Authorization"] = "Bearer Copy your JWT token here "
ce_client = Coinbase::Client::ContractEventsApi.new(api_client)

# Retrieve the smart contract events with input parameter networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight
response = ce_client.list_contract_events("base-mainnet", "public", "0x940181a94a35a4569e4529a3cdfb74e38fd98631", "AERO", "Transfer", 18341291, 18341292)
puts response
```


<!-- File: /Users/tinahe/docs/projects/onchain-data/docs/networks.mdx -->

---
title: Networks
sidebar_label: Networks
slug: networks
---

A Network is a blockchain where onchain actions are executed.
For example, wallets, addresses, and assets are created on a specific network.

## Capabilities

The following table shows the capabilities of Data on different networks:

| Data                               |      Base-Mainnet      |      Base-Sepolia      |   Ethereum-Mainnet   |   Polygon-Mainnet   |   Bitcoin-Mainnet    |   Arbitrum-Mainnet   |   Optimism-Mainnet   |
|------------------------------------|:----------------------:|:----------------------:|:--------------------:|:-------------------:|:--------------------:|:--------------------:|:--------------------:|
| **Current Balances**               |   :white_check_mark:   |   :white_check_mark:   |  :white_check_mark:  |  :white_check_mark: |  :white_check_mark:  |  :white_check_mark:  |  :white_check_mark:  |
| **Balance Histories**              |   :white_check_mark:   |   :white_check_mark:   |  :white_check_mark:  |  :white_check_mark: |  :white_check_mark:  |  :white_check_mark:  |  :white_check_mark:  |
| **Transaction Histories**          |   :white_check_mark:   |   :white_check_mark:   |  :white_check_mark:  |  :white_check_mark: |  :white_check_mark:  |  :white_check_mark:  |  :white_check_mark:  |
| **Webhooks**                       |   :white_check_mark:   |   :white_check_mark:   |          :x:         |          :x:        |          :x:         |          :x:         |          :x:         |
| **Smart Contract Events**          |   :white_check_mark:   |          :x:           |  :white_check_mark:  |          :x:        |          :x:         |          :x:         |          :x:         |

## Network Labels

The following table shows the network label mappings across different platforms:

| Network               | JSON RPC Network Labels | CDP API Network Labels |
|-----------------------|-------------------------|------------------------|
| **Base Mainnet**      | base                    | base-mainnet           |
| **Base Sepolia**      | base-sepolia            | base-sepolia           |
| **Ethereum Mainnet**  | ethereum                | ethereum-mainnet       |
| **Polygon Mainnet**   | polygon                 | polygon-mainnet        |
| **Bitcoin Mainnet**   | bitcoin                 | bitcoin-mainnet        |
| **Arbitrum Mainnet**  | arbitrum                | arbitrum-mainnet       |
| **Optimism Mainnet**  | optimism                | optimism-mainnet       |

Note that in each of the CDP SDKs, network labels can be found in corresponding network identifiers.
E.g. [NodeJS](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_coinbase.Coinbase.html#networks), 
[Ruby](https://coinbase.github.io/coinbase-sdk-ruby/Coinbase/Client/NetworkIdentifier.html), 
and [Python](https://coinbase.github.io/cdp-sdk-python/cdp.client.models.html#cdp.client.models.network_identifier.NetworkIdentifier).

## Testnet vs Mainnet

Data supports both mainnets and testnets. 

- Testnets are for building and testing applications. Funds are not real, and you can get test currencies from a faucet. 
- Mainnet is where the funds, contracts and applications are real. 



<!-- File: /Users/tinahe/docs/projects/verifications/docs/use-cases.mdx -->

---
title: Verifications Use Cases
sidebar_label: Use Cases
slug: use-cases
---

Current use cases of Coinbase Verifications include:

- Optimism Superchain: gating faucet access to prevent sybil attacks.
- Perennial: enabling users to trade perpetuals with leverage securely & compliantly.
- Deform: ensuring quality responses within DeForm's products
- Talent Protocol: increasing Builder Scores on their Talent Passport.
- Volmex Finance: enabling users to access volatility indices for tradable products.
- Index Coop: getting access to exclusive markets and higher yield.

Potential use cases include:

- Enforcing regulation by gating access to geographical-restricted areas.
- Enabling exclusive benefits to Coinbase One members.
- Verifying a user's country to implement in customer risk models.
- Building anti-sybil tooling.



<!-- File: /Users/tinahe/docs/projects/verifications/docs/attestations.mdx -->

---
title: Verifications Attestations
sidebar_label: Attestations
slug: attestations
---

Attestations establish trust and credibility by enabling issuers to make claims, either onchain or offchain, about any quality about the recipient's wallet address. 


## EAS Attestations

Coinbase Verfications leverages the [Ethereum Attestation Service](https://attest.org/) (EAS), an open-source base layer for making attestations. Attestations are issued on Base using EAS with ENS domain [verifications.coinbase.eth](https://app.ens.domains/verifications.coinbase.eth). 

This technology, paired with a credible issuer, can transfer credibility to the recipient. Because the attestation can be stored onchain, anyone can gather the attestation data from EAS.


## Schemas

Schemas act as blueprints for attestations and define the structure and type of data for a specific type of attestation. They set the information requirements for the attestation to contain.

| Schema name          | Schema content           | Schema ID |
| -------------------- | ------------------------ | --------- |
| Account Verification | bool verifiedAccount     | `0xf8b05c79f090979bf4a80270aba232dff11a10d9ca55c4f88de95317970f0de9` | 
| Country Verification | string verifiedCountry   | `0x1801901fabd0e6189356b4fb52bb0ab855276d84f7ec140839fbd1f6801ca065` | 
| Coinbase One         | bool verifiedCoinbaseOne | `0x254bd1b63e0591fefa66818ca054c78627306f253f86be6023725a67ee6bf9f4` | 


## Flows

<figcaption><i>How EAS is integrated with Coinbase Verifications</i></figcaption>
<img src={require('../assets/images/coinbase-verification-flow.png').default} width="700" alt="" />

<figcaption><i>How any Coinbase Verification is created starting from the user</i></figcaption>
<img src={require('../assets/images/attestation-creation-flow.png').default} width="700" alt="" />

<figcaption><i>How developers get data for the attestations they are verifying</i></figcaption>
<img src={require('../assets/images/developer-data-flow.png').default} width="700" alt="" />



<!-- File: /Users/tinahe/docs/projects/verifications/docs/welcome.mdx -->

---
title: Welcome to Coinbase Verifications
sidebar_label: Welcome
slug: welcome
---

Coinbase Verifications is a set of [Coinbase-verified onchain attestations](https://github.com/coinbase/verifications) that enable access to apps and other onchain benefits. A verification serves as a link between a user's Coinbase account and wallet address, and proves a specific attribute about that account without revealing any private information. 

## Types

The user can claim three types of Coinbase verifications:

- Account: wallet address has a trade-eligible account with Coinbase. 
- Country: wallet address has the country of residence of this account. 
- Coinbase One: wallet address has a Coinbase account with a Coinbase One membership.


## Motivations

As part of a large custodial exchange we want to bridge the gap between custodial customers and their onchain identities without revealing their personally identifiable information (PII). 

As [Base](https://www.base.org/) grows, we want to give our developers the ability to tap into pools of users with specific qualities (i.e., a specific country, trade-eligible accounts, Coinbase One member) to produce novel applications. 

The purpose of the Coinbase Indexer is to help developers integrate verifications into their protocols or apps. Developers will be able to check specific attributes against wallets to gate exclusive benefits.

<figcaption><i>Sample Attestation</i></figcaption>
<img src={require('../assets/images/onchain-attestation.png').default} width="700" alt="" />



<!-- File: /Users/tinahe/docs/projects/verifications/docs/quickstart.mdx -->

---
title: "Verifications Quickstart"
sidebar_label: "Quickstart"
slug: "quickstart"
---

This Coinbase Verifications quickstart shows you how to get the metadata associated with a user's attestation. Our implementation creates a read-only smart contract, to the ensure the integrity of the onchain data.

With a user wallet address and schema ID (a verification type ID), the Coinbase Indexer returns a UID. Then, with the UID, developers can call the EAS SDK to return the metadata associated with the attestation. If there is no attestation created, the Coinbase Indexer returns null. 


## Prerequisites

- Node >= 14.0.0
- npm >= 6.0.0
- [CDP account](https://portal.cdp.coinbase.com/products/node)
- Base mainnet endpoint

> How to get a Base Mainnet Endpoint:

1. Log into [CDP > Node](https://portal.cdp.coinbase.com/products/node).
1. Set the dropdown for RPC Endpoint to Base Mainnet.
1. Copy and save your endpoint to use later.

:::info
We use Base mainnet because it is a read-only contract that does not require any gas. 
:::

<img src={require('../assets/images/rpc-endpoint.png').default} width="700" alt="" />


## Get Attestation Data

### Initialize your project

In your terminal: 

1. Create a directory called `attestation-tutorial`
1. Initialize a project using npm.
1. Download dependencies: `eas-sdk` and `ethers`.

```sh
mkdir attestation-tutorial & cd attestation-tutorial

npm install @ethereum-attestation-service/eas-sdk

npm install ethers
```

### Set up imported variables 

Create a file called `indexer.js` and add the following variables to import: 

```js
const { EAS } = require("@ethereum-attestation-service/eas-sdk");
const { ethers } = require('ethers');
```

### Load and import ABI

1. Import the [ABI file](#abi-file) for the Coinbase Indexer contract.
1. Move the file to the `attestation-tutorial` directory.
1. Import the ABI as a variable.

```js
const ABI = require('./attestation_ABI.js');
```

### Create contract instance

Connect to the Base RPC endpoint and create a contract instance:

1. Copy your endpoint and paste it as the input for the `ethers.JsonRpcProvider` function.
1. Input the Coinbase Indexer contract address: `0x2c7eE1E5f416dfF40054c27A62f7B357C4E8619C`.
1. Create the contract instance with `contract address`, `ABI`, and `provider` variables.


:::note
Coinbase Indexer contract address: [0x2c7eE1E5f416dfF40054c27A62f7B357C4E8619C](https://basescan.org/address/0x2c7eE1E5f416dfF40054c27A62f7B357C4E8619C)
:::

```js
//Set this to the Node RPC URL from Step 1.
const provider = new ethers.JsonRpcProvider("YOUR RPC URL");

const contractAddress = "0x2c7eE1E5f416dfF40054c27A62f7B357C4E8619C";

const indexerContract = new ethers.Contract(contractAddress, ABI, provider);
```

### Get attestation UID

1. Setup a function that inputs a `walletAddress` and `schemaID` to return the `attestationUID`. 

:::info 
If the attestation does not exist, it returns `null`.
:::

> Fetching Attestation UID

```js
async function getAttestationUID(walletAddress,schemaID) {
    try {
      const attestationUID = await indexerContract.getAttestationUid(walletAddress, schemaID);
      return attestationUID;
    } catch (error) {
      console.error("Error fetching Attestation UID:", error);
    }
  }
```

### Get attestation data

Setup a function that inputs a `uid` to return `attestation`:

1. Input the contract address into `EAS`.

> Fetching Metadata

```js
async function getAttestationData(uid){
  try{
    const EASContractAddress = "0x4200000000000000000000000000000000000021"
    const eas = new EAS(EASContractAddress);
    eas.connect(provider);
    const attestation = await eas.getAttestation(uid);
    return attestation
  } catch(error){
    console.error("Error fetching Metadata: ", error)
  }
}	
```

### Call Functions

1. Create your main function.
1. Call the `getAttesationUID` and `getAttestationData` functions and input a valid Wallet Address and Schema ID.
1. Try with the following:

```
Wallet Address: `0x115aBfDa6b101bDC813B90c2780952E89E185F54`
Schema ID: `0xf8b05c79f090979bf4a80270aba232dff11a10d9ca55c4f88de95317970f0de9
```

> Check out recently claimed wallet addresses, schema IDs, and attestation UIDs we have here:

```js

async function main() {
  // Add any Wallet Address or SchemaID you would like to try.
  const walletAddress = "0x115aBfDa6b101bDC813B90c2780952E89E185F54";
  const schemaID = "0xf8b05c79f090979bf4a80270aba232dff11a10d9ca55c4f88de95317970f0de9";
  try {
      const uid = await getAttestationUID(walletAddress, schemaID);
      console.log('UID:', uid);
      const metadata = await getAttestationData(uid);
      console.log('Metadata:', metadata);
  } catch (error) {
      console.error('Error:', error);
  }
}

main();
```

### Output

You should return the output below. The comments above each line item represent the corresponding variable. 

```js
UID: 0x9c2108e7683176078b834068c0a8e6539213a56c3c4ae029d999f69840149911

Metadata: Result(10) [
//uid  '0x9c2108e7683176078b834068c0a8e6539213a56c3c4ae029d999f69840149911',
// schemaID
'0xf8b05c79f090979bf4a80270aba232dff11a10d9ca55c4f88de95317970f0de9',
//time
  1721434067n,
//expirationTime
  0n,
//revocationTime
  0n,
//refUID
'0x0000000000000000000000000000000000000000000000000000000000000000',
//recipient
  '0x115aBfDa6b101bDC813B90c2780952E89E185F54',
//attester
  '0x357458739F90461b99789350868CD7CF330Dd7EE',
//revocable[?]
  true,
//data  
'0x0000000000000000000000000000000000000000000000000000000000000001'
]
```


## ABI File

You can copy the ABI file here, or download <a href="/downloads/verifications/coinbase-verifications-abi-code-snippet.json.tar.gz" download target="blank">coinbase-verifications-abi-code-snippet.json.tar.gz</a>

```sh title="command to untar"
tar -xvf coinbase-verifications-abi-code-snippet.json.tar.gz
```

<details>
<summary><b>Expand for the ABI File</b></summary>

```json
const ABI = [
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "expirationTime",
        "type": "uint256"
      }
    ],
    "name": "AttestationExpired",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "name": "AttestationInvariantViolation",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "AttestationMissingRecipient",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "AttestationNotFound",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "revocationTime",
        "type": "uint256"
      }
    ],
    "name": "AttestationRevoked",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "previousAdmin",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "newAdmin",
        "type": "address"
      }
    ],
    "name": "AdminChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "indexer",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "schema",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "AttestationIndexed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "beacon",
        "type": "address"
      }
    ],
    "name": "BeaconUpgraded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "version",
        "type": "uint8"
      }
    ],
    "name": "Initialized",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "previousAdminRole",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "newAdminRole",
        "type": "bytes32"
      }
    ],
    "name": "RoleAdminChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleGranted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleRevoked",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "implementation",
        "type": "address"
      }
    ],
    "name": "Upgraded",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DEFAULT_ADMIN_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "INDEXER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PAUSER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "UPGRADER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "schemaUid",
        "type": "bytes32"
      }
    ],
    "name": "getAttestationUid",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      }
    ],
    "name": "getRoleAdmin",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "grantRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "hasRole",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "index",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "defaultAdmin",
        "type": "address"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pause",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "paused",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "proxiableUUID",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "renounceRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "revokeRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes4",
        "name": "interfaceId",
        "type": "bytes4"
      }
    ],
    "name": "supportsInterface",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "unpause",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      }
    ],
    "name": "upgradeTo",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      },
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "upgradeToAndCall",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  }
];
module.exports = ABI;

const ABI = [
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "expirationTime",
        "type": "uint256"
      }
    ],
    "name": "AttestationExpired",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "name": "AttestationInvariantViolation",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "AttestationMissingRecipient",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "AttestationNotFound",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "revocationTime",
        "type": "uint256"
      }
    ],
    "name": "AttestationRevoked",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "previousAdmin",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "newAdmin",
        "type": "address"
      }
    ],
    "name": "AdminChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "indexer",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "schema",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "AttestationIndexed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "beacon",
        "type": "address"
      }
    ],
    "name": "BeaconUpgraded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "version",
        "type": "uint8"
      }
    ],
    "name": "Initialized",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Paused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "previousAdminRole",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "newAdminRole",
        "type": "bytes32"
      }
    ],
    "name": "RoleAdminChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleGranted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "RoleRevoked",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "Unpaused",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "implementation",
        "type": "address"
      }
    ],
    "name": "Upgraded",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DEFAULT_ADMIN_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "INDEXER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "PAUSER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "UPGRADER_ROLE",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "recipient",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "schemaUid",
        "type": "bytes32"
      }
    ],
    "name": "getAttestationUid",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      }
    ],
    "name": "getRoleAdmin",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "grantRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "hasRole",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "attestationUid",
        "type": "bytes32"
      }
    ],
    "name": "index",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "defaultAdmin",
        "type": "address"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "pause",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "paused",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "proxiableUUID",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "renounceRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "role",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "revokeRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes4",
        "name": "interfaceId",
        "type": "bytes4"
      }
    ],
    "name": "supportsInterface",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "unpause",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      }
    ],
    "name": "upgradeTo",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      },
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "upgradeToAndCall",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  }
];
module.exports = ABI;
```

</details>


<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/_snippet-create-api-key.mdx -->

1. Log in to [Coinbase Commerce](https://beta.commerce.coinbase.com).

2. From your avatar, click **Settings** and go to the **Security** tab.

3. Under **API keys**, click **New API key** to generate a new key.

4. Click **Copy to clipboard** and securely store your new API key.

   <figcaption><i>Click image to enlarge</i></figcaption><img src={require('../assets/images/commerce-new-api-key.png').default} width="700" alt="Create a Coinbase Commerce API key so that you can authenticate your account, for example, when integrating into a 3rd party app." />


<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/build-creating-api-key.mdx -->

---
title: "Creating a Commerce API Key"
sidebar_label: "Creating an API Key"
slug: "creating-api-key"
---

Most Commerce API requests must be authenticated with an API key. You can create an API key in your Settings page after creating a Coinbase Commerce account.

## Create an API Key

1. Log into [Coinbase Commerce](https://beta.commerce.coinbase.com/).
2. Go to [Settings > Security](https://beta.commerce.coinbase.com/settings/security).
3. Click **New API key**.

<img src={require('../assets/images/api-keys.png').default} width="500" alt="." />


## Authenticating

Authenticated API requests should be made with a `X-CC-Api-Key` header. Your secret API key should be passed as the value.

If authentication fails, a JSON object with an error message is returned with HTTP status `401`.

Example authenticated request:
```bash
curl https://api.commerce.coinbase.com/checkouts \
 -H "X-CC-Api-Key: <Your API Key>"
```

<br />

**See Also:** 

- [Accepting Crypto Payments](./build-accepting-crypto.md)
- [Crypto Payments](./intro-crypto-payments.md)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/_snippet-add-webhook.mdx -->

1. Log in to [Coinbase Commerce](https://beta.commerce.coinbase.com).

2. From your avatar, click **Settings** and go to the **Notifications** tab.

3. Under **Webhook subscriptions**, click **Add an endpoint**.

4. Paste your webhook URL and click **Save**.

5. Click **Show shared secret**, then **Copy to clipboard** and securely store your secret.

   <figcaption><i>Click image to enlarge</i></figcaption><img src={require('../assets/images/commerce-add-webhook.png').default} width="700" alt="Add the endpoint of a 3rd pary app in Coinbase Commerce to create a webhook." />


<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-3rd-parties.mdx -->

---
title: "Commerce API 3rd Party Integration Overview"
sidebar_label: "3rd Party Integrations"
slug: "integrate-3rd-parties"
---

The Commerce API supports the following 3rd party integrations: 

- [Classy](./integrate-classy.mdx)
- [FundraiseUp](./integrate-fundraiseup.mdx)
- [JumpSeller](./integrate-jumpseller.mdx)
- [Primer](./integrate-primer.mdx)
- [Shopify](./integrate-shopify.mdx)
- [WooCommerce](./integrate-woocommerce.mdx)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/getting-started.mdx -->

---
title: "Getting Started with Commerce"
sidebar_label: "Getting Started"
slug: "getting-started"
---

To get started with Coinbase Commerce APIs, create an account and API key at [Coinbase Commerce](https://beta.commerce.coinbase.com/).


## Step 1: Create a Commerce Account

1. Sign up for an account at [commerce.coinbase.com](https://beta.commerce.coinbase.com/).
2. Add an EVM compatible wallet address to receive crypto deposits.

:::tip
Don’t have a wallet? Learn [how to create one](https://help.coinbase.com/en/wallet/getting-started/create-a-coinbase-wallet).
:::

## Step 2: Create an API Key

1. Log into [Coinbase Commerce](https://beta.commerce.coinbase.com/) if not logged in.
2. Go to [Settings > Security](https://beta.commerce.coinbase.com/settings/security).
3. Click **New API key** and copy your key to the clipboard.

<img src={require('../assets/images/api-keys.png').default} width="500" alt="." />



{/* <br /><br />

**See Also:** 

- [Commerce Quickstart](./quickstart.mdx) */}




<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-shopify.mdx -->

---
title: "Integrating Commerce and Shopify"
sidebar_label: "Shopify"
slug: "integrate-shopify"
--- 

This page explains how to integrate Coinbase Commerce and [Shopify](https://www.shopify.com/), an e-commerce platform. Integrating Shopify with Commerce lets you accept cryptocurrency payments peer-to-peer.

:::caution
Currently, only [Coinbase enterprise accounts](https://accounts.coinbase.com/businesssignup) can accept payments on Shopify. 
:::


## Link to Coinbase Commerce

1. Log in to [Shopify](https://admin.shopify.com/login).
   
2. From your Shopify store, go to **Settings > Payments > Add Payment Method > Search by provider**.

3. Search for **Coinbase Commerce** and select the application to install.

4. Sign into your Commerce account to link it directly to your Shopify store.

5. Complete a test transaction to make sure the integration is working.

:::caution
Only Coinbase-managed merchants can integrate with Shopify. Self-managed merchants (who do not go through the institutional onboarding flow) cannot use Shopify. For assistance, please contact us on the [Coinbase Developer Platform Discord](https://discord.com/invite/cdp).
:::


<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-fundraiseup.mdx -->

---
title: "Integrating Commerce and Fundraise Up"
sidebar_label: "Fundraise Up"
slug: "integrate-fundraiseup"
--- 

<!--- Import reusable content snippets --->
import CreateApiKeySnippet            from './_snippet-create-api-key.mdx';

This page explains how to integrate Coinbase Commerce and [Fundraise Up](https://fundraiseup.com/), a giving platform. Integrating Fundraise Up with Coinbase Commerce lets you accept cryptocurrency donations.


## Summary of Steps

1. (In Commerce) [Create](#1-create-commerce-api-key) an API key and copy/save your new API key.
2. (In Fundraise Up) [Add](#2-add-commerce-as-payment-method) Commerce as a payment method and paste the API key to authenticate.


## 1. Create Commerce API Key 

<CreateApiKeySnippet />


## 2. Add Commerce as Payment Method

1. Log in to [Fundraise Up](https://dashboard.fundraiseup.com/user/login).
   
2. Click your name and go to **Settings** > **Payment methods**.

3. Under **Payment processors**, select Coinbase Commerce.

4. Click **Connect Coinbase Commerce**.

5. Paste your Coinbase Commerce API credentials and click **Connect**.



<br /><br />

**See Also:** 

- [Accept cryptocurrency donations with Coinbase Commerce](https://fundraiseup.com/docs/coinbase-commerce/)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/quickstart.mdx -->

---
title: "Commerce Quickstart"
sidebar_label: "Quickstart"
slug: "quickstart"
---

This quickstart shows you how to call the Commerce API. 


## Step 1: Set up

Create an account and API key at [Getting Started](./getting-started.mdx).


## Step 2: Authenticate API Requests

Use the `X-CC-Api-Key` header to authenticate requests with your API key.

> Example:

```
curl https://api.commerce.coinbase.com/checkouts \
-H "X-CC-Api-Key: YOUR_API_KEY"
```

:::caution 401 errors
If authentication fails, a JSON object with an error message is returned with HTTP status `401`.
:::


## Step 3: Create a Charge

To start accepting payments, create a charge. You can navigate to the charge by pasting the `hosted_url` into your browser

> Example:

```
curl -X POST https://api.commerce.coinbase.com/charges/ \
-H "Content-Type: application/json" \
-H "X-CC-Api-Key: YOUR_API_KEY" \
-d '{
      "name": "The Human Fund",
      "description": "Money For People",
      "pricing_type": "fixed_price",
      "local_price": {
        "amount": "1.00",
        "currency": "USD"
      }
    }'
```


## Step 4: Retrieve a Charge

Retrieve the charge to get payment information. The `id` field in the response is the `CHARGE_UUID`.


> Example:

```
curl https://api.commerce.coinbase.com/charges/<CHARGE_UUID> \
-H "X-CC-Api-Key: YOUR_API_KEY"
```


## Step 5: Add a 'Pay with Crypto' Button

You can add a payment button to your website using a payment link or programmatically. See [Adding a 'Pay with Crypto' Payment Button](./build-adding-button.md).


## Step 6: Set Up Webhooks

Subscribe to webhooks for real-time updates on charges. Learn more about webhooks at [Commerce API Webhooks Overview](./api-webhooks.md).


## Conclusion

You are now ready to accept cryptocurrency payments with Coinbase Commerce. 

For more detailed information, refer to our [API reference](/commerce-onchain/reference) and the rest of the Coinbase Commerce API documentation.


<br />

**See Also:** 

- [Create a charge](./build-accepting-crypto.md)
- [Using Webhooks](./api-webhooks.md)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-primer.mdx -->

---
title: "Integrating Commerce and Primer"
sidebar_label: "Primer"
slug: "integrate-primer"
--- 

<!--- Import reusable content snippets --->
import AddWebhookSnippet              from './_snippet-add-webhook.mdx';
import CreateApiKeySnippet            from './_snippet-create-api-key.mdx';

This page explains how to integrate Coinbase Commerce and [Primer](https://primer.io/), a no-code payments solution. Integrating Primer with Commerce lets you accept cryptocurrency payments.


## Create Commerce API Key 

<CreateApiKeySnippet />


## Add Coinbase Payment Method

1. Log in to your [Primer Dashboard](https://dashboard.primer.io/login) and go to **Connections**.
   
2. Select the **Discover** tab.

3. Search for and select "Coinbase Commerce", then click **Connect**. 

4. Paste the Commerce API key into the API Key field.


## Add Webhook Subscription

<AddWebhookSnippet />


## Activate Coinbase on Checkout

1. Return to your Primer Dashboard and go to **Checkout**.

2. Activate the Coinbase payment method.


## Add Workflow to Process Payments

A workflow ensures that your Coinbase processor is used to process payments made with Coinbase.

1. Log in to your Primer Dashboard and go to **Workflows**.
2. Click **Payment**, then click **Edit**.
3. From the **Method** dropdown (top), select "Coinbase".
4. Create a Workflow for Coinbase:

   a. Create Condition.
   
   b. Click the **plus (+)** symbol on Condition and select **Next Step**.

   c. Select "Coinbase Commerce".

   d. Click **Publish**.

5. Go to **Checkout** in the lefthand navigation bar.

6. Under Payment Methods, enable "Coinbase" on your Universal Checkout.

7. Add conditions so Coinbase Commerce is shown on Universal Checkout.

8. Click the icon to the right of the toggle and add your conditions based on currency and/or amount, country or metadata.

9. Publish your checkout.




<br /><br />

**See Also:** 

- [Add Coinbase Commerce to your Primer Dashboard.](https://www.coinbase.com/commerce/integrations/primer)
- [Coinbase Direct Integration](https://primer.io/docs/payment-methods/coinbase/direct-integration)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-jumpseller.mdx -->

---
title: "Integrating Commerce and JumpSeller"
sidebar_label: "JumpSeller"
slug: "integrate-jumpseller"
--- 

<!--- Import reusable content snippets --->
import AddWebhookSnippet              from './_snippet-add-webhook.mdx';
import CreateApiKeySnippet            from './_snippet-create-api-key.mdx';

This page explains how to integrate Coinbase Commerce and [JumpSeller](https://jumpseller.com/), an e-commerce platform. Integrating JumpSeller with Commerce lets you accept cryptocurrency payments peer-to-peer.


## Summary of Steps

1. (In Commerce) [Create](#1-create-commerce-api-key)  an API key and copy/save your new API key. 
2. (In JumpSeller) [Add](#2-add-payment-method) Coinbase as a payment method and paste the key, then copy the JumpSeller webhook URL. 
3. (In Commerce) [Paste](#3-add-endpoint) the URL to add a webhook subscription and copy/save your webhook secret. 
4. (In JumpSeller) [Paste](#4-authenticate-commerce) the webhook secret to authenticate Commerce.


## Add Coinbase as Payment Method

### 1. Create Commerce API Key 

<CreateApiKeySnippet />

### 2. Add Payment Method

1. Log in to [JumpSeller](https://jumpseller.com/login/) and go to the admin panel of your store.
2. Go to **Checkout > Payments**, select "Coinbase", and click **Add Method**.
3. Paste the Coinbase Commerce API key you created above.
4. Copy the JumpSelleer URL that displays in bold, for example:
   
   ```
   https://{YOUR-STORE}.jumpseller.com/en/checkout/coinbase/ipn
   ```


## Add Webhook Subscription 

### 3. Add Endpoint

<AddWebhookSnippet />

### 4. Authenticate Commerce

1. Return to Jumpseller.
2. Paste the Commerce shared secret in **Secret key for events** and click **Save**.


<br /><br />

**See Also:**

- [Configure Coinbase Commerce for your online store](https://jumpseller.com/support/coinbase-commerce/)
- [External Payment Gateways](https://jumpseller.com/support/external-payment-gateways/#external-payment-notification)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-classy.mdx -->

---
title: "Integrating Commerce and Classy"
sidebar_label: "Classy"
slug: "integrate-classy"
--- 

<!--- Import reusable content snippets --->
import AddWebhookSnippet              from './_snippet-add-webhook.mdx';
import CreateApiKeySnippet            from './_snippet-create-api-key.mdx';

This page explains how to integrate Coinbase Commerce and [Classy](https://www.classy.org), a giving platform. Integrating Classy with Coinbase Commerce lets you accept cryptocurrency donations.

:::caution
Currently, only [Coinbase enterprise accounts](https://accounts.coinbase.com/businesssignup) can accept payments on Classy. 
:::

## Summary of Steps

1. (In Classy)   [Copy](#1-copy-classy-webhook-url) the webhook URL. 
2. (In Commerce) [Paste](#2-add-webhook-subscription) the URL to add a webhook subscription and copy/save your webhook secret. 
3. (In Commerce) [Create](#3-create-commerce-api-key) an API key and copy/save your new API key. 
4. (In Classy)   [Paste](#4-authenticate-commerce) the Commerce webhook secret and API key to authenticate Commerce.


## Add Classy Webhook Subscription

### 1. Copy Classy Webhook URL

1. Log in to [Classy](https://www.classy.org/sso) and go to **Settings > Payment Processor Portal**.
   
2. Under **Crypto Giving**, click **Select Exchange** and choose Coinbase.

3. Click **Copy URL** (and leave the browser window open).

### 2. Add Webhook Subscription

<AddWebhookSnippet />


## Integrate Classy and Commerce

### 3. Create Commerce API Key 

<CreateApiKeySnippet />

### 4. Authenticate Commerce

1. Return to the Payment Processor Portal in Classy.
   
2. Paste your Coinbase Commerce API key and webhook secret.

3. Check the agreement box and click **Connect**.


<br /><br />

**See Also:** 

- [Set Up Crypto Donations](https://support.classy.org/s/article/set-up-crypto)



<!-- File: /Users/tinahe/docs/projects/commerce-onchain/docs/integrate-woocommerce.mdx -->

---
title: "Integrating Commerce and WooCommerce"
sidebar_label: "WooCommerce"
slug: "integrate-woocommerce"
--- 

<!--- Import reusable content snippets --->
import AddWebhookSnippet              from './_snippet-add-webhook.mdx';
import CreateApiKeySnippet            from './_snippet-create-api-key.mdx';

This page explains how to integrate Coinbase Commerce and [WooCommerce](https://woo.com/), a WordPress-based ecommerce platform. Integrating Woocommerce with Coinbase Commerce lets you accept cryptocurrency peer-to-peer.


## Summary of Steps

This page assumes that you have a Coinbase Commerce account and a paid WooCommerce account with a store configured to receive payments.


1. (In Commerce) [Create](#create-commerce-api-key) an API key and copy/save your new API key. 
2. (In Woo) [Install](#install-coinbase-commerce-plugin) the Coinbase Commerce plugin (the one authored by Coinbase).
3. (In Woo) [Add pay method, part 1](#add-coinbase-payment-method-pt-1): Paste Coinbase API key and copy WooCommerce webhook URL.
4. (In Commerce) [Paste](#add-webhook-subscription) the Woo webhook URL and copy/save your webhook secret.
5. (In Woo) [Add pay method, part 2](#add-coinbase-payment-method-pt-2): Paste Coinbase Commerce webhook secret.


## Create Commerce API Key

This section assumes that you have a [Coinbase Commerce account](https://commerce.coinbase.com/signup).

<CreateApiKeySnippet />


## Install Coinbase Commerce Plugin

:::info
To add a new plugin, you must have a paid WooCommerce plan.
:::

1. Log in to your [WooCommerce WordPress](https://woo.com/signin-with-wordpress/) account.
2. From your storefront dashboard, select **Plugins > Add New Plugin**.
3. Search for **Coinbase** and select the [Coinbase Commerce plugin](https://woocommerce.com/products/coinbase-commerce/).
4. Click **Install and Activate**.

   <figcaption><i>Click image to enlarge</i></figcaption><img src={require('../assets/images/woocommerce-coinbase-plugin.png').default} width="700" alt="" />


## Add Coinbase Payment Method, Pt 1

:::info
To add Coinbase Commerce as a payment gateway, you must be configured for live payments (not just sandbox).
:::

1. From your storefront dashboard, select **Payments**.
3. Find "Coinbase" in the list of available payment gateways.
4. Click on the **Manage** button on the right hand side.

   <figcaption><i>Click image to enlarge</i></figcaption><img src={require('../assets/images/woocommerce-02-manage.png').default} width="500" alt="Coinbase in the list of available payment gateways." />

   This takes you to the settings page, where you can configure the plugin for your store. 

   <figcaption><i>Click image to enlarge</i></figcaption><img src={require('../assets/images/woocommerce-03-settings.png').default}  width="500" alt="Plugin settings dialog." />

5. Paste the Coinbase Commerce API key into the **API Key** field.
6. Copy the URL in step 2 under the **Webhook Shared Secret** field.
7. Leave the dialog open so you can paste the webhook secret later.


## Add Webhook Subscription

<AddWebhookSnippet />


## Add Coinbase Payment Method, Pt 2

1. Return to the WooCommerce **Payments** management dialog.
2. Paste your Coinbase Commerce webhook secret into the **Webhook Shared Secret** field.

Your customers are now able to checkout and pay with crypto using Coinbase Commerce.


<br /><br />

**See Also:** 

- [Coinbase Commerce: Accept crypto payments on your WooCommerce store](https://woo.com/document/coinbase-commerce/)



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/_snippet-cdp-auth-making-requests.mdx -->

CDP API keys are used to generate a JSON Web Token (JWT) for an API. Once you've generated a JWT, set it as a Authorization Bearer header to make an authenticated request.

```
# Example request to get account
curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9'
```



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/_snippet-cdp-auth-creating-keys.mdx -->

1. Navigate to your [API settings](https://coinbase.com/settings/api).
1. Click the **Create API key** button.
1. In the popup dialog configure:
    - API key nickname
    - Portfolio
    - Permissions (editing this value prompts 2FA)
    - IP allowlist
1. Click **Create & Download**.
1. Copy and secure your private/public key pair in a safe location.
1. Click **I've saved my key**.

:::tip
To regenerate an API key, click **Manage** to delete and recreate the key.
:::

<figcaption><i>Click to enlarge</i></figcaption> <img src={require('../assets/images/create-retail-api-key.png').default} width="800" alt="Image of API Key Management" />



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/ws-channels.mdx -->

---
title: "Advanced Trade WebSocket Channels"
sidebar_label: "Channels"
slug: "ws-channels"
---

import Badge from '@components/Badge';

:::caution Use heartbeats to keep all subscriptions open
Most channels close within 60-90 seconds if no updates are sent. Subscribe to [heartbeats](#heartbeats-channel) to keep all subscriptions open.
:::

The Coinbase Advanced Trade Market Data WebSocket feed provides the following channels:

| Channel                                                     | Description                                                   | Requires Authentication |
|:------------------------------------------------------------|:--------------------------------------------------------------|:------------------------|
| **[heartbeats](#heartbeats-channel)**                       | **Real-time server pings to keep all connections open**       | No                      |
| [candles](#candles-channel)                                 | Real-time updates on product candles                          | No                      |
| [status](#status-channel)                                   | Sends all products and currencies on a preset interval        | No                      |
| [ticker](#ticker-channel)                                   | Real-time price updates every time a match happens            | No                      |
| [ticker_batch](#ticker-batch-channel)                       | Real-time price updates every 5000 milli-seconds              | No                      |
| [level2](#level2-channel)                                   | All updates and easiest way to keep order book snapshot       | No                      |
| [user](#user-channel)                                       | Only sends messages that include the authenticated user       | <i>Yes</i>              |
| [market_trades](#market-trades-channel)                     | Real-time updates every time a market trade happens           | No                      |
| [futures_balance_summary](#futures-balance-summary-channel) | Real-time updates every time a user's futures balance changes | <i>Yes</i>              |

Refer to the documentation on [subscribing to a WebSocket channel](./ws-overview.mdx#subscribing).

:::tip
For the most reliable connection, authenticate with a CDP API key when subscribing to any channel.
:::

:::info
Subscribing to "-USDC" based products are only available on the user channel. Other channels will return the same data as the corresponding "-USD" based products. USDT-USDC and EURC-USDC are available on all channels.
:::

## Heartbeats Channel

Subscribe to the `heartbeats` channel to receive heartbeats messages every second. Heartbeats include a `heartbeat_counter` which verifies that no messages were missed.

:::tip
Subscribing to the heartbeats channel, alongside other channels, ensures that all subscriptions stay open when updates are sparse. This is useful, for example, when fetching market data for illiquid pairs.
:::

```json
// Request
{
  "type": "subscribe",
  "channel": "heartbeats",
  "jwt": "XYZ"
}
```

A heartbeats message is of the type `heartbeats` as seen below.

```json
// Heartbeats Message
{
  "channel": "heartbeats",
  "client_id": "",
  "timestamp": "2023-06-23T20:31:26.122969572Z",
  "sequence_num": 0,
  "events": [
    {
      "current_time": "2023-06-23 20:31:56.121961769 +0000 UTC m=+91717.525857105",
      "heartbeat_counter": "3049"
    }
  ]
}
```

## Candles Channel

Subscribe to the `candles` channel to receive candles messages for specific products with updates every second. Candles are grouped into buckets (granularities) of five minutes.

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD"],
  "channel": "candles",
  "jwt": "XYZ"
}
```

A candles message is of the type `candles` and some of its parameters include:

- `start` - string representation of the UNIX timestamp of the candle.
- `high` and `low` - highest and lowest prices during the bucket interval.
- `open` and `close` - prices of the first and last trade respectively.
- `volume` - base amount that has been traded during this interval.
- `product_id` - product identifier for this candle

```json
// Candles Message
{
  "channel": "candles",
  "client_id": "",
  "timestamp": "2023-06-09T20:19:35.39625135Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "candles": [
        {
          "start": "1688998200",
          "high": "1867.72",
          "low": "1865.63",
          "open": "1867.38",
          "close": "1866.81",
          "volume": "0.20269406",
          "product_id": "ETH-USD"
        }
      ]
    }
  ]
}
```

## Market Trades Channel

The `market_trades` channel sends market trades for a specified product on a preset interval. Clients should provide an array of `product_ids` for which they would like status subscriptions.

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "market_trades",
  "jwt": "XYZ"
}
```

A market trades message is of the type `snapshot` or `update`, and contains an array of market trades. Each market trade belongs to a `side`, which refers to the makers side, and can be of type `BUY`, or `SELL`. The channel collects all updates over the last 250 ms and sends them as an `update` -- so an `update` can contain one or many trades, depending on the last 250 ms of trading volume.

```json
// Market Trades Message
{
  "channel": "market_trades",
  "client_id": "",
  "timestamp": "2023-02-09T20:19:35.39625135Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "trades": [
        {
          "trade_id": "000000000",
          "product_id": "ETH-USD",
          "price": "1260.01",
          "size": "0.3",
          "side": "BUY",
          "time": "2019-08-14T20:42:27.265Z"
        }
      ]
    }
  ]
}
```

## Status Channel

The `status` channel sends all products and currencies on a preset interval. Clients should provide an array of `product_ids` for which they would like status subscriptions. They are automatically subscribed to all products if `product_ids` is not provided.

:::caution
The `status` channel, like most channels, closes within 60-90 seconds when there are no updates. For example, if you listen for `BTC-USD` updates and nothing changes within 60-90 seconds (which is common), the channel closes. To avoid this, subscribe to the [heartbeats](#heartbeats-channel) in addition to your other channels.
:::

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "status",
  "jwt": "XYZ"
}
```

```json
// Status Message
{
  "channel": "status",
  "client_id": "",
  "timestamp": "2023-02-09T20:29:49.753424311Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "products": [
        {
          "product_type": "SPOT",
          "id": "BTC-USD",
          "base_currency": "BTC",
          "quote_currency": "USD",
          "base_increment": "0.00000001",
          "quote_increment": "0.01",
          "display_name": "BTC/USD",
          "status": "online",
          "status_message": "",
          "min_market_funds": "1"
        }
      ]
    }
  ]
}
```

## Ticker Channel

The `ticker` channel provides real-time price updates every time a match happens. It batches updates in case of cascading matches, greatly reducing bandwidth requirements.

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "ticker",
  "jwt": "XYZ"
}
```

```json
// Ticker messsage
{
  "channel": "ticker",
  "client_id": "",
  "timestamp": "2023-02-09T20:30:37.167359596Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "tickers": [
        {
          "type": "ticker",
          "product_id": "BTC-USD",
          "price": "21932.98",
          "volume_24_h": "16038.28770938",
          "low_24_h": "21835.29",
          "high_24_h": "23011.18",
          "low_52_w": "15460",
          "high_52_w": "48240",
          "price_percent_chg_24_h": "-4.15775596190603",
          "best_bid": "21931.98",
          "best_bid_quantity": "8000.21",
          "best_ask": "21933.98",
          "best_ask_quantity": "8038.07770938"
        }
      ]
    }
  ]
}
```

## Ticker Batch Channel

The `ticker_batch` channel provides latest price updates **every 5000 milliseconds** (5 seconds) if there is a change. It has the same JSON message schema as the [`ticker` channel](#ticker-channel), except the `channel` field will have a value of `ticker_batch`.

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "ticker_batch",
  "jwt": "XYZ"
}
```

## Level2 Channel

The `level2` channel guarantees delivery of all updates and is the easiest way to keep a snapshot of the order book.

```json
// Request
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "BTC-USD"],
  "channel": "level2",
  "jwt": "XYZ"
}
```

:::tip
Subscribe to the `level2` channel to guarantee that messages are delivered and your order book is in sync.
:::

The level2 channel sends a message with fields, `type` ("snapshot" or "update"), `product_id`, and `updates`. The field `updates` is an array of objects of `{price_level, new_quantity, event_time, side}` to represent the entire order book. The`event_time` property is the time of the event as recorded by our trading engine.

:::info
The `new_quantity` property is the updated size at that price level, not a delta. A `new_quantity` of "0" indicates the price level can be removed.
:::

```json
// Example:
{
  "channel": "l2_data",
  "client_id": "",
  "timestamp": "2023-02-09T20:32:50.714964855Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "product_id": "BTC-USD",
      "updates": [
        {
          "side": "bid",
          "event_time": "1970-01-01T00:00:00Z",
          "price_level": "21921.73",
          "new_quantity": "0.06317902"
        },
        {
          "side": "bid",
          "event_time": "1970-01-01T00:00:00Z",
          "price_level": "21921.3",
          "new_quantity": "0.02"
        }
      ]
    }
  ]
}
```

## User Channel

<Badge color="0a639a" url="./ws-auth" label="User Channel:Authentication Required" />

The `user` channel sends updates on all of a user's open orders and current positions, including all subsequent updates of those orders and positions.

The `user` channel expects one connection per user:

- This connection accepts multiple product IDs in a `product_ids` array. If none are provided, the WebSocket subscription is open to all product IDs.
- To subscribe to new `product_ids`, close your previous connection by unsubscribing and open a new connection with `product_ids` added to the array.

:::tip
Subscribing to the User channel returns all `OPEN` orders, batched by 50, in the first few messages of the stream. For example, if you have 109 orders, you will get a snapshot containing 50 orders, followed by a patch of 50 orders, followed by a patch of 9 orders. To know when all of your open orders are returned, look for the first message with less than 50 orders.
:::

```json
// Request
{
  "type": "subscribe",
  "channel": "user",
  "product_ids": ["BTC-USD"],
  "jwt": "XYZ"
}
```

```json
// User message
{
  "channel": "user",
  "client_id": "",
  "timestamp": "2023-02-09T20:33:57.609931463Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "orders": [
        {
          "avg_price": "50000",
          "cancel_reason": "",
          "client_order_id": "XXX",
          "completion_percentage": "100.00",
          "contract_expiry_type": "UNKNOWN_CONTRACT_EXPIRY_TYPE",
          "cumulative_quantity": "0.01",
          "filled_value": "500",
          "leaves_quantity": "0",
          "limit_price": "50000",
          "number_of_fills": "1",
          "order_id": "YYY",
          "order_side": "BUY",
          "order_type": "Limit",
          "outstanding_hold_amount": "0",
          "post_only": "false",
          "product_id": "BTC-USD",
          "product_type": "SPOT",
          "reject_reason": "",
          "retail_portfolio_id": "ZZZ",
          "risk_managed_by": "UNKNOWN_RISK_MANAGEMENT_TYPE",
          "status": "FILLED",
          "stop_price": "",
          "time_in_force": "GOOD_UNTIL_CANCELLED",
          "total_fees": "2",
          "total_value_after_fees": "502",
          "trigger_status": "INVALID_ORDER_TYPE",
          "creation_time": "2024-06-21T18:29:13.909347Z",
          "end_time": "0001-01-01T00:00:00Z",
          "start_time": "0001-01-01T00:00:00Z"
        }
      ],
      "positions": {
        "perpetual_futures_positions": [
          {
            "product_id": "BTC-PERP-INTX",
            "portfolio_uuid": "018c4b12-9f87-7c36-897d-28fb6a1ea88d",
            "vwap": "63049.9",
            "entry_vwap": "0",
            "position_side": "Long",
            "margin_type": "Cross",
            "net_size": "0.0041",
            "buy_order_size": "0",
            "sell_order_size": "0",
            "leverage": "1",
            "mark_price": "63049.9",
            "liquidation_price": "0",
            "im_notional": "258.5046",
            "mm_notional": "17.061304",
            "position_notional": "258.5046",
            "unrealized_pnl": "0",
            "aggregated_pnl": "258.50459"
          }
        ],
        "expiring_futures_positions": [
          {
            "product_id": "BIT-28JUN24-CDE",
            "side": "Long",
            "number_of_contracts": "1",
            "realized_pnl": "0",
            "unrealized_pnl": "-21.199999999999932",
            "entry_price": "64150"
          }
        ]
      }
    }
  ]
}
```

#### Orders Fields

| Field                     | Description                                                                                                                                                                                                                                                                                                                                    |
|:--------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `avg_price`               | Average filled price of the order so far                                                                                                                                                                                                                                                                                                       |
| `cancel_reason`           | Reason for order cancellation                                                                                                                                                                                                                                                                                                                  |
| `client_order_id`         | Unique identifier of order specified by client                                                                                                                                                                                                                                                                                                 |
| `completion_percentage`   | Percentage of order completion                                                                                                                                                                                                                                                                                                                 |
| `contract_expiry_type`    | Can be one of: <ul> <li>`UNKNOWN_CONTRACT_EXPIRY`</li> <li>`EXPIRING`</li> <li>`PERPETUAL`</li></ul>                                                                                                                                                                                                                                           |
| `cumulative_quantity`     | Amount the order is filled, in base currency                                                                                                                                                                                                                                                                                                   |
| `filled_value`            | Value of the filled order                                                                                                                                                                                                                                                                                                                      |
| `leaves_quantity`         | Amount remaining, in same currency as order was placed in (quote or base)                                                                                                                                                                                                                                                                      |
| `limit_price`             | Can be one of: <ul> <li>`Limit Price`: Order is Limit or Stop Limit type</li> <li>`0`: Order is not Limit or Stop Limit type</li></ul>                                                                                                                                                                                                         |
| `number_of_fills`         | Number of fills for the order                                                                                                                                                                                                                                                                                                                  |
| `order_id`                | Unique identifier of order                                                                                                                                                                                                                                                                                                                     |
| `order_side`              | Can be one of: <ul> <li>`BUY`</li> <li>`SELL`</li> </ul>                                                                                                                                                                                                                                                                                       |
| `order_type`              | Can be one of: <ul> <li>`LIMIT_ORDER_TYPE`</li> <li>`MARKET_ORDER_TYPE`</li> <li>`STOP_LIMIT_ORDER_TYPE`</li> </ul>                                                                                                                                                                                                                            |
| `outstanding_hold_amount` | Outstanding hold amount for the order                                                                                                                                                                                                                                                                                                          |
| `post_only`               | Can be one of: <ul> <li>`true`</li> <li>`false`</li> </ul>                                                                                                                                                                                                                                                                                     |
| `product_id`              | The product ID for which this order was placed                                                                                                                                                                                                                                                                                                 |
| `product_type`            | Can be one of: <ul> <li>`UNKNOWN_PRODUCT_TYPE`</li> <li>`SPOT`</li> <li>`FUTURE`</li> </ul>                                                                                                                                                                                                                                                    |
| `reject_reason`           | Reason for order rejection                                                                                                                                                                                                                                                                                                                     |
| `retail_portfolio_id`     | The ID of the portfolio this order is associated with.                                                                                                                                                                                                                                                                                         |
| `risk_managed_by`         | Can be one of: <ul> <li>`UNKNOWN_RISK_MANAGEMENT_TYPE`</li> <li>`MANAGED_BY_FCM`</li> <li>`MANAGED_BY_VENUE`</li></ul>                                                                                                                                                                                                                         |
| `status`                  | Can be one of: <ul> <li>`PENDING`: Order is not yet open</li> <li>`OPEN`: Order is waiting to be fully filled</li> <li>`FILLED`: Order is 100% filled</li> <li>`CANCELLED`: Order was cancelled by user or system</li> <li>`EXPIRED`: TWAP order was not filled by the expiry time</li> <li>`FAILED`: Order cannot be placed at all</li> </ul> |
| `stop_price`              | Can be one of: <ul> <li>`Stop Price`: Order is Stop Limit type</li> <li>`0`: Order is not Stop Limit type</li></ul>                                                                                                                                                                                                                            |
| `time_in_force`           | Can be one of: <ul> <li>`UNKNOWN_TIME_IN_FORCE`</li> <li>`GOOD_UNTIL_DATE_TIME`</li> <li>`GOOD_UNTIL_CANCELLED`</li> <li>`IMMEDIATE_OR_CANCEL`</li> <li>`FILL_OR_KILL`</li> </ul>                                                                                                                                                              |
| `total_fees`              | Commission paid for the order                                                                                                                                                                                                                                                                                                                  |
| `total_value_after_fees`  | Total value of the order after fees                                                                                                                                                                                                                                                                                                            |
| `trigger_status`          | Can be one of: <ul> <li>`UNKNOWN_TRIGGER_STATUS`</li> <li>`INVALID_ORDER_TYPE`</li> <li>`STOP_PENDING`</li> <li>`STOP_TRIGGERED`</li> </ul>                                                                                                                                                                                                    |
| `creation_time`           | When the order was placed                                                                                                                                                                                                                                                                                                                      |
| `end_time`                | <ul> <li>`End Time`: Order has end time </li> <li>`0001-01-01T00:00:00Z`: End Time not applicable</li></ul>                                                                                                                                                                                                                                    |
| `start_time`              | <ul> <li>`Start Time`: Order has start time </li> <li>`0001-01-01T00:00:00Z`: Start Time not applicable</li></ul>                                                                                                                                                                                                                              |

#### Positions Fields

Numeric values are in units of USDC.

##### Perpetual Futures

| Field               | Description                                                                                                                                                                |
|:--------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `product_id`        | Name of the instrument the position is in, e.g. `BTC-PERP-INTX`                                                                                                            |
| `portfolio_uuid`    | The uuid of the portfolio this order is associated with                                                                                                                    |
| `vwap`              | The price of the position based on the last settlement period                                                                                                              |
| `entry_vwap`        | Volume weighted entry price of the position (not reset to the last funding price)                                                                                          |
| `position_side`     | The side of the position. Can be one of: <ul> <li>`Long`</li> <li>`Short`</li></ul>                                                                                        |
| `margin_type`       | The margin type of the position. Can be one of: <ul> <li>`Cross`: Indicating a cross margin position</li> <li>`Isolated`: Indicating an isolated margin position</li></ul> |
| `net_size`          | The size of the position with positive values reflecting a long position and negative values reflecting a short position                                                   |
| `buy_order_size`    | Cumulative size of all the open buy orders                                                                                                                                 |
| `sell_order_size`   | Cumulative size of all the open sell orders                                                                                                                                |
| `leverage`          | The leverage of the position                                                                                                                                               |
| `mark_price`        | The current mark price value for the instrument of this position used in risk and margin calculations                                                                      |
| `liquidation_price` | Price at which the position will be liquidated at                                                                                                                          |
| `im_notional`       | The amount this position contributes to the initial margin                                                                                                                 |
| `mm_notional`       | The amount this position contributes to the maintenance margin                                                                                                             |
| `position_notional` | The notional value of the position                                                                                                                                         |
| `unrealized_pnl`    | The profit or loss of this position (resets to 0 after settlement)                                                                                                         |
| `aggregated_pnl`    | The total profit or loss of this position since the initial opening of the position                                                                                        |

#### Expiring Futures

| Field                   | Description                                                                         |
|:------------------------|:------------------------------------------------------------------------------------|
| `product_id`            | Name of the instrument the position is in, e.g. `BTC-12Jun24-CDE`                   |
| `side`                  | The side of the position. Can be one of: <ul> <li>`Long`</li> <li>`Short`</li></ul> |
| `number_of_contracts`   | The size of your position in contracts                                              |
| `realized_pnl`          | Your realized PnL for your position                                                 |
| `unrealized_pnl`        | Your current unrealized PnL for your position                                       |
| `entry_price`           | The average entry price at which you entered your current position                  |

## Futures Balance Summary Channel

<Badge color="0a639a" url="./ws-auth" label="Futures Balance Summary Channel:Authentication Required" />

The `futures_balance_summary` channel sends updates on all of a user's futures balances, including all subsequent updates of those balances.


```json
// Request
{
  "type": "subscribe",
  "channel": "futures_balance_summary",
  "jwt": "XYZ"
}
```
```json
// Futures Balance Summary Message:
{
  "channel": "futures_balance_summary",
  "client_id": "",
  "timestamp": "2023-02-09T20:33:57.609931463Z",
  "sequence_num": 0,
  "events": [
    {
      "type": "snapshot",
      "fcm_balance_summary":{
        "futures_buying_power": "100.00",
        "total_usd_balance": "200.00",
        "cbi_usd_balance": "300.00",
        "cfm_usd_balance": "400.00",
        "total_open_orders_hold_amount": "500.00",
        "unrealized_pnl": "600.00",
        "daily_realized_pnl": "0",
        "initial_margin": "700.00",
        "available_margin": "800.00",
        "liquidation_threshold": "900.00",
        "liquidation_buffer_amount": "1000.00",
        "liquidation_buffer_percentage": "1000",
        "intraday_margin_window_measure":{
          "margin_window_type":"FCM_MARGIN_WINDOW_TYPE_INTRADAY",
          "margin_level":"MARGIN_LEVEL_TYPE_BASE",
          "initial_margin":"100.00",
          "maintenance_margin":"200.00",
          "liquidation_buffer_percentage":"1000",
          "total_hold":"100.00",
          "futures_buying_power":"400.00"
        },
        "overnight_margin_window_measure":{
          "margin_window_type":"FCM_MARGIN_WINDOW_TYPE_OVERNIGHT",
          "margin_level":"MARGIN_LEVEL_TYPE_BASE",
          "initial_margin":"300.00",
          "maintenance_margin":"200.00",
          "liquidation_buffer_percentage":"1000",
          "total_hold":"-30.00",
          "futures_buying_power":"2000.00"
        }
      }
    }
  ]
}
```

| Field                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
|:----------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `futures_buying_power`            | The amount of your cash balance that is available to trade CFM futures                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `total_usd_balance`               | Aggregate USD maintained across your CFTC-regulated futures account and your Coinbase Inc. spot account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `cbi_usd_balance`                 | USD maintained in your Coinbase Inc. spot account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `cfm_usd_balance`                 | USD maintained in your CFTC-regulated futures account. Funds held in your futures account are not available to trade spot                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `total_open_orders_hold_amount`   | Your total balance on hold for spot and futures open orders                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `unrealized_pnl`                  | Your current unrealized PnL across all open positions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `daily_realized_pnl`              | Your realized PnL from the current trade date. May include profit or loss from positions you’ve closed on the current trade date                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `initial_margin`                  | Margin required to initiate futures positions. Once futures orders are placed, these funds cannot be used to trade spot. The actual amount of funds necessary to support executed futures orders will be moved to your futures account                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `available_margin`                | Funds available to meet your anticipated margin requirement. This includes your CBI spot USD, CFM futures USD, and Futures PnL, less any holds for open spot or futures orders                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `liquidation_threshold`           | When your available funds for collateral drop to the liquidation threshold, some or all of your futures positions will be liquidated                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `liquidation_buffer_amount`       | Funds available in excess of the liquidation threshold, calculated as available margin minus liquidation threshold. If your liquidation buffer amount reaches 0, your futures positions and/or open orders will be liquidated as necessary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `liquidation_buffer_percentage`   | Funds available in excess of the liquidation threshold expressed as a percentage. If your liquidation buffer percentage reaches 0%, your futures positions and/or open orders will be liquidated as necessary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `intraday_margin_window_measure`  | The period of time used to calculate margin requirements for positions held intraday before settling overnight <br/> Includes: <ul> <li>`margin_window_type` <ul> <li>FCM_MARGIN_WINDOW_TYPE_UNSPECIFIED</li> <li>FCM_MARGIN_WINDOW_TYPE_OVERNIGHT</li> <li>FCM_MARGIN_WINDOW_TYPE_WEEKEND</li> <li>FCM_MARGIN_WINDOW_TYPE_INTRADAY</li> <li>FCM_MARGIN_WINDOW_TYPE_TRANSITION</li> </ul> </li> <li>`margin_level` <ul> <li>MARGIN_LEVEL_TYPE_UNSPECIFIED</li> <li>MARGIN_LEVEL_TYPE_BASE</li> <li>MARGIN_LEVEL_TYPE_WARNING</li> <li>MARGIN_LEVEL_TYPE_DANGER</li> <li>MARGIN_LEVEL_TYPE_LIQUIDATION</li> </ul></li> <li>`initial_margin`</li> <li>`maintenance_margin`</li> <li>`liquidation_buffer_percentage`</li> <li>`total_hold`</li> <li>`futures_buying_power`</li> </ul>     |
| `overnight_margin_window_measure` | The period of time used to calculate increased margin requirements for positions held and left unsettled overnight <br/> Includes: <ul> <li>`margin_window_type` <ul> <li>FCM_MARGIN_WINDOW_TYPE_UNSPECIFIED</li> <li>FCM_MARGIN_WINDOW_TYPE_OVERNIGHT</li> <li>FCM_MARGIN_WINDOW_TYPE_WEEKEND</li> <li>FCM_MARGIN_WINDOW_TYPE_INTRADAY</li> <li>FCM_MARGIN_WINDOW_TYPE_TRANSITION</li> </ul> </li> <li>`margin_level` <ul> <li>MARGIN_LEVEL_TYPE_UNSPECIFIED</li> <li>MARGIN_LEVEL_TYPE_BASE</li> <li>MARGIN_LEVEL_TYPE_WARNING</li> <li>MARGIN_LEVEL_TYPE_DANGER</li> <li>MARGIN_LEVEL_TYPE_LIQUIDATION</li> </ul></li> <li>`initial_margin`</li> <li>`maintenance_margin`</li> <li>`liquidation_buffer_percentage`</li> <li>`total_hold`</li> <li>`futures_buying_power`</li> </ul> |

**See Also:**

- [Subscribing to WebSocket Channels](./ws-overview.mdx#subscribing)
- [WebSocket Sequence Numbers](./ws-overview.mdx#sequence-numbers)
- [WebSocket Best Practices](./ws-best-practices.md)



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/ws-auth.mdx -->

---
title: "Advanced Trade WebSocket Authentication"
sidebar_label: "Authentication"
slug: "ws-auth"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This guide explains how to authenticate requests to the Advanced Trade [WebSocket API](./ws-channels.mdx) server channels. It assumes that you have already [created API keys](./getting-started.mdx) on the [Coinbase Developer Platform](https://portal.cdp.coinbase.com). 


## Sending Messages with API Keys

### Making Requests

Use the code samples below to generate/export a JSON Web Token (JWT) and make an authenticated request.

:::info
WebSocket JWTs (vs those for REST API) are not built with a request method or request path.
:::

### Generating a JWT

Regardless of which [code snippet](#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
1. Run the generation script that prints the command `export JWT=...`.
1. Run the generated command to save your JWT. 

  :::caution
  Your JWT expires after 2 minutes, after which all requests are unauthenticated.
  :::

### Code samples

The easiest way to generate a JWT is to use the built-in functions in our [Python SDK](./sdk-overview.md) as described below.
Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.


<Tabs>
<TabItem value="python_sdk" label="Python SDK">

1. Install the SDK.

    ```
    pip3 install coinbase-advanced-py
    ```

1. In the console, run: `python main.py` (or whatever your file name is).
1. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.

```python
from coinbase import jwt_generator

api_key = "organizations/{org_id}/apiKeys/{key_id}"
api_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def main():
    jwt_token = jwt_generator.build_ws_jwt(api_key, api_secret)
    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()

```

</TabItem>
<TabItem value="python" label="Python">

1. Install dependencies PyJWT and cryptography.
    ```
    pip install PyJWT
    pip install cryptography
    ```
2. In the console, run: `python main.py` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to the environment with `export JWT=$(node main.py)`.

```python
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name     = "organizations/{org_id}/apiKeys/{key_id}"
key_secret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt():
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)

    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
    }

    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )

    return jwt_token

def main():
    jwt_token = build_jwt()

    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()

```

</TabItem>
<TabItem value="go" label="Go">

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` and manage your dependencies.
4. In the console, run: go run `main.go`.
5. Set your JWT with that output, or export the JWT to environment with `export JWT=$(node main.go)`.


```go
package main

import (
    "crypto/rand"
    "crypto/x509"
    "encoding/pem"
    "fmt"
    "math"
    "math/big"
    "time"

    log "github.com/sirupsen/logrus"
    "gopkg.in/go-jose/go-jose.v2"
    "gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
    keyName     = "organizations/{org_id}/apiKeys/{key_id}"
    keySecret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
)

type APIKeyClaims struct {
    *jwt.Claims
}

func buildJWT() (string, error) {
    block, _ := pem.Decode([]byte(keySecret))
    if block == nil {
        return "", fmt.Errorf("jwt: Could not decode private key")
    }

    key, err := x509.ParseECPrivateKey(block.Bytes)
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    sig, err := jose.NewSigner(
        jose.SigningKey{Algorithm: jose.ES256, Key: key},
        (&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
    )
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    cl := &APIKeyClaims{
        Claims: &jwt.Claims{
            Subject:   keyName,
            Issuer:    "cdp",
            NotBefore: jwt.NewNumericDate(time.Now()),
            Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
        },
    }
    jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }
    return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
    r, err := rand.Int(rand.Reader, max)
    if err != nil {
        return "", err
    }
    return r.String(), nil
}

func main() {
    jwt, err := buildJWT()

    if err != nil {
        log.Errorf("error building jwt: %v", err)
    }
    fmt.Println("export JWT=" + jwt)
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

1. Install jsonwebtoken.
    ```
    npm install jsonwebtoken
    ```
2. In the console, run: `node main.js` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to environment with `export JWT=$(node main.js)`.

```javascript
const { sign } = require('jsonwebtoken');
const crypto = require('crypto');

const key_name       = 'organizations/{org_id}/apiKeys/{key_id}';
const key_secret = '-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n';

const algorithm = 'ES256';

const token = sign(
        {
           iss: 'cdp',
           nbf: Math.floor(Date.now() / 1000),
           exp: Math.floor(Date.now() / 1000) + 120,
           sub: key_name,
        },
        key_secret,
        {
           algorithm,
           header: {
              kid: key_name,
              nonce: crypto.randomBytes(16).toString('hex'),
           },
        }
);
console.log('export JWT=' + token);
```

</TabItem>
<TabItem value="php" label="PHP">

1. Add PHP dependencies with Composer (for JWT and environment variable management):

   ```
   composer require firebase/php-jwt
   composer require vlucas/phpdotenv
   ```

2. Run `generate_jwt.php` (or a filename of your choice).

3. Output the JWT to the command line and use a shell script to export it:

   ```
   export JWT=$(php generate_jwt.php)
   ```

<br />

> Code Snippet

```php
<?php
require 'vendor/autoload.php';
use Firebase\JWT\JWT;
use \Dotenv\Dotenv;

// Load environment variables
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

function buildJwt() {
    $keyName = $_ENV['NAME'];
    $keySecret = str_replace('\\n', "\n", $_ENV['PRIVATE_KEY']);

    $privateKeyResource = openssl_pkey_get_private($keySecret);
    if (!$privateKeyResource) {
        throw new Exception('Private key is not valid');
    }
    $time = time();
    $nonce = bin2hex(random_bytes(16));  // Generate a 32-character hexadecimal nonce
    $jwtPayload = [
        'sub' => $keyName,
        'iss' => 'cdp',
        'nbf' => $time,
        'exp' => $time + 120,  // Token valid for 120 seconds from now
    ];
    $headers = [
        'typ' => 'JWT',
        'alg' => 'ES256',
        'kid' => $keyName,  // Key ID header for JWT
        'nonce' => $nonce  // Nonce included in headers for added security
    ];
    $jwtToken = JWT::encode($jwtPayload, $privateKeyResource, 'ES256', $keyName, $headers);
    return $jwtToken;
}
```

</TabItem>
<TabItem value="java" label="Java">

1. Add Java Dependencies to your project's Maven or Gradle configuration:

   ```
   nimbus-jose-jwt (version 9.39), bcpkix-jdk18on (version 1.78), and java-dotenv (version 5.2.2)
   ```

2. Compile your Java application to generates a JWT, for example:

   ```
   mvn compile
   ```

3. Capture and export the JWT output from your Java application to an environment variable:

   ```
   export JWT=$(mvn exec:java -Dexec.mainClass=Main)
   ```

<br />

> Code Snippet

```java
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;
import java.security.interfaces.ECPrivateKey;
import java.util.Map;
import java.util.HashMap;
import java.time.Instant;
import java.util.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.io.StringReader;
import java.security.PrivateKey;
import java.security.Security;
import io.github.cdimascio.dotenv.Dotenv;

public class Main {
    public static void main(String[] args) throws Exception {
        // Register BouncyCastle as a security providerx
        Security.addProvider(new BouncyCastleProvider());

        // Load environment variables
        Dotenv dotenv = Dotenv.load();
        String privateKeyPEM = dotenv.get("PRIVATE_KEY").replace("\\n", "\n");
        String name = dotenv.get("NAME");

        // create header object
        Map<String, Object> header = new HashMap<>();
        header.put("alg", "ES256");
        header.put("typ", "JWT");
        header.put("kid", name);
        header.put("nonce", String.valueOf(Instant.now().getEpochSecond()));

        // create data object
        Map<String, Object> data = new HashMap<>();
        data.put("iss", "cdp");
        data.put("nbf", Instant.now().getEpochSecond());
        data.put("exp", Instant.now().getEpochSecond() + 120);
        data.put("sub", name);

        // Load private key
        PEMParser pemParser = new PEMParser(new StringReader(privateKeyPEM));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        Object object = pemParser.readObject();
        PrivateKey privateKey;

        if (object instanceof PrivateKey) {
            privateKey = (PrivateKey) object;
        } else if (object instanceof org.bouncycastle.openssl.PEMKeyPair) {
            privateKey = converter.getPrivateKey(((org.bouncycastle.openssl.PEMKeyPair) object).getPrivateKeyInfo());
        } else {
            throw new Exception("Unexpected private key format");
        }
        pemParser.close();

        // Convert to ECPrivateKey
        KeyFactory keyFactory = KeyFactory.getInstance("EC");
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());
        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);

        // create JWT
        JWTClaimsSet.Builder claimsSetBuilder = new JWTClaimsSet.Builder();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            claimsSetBuilder.claim(entry.getKey(), entry.getValue());
        }
        JWTClaimsSet claimsSet = claimsSetBuilder.build();

        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.ES256).customParams(header).build();
        SignedJWT signedJWT = new SignedJWT(jwsHeader, claimsSet);

        JWSSigner signer = new ECDSASigner(ecPrivateKey);
        signedJWT.sign(signer);

        String sJWT = signedJWT.serialize();
        System.out.println(sJWT);
    }
}
```

</TabItem>
<TabItem value="cpp" label="C++">

1. Install C++ project dependencies like so:

   ```
   apt-get update
   apt-get install libcurlpp-dev libssl-dev
   git clone https://github.com/Thalhammer/jwt-cpp
   cd jwt-cpp
   mkdir build && cd build
   cmake ..
   make
   make install
   ```

2. After you've saved your code to a file name, for example main.cpp, compile the program:

   ```
   g++ main.cpp -o myapp -lcurlpp -lcurl -lssl -lcrypto -I/usr/local/include -L/usr/local/lib -ljwt -std=c++17
   ```

3. Capture and export the JWT output from your C++ application to an environment variable:

   ```
   export JWT=$(./myapp)
   ```

<br />

> Code Snippet

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <jwt-cpp/jwt.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/pem.h>
#include <openssl/rand.h>

std::string create_jwt() {
    // Set request parameters
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

    // Generate a random nonce
    unsigned char nonce_raw[16];
    RAND_bytes(nonce_raw, sizeof(nonce_raw));
    std::string nonce(reinterpret_cast<char*>(nonce_raw), sizeof(nonce_raw));

    // Create JWT token
    auto token = jwt::create()
        .set_subject(key_name)
        .set_issuer("cdp")
        .set_not_before(std::chrono::system_clock::now())
        .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{120})
        .set_header_claim("kid", jwt::claim(key_name))
        .set_header_claim("nonce", jwt::claim(nonce))
        .sign(jwt::algorithm::es256(key_name, key_secret));

    return token;
};

int main() {
    try {
        std::string token = create_jwt();
        std::cout << "Generated JWT Token: " << token << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
};
```

</TabItem>
<TabItem value="typescript" label="TypeScript">
1. Install the JSON Web Token and TypeScript dependencies:

    ```bash
    npm install jsonwebtoken
    npm install @types/jsonwebtoken
    npm install -g typescript
    ```

2. Create a TypeScript file named `main.ts` and add the following code:

    ```typescript
    import * as jwt from 'jsonwebtoken';
    import * as crypto from 'crypto';

    const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
    const keySecret = `-----BEGIN EC PRIVATE KEY-----
    YOUR PRIVATE KEY
    -----END EC PRIVATE KEY-----`;
    const algorithm = 'ES256';


    const generateJWT = (): string => {
      const payload = {
        iss: 'cdp',
        nbf: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 120,
        sub: keyName,
      };

      const header = {
        alg: algorithm,
        kid: keyName,
        nonce: crypto.randomBytes(16).toString('hex'),
      };

      return jwt.sign(payload, keySecret, { algorithm, header });
    };

    const main = () => {
      const token = generateJWT();
      console.log(token);
    };

    main();
    ```

3. Compile the TypeScript file to JavaScript:

    ```bash
    tsc main.ts
    ```

    This will generate a `main.js` file.

4. Run the generated JavaScript file:

    ```bash
    node main.js
    ```

5. Set the JWT to the output, or export the JWT to the environment with:

    ```bash
    export JWT=$(node main.js)
    ```

> Code Snippet

```typescript
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----`;
const algorithm = 'ES256';

const generateJWT = (): string => {
  const payload = {
    iss: 'cdp',
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: keyName,
  };

  const header = {
    alg: algorithm,
    kid: keyName,
    nonce: crypto.randomBytes(16).toString('hex'),
  };

  return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
  const token = generateJWT();
  console.log(token);
};

main();
```

</TabItem>
<TabItem value="dotnet" label="C#">

1. Create a new console project by running the following command:

    ```
    dotnet new console
    ```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.


3.  Install C# project dependencies like so:

        ```
        dotnet add package Microsoft.IdentityModel.Tokens
        dotnet add package System.IdentityModel.Tokens.Jwt
        dotnet add package Jose-JWT
        ```

4.  Build the project by running the following command:

    ```
    dotnet build
    ```

5.  Run the project by running the following command:

    ```
    dotnet run
    ```

<br />

> Code Snippet

```dotnet
// Environment is .NET 6.0 C#

using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using Jose;

namespace JwtTest {
    internal class Program {

        static Random random = new Random();

        static void Main(string[] args) {

            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string key = parseKey(cbPrivateKey);
            string token = generateToken(name, key);

            Console.WriteLine($"Token is valid? {isTokenValid(token, name, key)}");

        }


        static string generateToken(string name, string secret) {
             var privateKeyBytes = Convert.FromBase64String(secret); // Assuming PEM is base64 encoded
             using var key = ECDsa.Create();
             key.ImportECPrivateKey(privateKeyBytes, out _);

             var payload = new Dictionary<string, object>
             {
                 { "sub", name },
                 { "iss", "coinbase-cloud" },
                 { "nbf", Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "exp", Convert.ToInt64((DateTime.UtcNow.AddMinutes(1) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
             };

             var extraHeaders = new Dictionary<string, object>
             {
                 { "kid", name },
                 // add nonce to prevent replay attacks with a random 10 digit number
                 { "nonce", randomHex(10) },
                 { "typ", "JWT"}
             };

             var encodedToken = JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

            // print token
            Console.WriteLine(encodedToken);
            return encodedToken;
        }

        static bool isTokenValid(string token, string tokenId, string secret) {
            if (token == null)
                return false;

            var key = ECDsa.Create();
            key?.ImportECPrivateKey(Convert.FromBase64String(secret), out _);

            var securityKey = new ECDsaSecurityKey(key) { KeyId = tokenId };

            try {
                var tokenHandler = new JwtSecurityTokenHandler();
                tokenHandler.ValidateToken(token, new TokenValidationParameters {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = securityKey,
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ClockSkew = TimeSpan.Zero
                }, out var validatedToken);

                return true;
            } catch {
                return false;
            }
        }

        static string parseKey(string key) {
            List<string> keyLines = new List<string>();
            keyLines.AddRange(key.Split('\n', StringSplitOptions.RemoveEmptyEntries));

            keyLines.RemoveAt(0);
            keyLines.RemoveAt(keyLines.Count - 1);

            return String.Join("", keyLines);
        }


        static string randomHex(int digits) {
            byte[] buffer = new byte[digits / 2];
            random.NextBytes(buffer);
            string result = String.Concat(buffer.Select(x => x.ToString("X2")).ToArray());
            if (digits % 2 == 0)
                return result;
            return result + random.Next(16).ToString("X");
        }

    }
}
```
</TabItem>
<TabItem value="Ruby" label="Ruby">

1. Install dependencies `JWT` and `OpenSSL`.

   ```
   gem install JWT
   gem install OpenSSL
   ```

2. In the console, run: `ruby main.rb` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(ruby main.rb)`.

```ruby
require 'jwt'
require 'openssl'
require 'time'
require 'securerandom'

Key_name = "organizations/{org_id}/apiKeys/{key_id}"
Key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt()
    header = {
      typ: 'JWT',
      kid: Key_name,
      nonce: SecureRandom.hex(16)
    }

    claims = {
      sub: Key_name,
      iss: 'cdp',
      aud: ['cdp_service'],
      nbf: Time.now.to_i,
      exp: Time.now.to_i + 120, # Expiration time: 2 minute from now.
    }

    private_key = OpenSSL::PKey::read(Key_secret)
    JWT.encode(claims, private_key, 'ES256', header)
  end


token = build_jwt()
puts token
```

</TabItem>
</Tabs>


## Sending Messages without API Keys

### Subscribing

```json
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
    "type": "subscribe",
    "product_ids": [
        "ETH-USD",
        "ETH-EUR"
    ],
    "channel": "level2"
}
```

### Unsubscribing

```json
// Request
{
    "type": "unsubscribe",
    "product_ids": [
        "ETH-USD",
        "ETH-EUR"
    ],
    "channel": "level2"
}
```

## Sequence Numbers

Most feed messages contain a sequence number. Sequence numbers are increasing integer values for each product, with each new message being exactly one sequence number greater than the one before it.

Sequence numbers that are _greater than one integer value_ from the previous number indicate that a message has been dropped. Sequence numbers that are _less_ than the previous number can be ignored or represent a message that has arrived out of order.

In either situation you may need to perform logic to make sure your system is in the correct state.

:::caution
Even though a WebSocket connection is over TCP, the WebSocket servers receive market data in a manner that can result in dropped messages. Your feed consumer should be designed to handle sequence gaps and out of order messages, or should use channels that guarantee delivery of messages.
:::

:::tip
To guarantee that messages are delivered and your order book is in sync, consider using the [level2 channel](./ws-channels.mdx#level2-channel).
:::


**See Also:**  

- [WebSocket Legacy Keys](./ws-auth-legacy.md)
- [WebSocket Channels](./ws-channels.mdx)


<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/ws-overview.mdx -->

---
title: "Advanced Trade WebSocket Overview"
sidebar_label: "WebSocket Overview"
slug: "ws-overview"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The WebSocket feed is publicly available and provides real-time market data updates for orders and trades. Two endpoints are supported in production:
- **Market Data** is our traditional feed that provides updates for both orders and trades. Most channels are now available without authentication.
- **User Order Data** provides updates for the orders of the user.

:::info
**Market Data** Endpoint: `wss://advanced-trade-ws.coinbase.com`<br/>
**User Order Data** Endpoint: `wss://advanced-trade-ws-user.coinbase.com`
:::

:::tip
You can subscribe to the Heartbeats Channel, User Channel and Futures Balance Summary Channel with the User Order Data endpoint. If advanced-trade-ws-user is your primary connection, we recommend using advanced-trade-ws as a failover.
:::

## Protocol

The WebSocket feed uses a bidirectional protocol that encodes all messages as JSON objects. All messages have a `type` attribute that can be used to handle the message appropriately.

:::tip
New message types can be added at any time. Clients are expected to ignore messages they do not support.
:::

## Sending Messages with CDP Keys

### Subscribing

To begin receiving feed messages, you must send a `subscribe` message to the server indicating which channel and products to receive. This message is mandatory and you are disconnected if no `subscribe` has been received within 5 seconds.

You can subscribe to multiple channels but you must send a unique subscription message for each channel.

:::caution
To receive feed messages, you must send a `subscribe` message or you are disconnected in 5 seconds.
:::

```json
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "jwt": "exampleJWT"
}
```

To subscribe to any channel, provide a `channel` name and `jwt`:

- `channel` name as a string. You can only subscribe to one channel per subscription message.

- `jwt` can be generated by running one of the code snippets provided in the [WebSocket Authentication page](./ws-auth.mdx). Remember that you must generate a different JWT for each websocket message sent, since the JWTs will expire after 2 minutes.

### Unsubscribing

To unsubscribe from a channel/product pair, send an `unsubscribe` message. The structure is the same as `subscribe` message. You can only unsubscribe from one channel per subscription message. You can also unsubscribe from a channel entirely by providing no product IDs.

```json
// Request
{
  "type": "unsubscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2",
  "jwt": "exampleJWT"
}
```

You receive a `subscriptions` message as a response to an `unsubscribe` message.

## Websocket Code Samples

Use the code samples to subscribe to one or more Advanced Trade WebSocket channels using CDP API Keys.


<Tabs>
<TabItem value="javascript" label="JavaScript">

```javascript
// JS Example for subscribing to a channel
/* eslint-disable */
const WebSocket = require("ws");
const { sign } = require("jsonwebtoken");
const crypto = require("crypto");
const fs = require("fs");

// Derived from your Coinbase CDP API Key
//  SIGNING_KEY: the signing key provided as a part of your API key. Also called the "SECRET KEY"
//  API_KEY: the api key provided as a part of your API key. also called the "API KEY NAME"
const API_KEY = "organizations/{org_id}/apiKeys/{key_id}";
const SIGNING_KEY =
  "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

const algorithm = "ES256";

if (!SIGNING_KEY.length || !API_KEY.length) {
  throw new Error("missing mandatory environment variable(s)");
}

const CHANNEL_NAMES = {
  level2: "level2",
  user: "user",
  tickers: "ticker",
  ticker_batch: "ticker_batch",
  status: "status",
  market_trades: "market_trades",
  candles: "candles",
};

// The base URL of the API
const WS_API_URL = "wss://advanced-trade-ws.coinbase.com";

function signWithJWT(message, channel, products = []) {
  const jwt = sign(
    {
      iss: "cdp",
      nbf: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 120,
      sub: API_KEY,
    },
    SIGNING_KEY,
    {
      algorithm,
      header: {
        kid: API_KEY,
        nonce: crypto.randomBytes(16).toString("hex"),
      },
    }
  );

  return { ...message, jwt: jwt };
}

const ws = new WebSocket(WS_API_URL);

function subscribeToProducts(products, channelName, ws) {
  const message = {
    type: "subscribe",
    channel: channelName,
    product_ids: products,
  };
  const subscribeMsg = signWithJWT(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function unsubscribeToProducts(products, channelName, ws) {
  const message = {
    type: "unsubscribe",
    channel: channelName,
    product_ids: products,
  };
  const subscribeMsg = signWithJWT(message, channelName, products);
  ws.send(JSON.stringify(subscribeMsg));
}

function onMessage(data) {
  const parsedData = JSON.parse(data);
  fs.appendFile("Output1.txt", data, (err) => {
    // In case of a error throw err.
    if (err) throw err;
  });
}

const connections = [];
let sentUnsub = false;
for (let i = 0; i < 1; i++) {
  const date1 = new Date(new Date().toUTCString());
  const ws = new WebSocket(WS_API_URL);

  ws.on("message", function (data) {
    const date2 = new Date(new Date().toUTCString());
    const diffTime = Math.abs(date2 - date1);
    if (diffTime > 5000 && !sentUnsub) {
      unsubscribeToProducts(["BTC-USD"], CHANNEL_NAMES.level2, ws);
      sentUnsub = true;
    }

    const parsedData = JSON.parse(data);
    fs.appendFile("Output1.txt", data, (err) => {
      // In case of a error throw err.
      if (err) throw err;
    });
  });

  ws.on("open", function () {
    const products = ["BTC-USD"];
    subscribeToProducts(products, CHANNEL_NAMES.level2, ws);
  });

  connections.push(ws);
}
```


</TabItem>
<TabItem value="python" label="Python">

```python
# Python Example for subscribing to a channel
import time
import json
import jwt
import hashlib
import os
import websocket
import threading
from datetime import datetime, timedelta

# Derived from your Coinbase CDP API Key
# SIGNING_KEY: the signing key provided as a part of your API key. Also called the "SECRET KEY"
# API_KEY: the api key provided as a part of your API key. also called the "API KEY NAME"
API_KEY = "organizations/{org_id}/apiKeys/{key_id}"
SIGNING_KEY = """-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----"""

ALGORITHM = "ES256"

if not SIGNING_KEY or not API_KEY:
    raise ValueError("Missing mandatory environment variable(s)")

CHANNEL_NAMES = {
    "level2": "level2",
    "user": "user",
    "tickers": "ticker",
    "ticker_batch": "ticker_batch",
    "status": "status",
    "market_trades": "market_trades",
    "candles": "candles",
}

WS_API_URL = "wss://advanced-trade-ws.coinbase.com"

def sign_with_jwt(message, channel, products=[]):
    payload = {
        "iss": "coinbase-cloud",
        "nbf": int(time.time()),
        "exp": int(time.time()) + 120,
        "sub": API_KEY,
    }
    headers = {
        "kid": API_KEY,
        "nonce": hashlib.sha256(os.urandom(16)).hexdigest()
    }
    token = jwt.encode(payload, SIGNING_KEY, algorithm=ALGORITHM, headers=headers)
    message['jwt'] = token
    return message

def on_message(ws, message):
    data = json.loads(message)
    with open("Output1.txt", "a") as f:
        f.write(json.dumps(data) + "\n")

def subscribe_to_products(ws, products, channel_name):
    message = {
        "type": "subscribe",
        "channel": channel_name,
        "product_ids": products
    }
    signed_message = sign_with_jwt(message, channel_name, products)
    ws.send(json.dumps(signed_message))

def unsubscribe_to_products(ws, products, channel_name):
    message = {
        "type": "unsubscribe",
        "channel": channel_name,
        "product_ids": products
    }
    signed_message = sign_with_jwt(message, channel_name, products)
    ws.send(json.dumps(signed_message))

def on_open(ws):
    products = ["BTC-USD"]
    subscribe_to_products(ws, products, CHANNEL_NAMES["level2"])

def start_websocket():
    ws = websocket.WebSocketApp(WS_API_URL, on_open=on_open, on_message=on_message)
    ws.run_forever()

def main():
    ws_thread = threading.Thread(target=start_websocket)
    ws_thread.start()

    sent_unsub = False
    start_time = datetime.utcnow()

    try:
        while True:
            if (datetime.utcnow() - start_time).total_seconds() > 5 and not sent_unsub:
                # Unsubscribe after 5 seconds
                ws = websocket.create_connection(WS_API_URL)
                unsubscribe_to_products(ws, ["BTC-USD"], CHANNEL_NAMES["level2"])
                ws.close()
                sent_unsub = True
            time.sleep(1)
    except Exception as e:
        print(f"Exception: {e}")

if __name__ == "__main__":
    main()

```

</TabItem>
</Tabs>


## Sending Messages without API Keys

### Subscribing

```json
// Request
// Subscribe to ETH-USD and ETH-EUR with the level2 channel
{
  "type": "subscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2"
}
```

### Unsubscribing

```json
// Request
{
  "type": "unsubscribe",
  "product_ids": ["ETH-USD", "ETH-EUR"],
  "channel": "level2"
}
```

## Sequence Numbers

Most feed messages contain a sequence number. Sequence numbers are increasing integer values for each product, with each new message being exactly one sequence number greater than the one before it.

Sequence numbers that are _greater than one integer value_ from the previous number indicate that a message has been dropped. Sequence numbers that are _less_ than the previous number can be ignored or represent a message that has arrived out of order.

In either situation you may need to perform logic to make sure your system is in the correct state.

:::caution
Even though a WebSocket connection is over TCP, the WebSocket servers receive market data in a manner that can result in dropped messages. Your feed consumer should be designed to handle sequence gaps and out of order messages, or should use channels that guarantee delivery of messages.
:::

:::tip
To guarantee that messages are delivered and your order book is in sync, consider using the [level2 channel](./ws-channels.mdx#level2-channel).
:::

**See Also:**

- [WebSocket Channels](./ws-channels.mdx)
- [WebSocket Rate Limits](./ws-rate-limits.md)



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/rest-api-overview.mdx -->

---
title: "Advanced Trade API Endpoints"
sidebar_label: "Endpoints"
slug: "api-overview"
hide_table_of_contents: true
---

{/* Import reusable content snippet */}
import AuthenticateAllV3Endpoints from './\_snippet-auth-v3-endpoints.mdx';

The Advanced Trade API lets you manage orders, portfolios, products, and fees with our new `v3` endpoints. For core Coinbase functions for account deposits, withdrawals, and transaction, you will still need [Coinbase App API](/coinbase-app/docs/api-users) `v2` endpoints.

<AuthenticateAllV3Endpoints />


## Advanced Trade Endpoints

Advanced Trade endpoint URL: **`https://api.coinbase.com/api/v3/brokerage/{resource}`**


## Private Endpoints

Consult the [Authentication guide](./getting-started.mdx) for more information on CDP API keys.

| API                                                                                                      | Method | Resource                               | API Key Permission                |
| :------------------------------------------------------------------------------------------------------- | :----- | :------------------------------------- | :-------------------------------- |
| [List Accounts](/advanced-trade/reference/retailbrokerageapi_getaccounts)                                | GET    | `/accounts`                            | `view`                            |
| [Get Account](/advanced-trade/reference/retailbrokerageapi_getaccount)                                   | GET    | `/accounts/:account_id`                | `view`                            |
| [Create Order](/advanced-trade/reference/retailbrokerageapi_postorder)                                   | POST   | `/orders`                              | `trade`                           |
| [Cancel Orders](/advanced-trade/reference/retailbrokerageapi_cancelorders)                               | POST   | `/orders/batch_cancel`                 | `trade`                           |
| [List Orders](/advanced-trade/reference/retailbrokerageapi_gethistoricalorders)                          | GET    | `/orders/historical/batch`             | `view`                            |
| [List Fills](/advanced-trade/reference/retailbrokerageapi_getfills)                                      | GET    | `/orders/historical/fills`             | `view`                            |
| [Get Order](/advanced-trade/reference/retailbrokerageapi_gethistoricalorder)                             | GET    | `/orders/historical/{order_id}`        | `view`                            |
| [Preview Orders](/advanced-trade/reference/retailbrokerageapi_previeworder)                              | POST   | `/orders/preview`                      | `view`                            |
| [Get Best Bid/Ask](/advanced-trade/reference/retailbrokerageapi_getbestbidask)                           | GET    | `/best_bid_ask`                        | `view`                            |
| [Get Product Book](/advanced-trade/reference/retailbrokerageapi_getproductbook)                          | GET    | `/product_book`                        | `view`                            |
| [List Products](/advanced-trade/reference/retailbrokerageapi_getproducts)                                | GET    | `/products`                            | `view`                            |
| [Get Product](/advanced-trade/reference/retailbrokerageapi_getproduct)                                   | GET    | `/products/{product_id}`               | `view`                            |
| [Get Product Candles](/advanced-trade/reference/retailbrokerageapi_getcandles)                           | GET    | `/products/{product_id}/candles`       | `view`                            |
| [Get Market Trades](/advanced-trade/reference/retailbrokerageapi_getmarkettrades)                        | GET    | `/products/{product_id}/ticker`        | `view`                            |
| [Get Transactions Summary](/advanced-trade/reference/retailbrokerageapi_gettransactionsummary)           | GET    | `/transaction_summary`                 | `view`                            |
| [Create Convert Quote](/advanced-trade/reference/retailbrokerageapi_createconvertquote)                  | POST   | `/convert/quote`                       | `trade`                           |
| [Commit Convert Trade](/advanced-trade/reference/retailbrokerageapi_commitconverttrade)                  | POST   | `/convert/{trade_id}`                  | `trade`                           |
| [Get Convert Trade](/advanced-trade/reference/retailbrokerageapi_getconverttrade)                        | GET    | `/convert/{trade_id}`                  | `view`                            |
| [List Portfolios](/advanced-trade/reference/retailbrokerageapi_getportfolios)                            | GET    | `/portfolios`                          | `view`                            |
| [Create Portfolio](/advanced-trade/reference/retailbrokerageapi_createportfolio)                         | POST   | `/portfolios`                          | `view` (any portfolio)            |
| [Move Portfolio Funds](/advanced-trade/reference/retailbrokerageapi_moveportfoliofunds)                  | POST   | `/portfolios`                          | `transfer` (for source portfolio) |
| [Get Portfolio Breakdown](/advanced-trade/reference/retailbrokerageapi_getportfoliobreakdown)            | GET    | `/portfolios`                          | `view` (for that portfolio)       |
| [Delete Portfolio](/advanced-trade/reference/retailbrokerageapi_deleteportfolio)                         | DELETE | `/portfolios`                          | `trade` (for that portfolio)      |
| [Edit Portfolio](/advanced-trade/reference/retailbrokerageapi_editportfolio)                             | PUT    | `/portfolios`                          | `trade` (for that portfolio)      |
| [Get Futures Balance Summary](/advanced-trade/reference/retailbrokerageapi_getfcmbalancesummary)         | GET    | `/cfm/balance_summary`                 | `view`                            |
| [List Futures Positions](/advanced-trade/reference/retailbrokerageapi_getfcmpositions)                   | GET    | `/cfm.positions`                       | `view`                            |
| [Get Futures Position](/advanced-trade/reference/retailbrokerageapi_getfcmposition)                      | GET    | `/cfm/positions/{product_id}`          | `view`                            |
| [Schedule Futures Sweep](/advanced-trade/reference/retailbrokerageapi_schedulefcmsweep)                  | POST   | `/cfm/sweeps/schedule`                 | `transfer`                        |
| [List Futures Sweeps](/advanced-trade/reference/retailbrokerageapi_getfcmsweeps)                         | GET    | `/cfm/sweeps`                          | `view`                            |
| [Cancel Futures Sweep](/advanced-trade/reference/retailbrokerageapi_cancelfcmsweep)                      | DELETE | `/cfm/sweeps`                          | `transfer`                        |
| [Get Intraday Margin Setting](/advanced-trade/reference/retailbrokerageapi_getintradaymarginsetting)     | GET    | `/cfm/intraday/margin_setting`         | `view`                            |
| [Set Intraday Margin Setting](/advanced-trade/reference/retailbrokerageapi_setintradaymarginsetting)     | POST   | `/cfm/intraday/margin_setting`         | `trade`                           |
| [Get Current Margin Window](/advanced-trade/reference/retailbrokerageapi_getcurrentmarginwindow)         | GET    | `/cfm/intraday/current_margin_window`  | `view`                            |
| [Get Perpetuals Portfolio Summary](/advanced-trade/reference/retailbrokerageapi_getintxportfoliosummary) | GET    | `/intx/portfolio`                      | `view` (for intx portfolio)       |
| [List Perpetuals Positions](/advanced-trade/reference/retailbrokerageapi_getintxpositions)               | GET    | `/intx/positions`                      | `view` (for intx portfolio)       |
| [Get Perpetuals Position](/advanced-trade/reference/retailbrokerageapi_getintxposition)                  | GET    | `/intx/positions`                      | `view` (for intx portfolio)       |
| [Get Perpetuals Portfolio Balances](/advanced-trade/reference/retailbrokerageapi_getintxbalances)        | GET    | `/intx/balances`                       | `view` (for intx portfolio)       |
| [Opt-In Multi Asset Collateral](/advanced-trade/reference/retailbrokerageapi_intxmultiassetcollateral)   | POST   | `/intx/multi_asset_collateral`         | `trade` (for intx portfolio)      |
| [Allocate Portfolio](/advanced-trade/reference/retailbrokerageapi_allocateportfolio)                     | POST   | `/intx/allocate`                       | `transfer` (for intx portfolio)   |
| [List Payment Methods](/advanced-trade/reference/retailbrokerageapi_getpaymentmethods)                   | GET    | `/payment_methods`                     | `view`                            |
| [Get Payment Method](/advanced-trade/reference/retailbrokerageapi_getpaymentmethod)                      | GET    | `/payment_methods/{payment_method_id}` | `view`                            |
| [Get Api Key Permissions](/advanced-trade/reference/retailbrokerageapi_getapikeypermissions)                      | GET    | `/key_permissions` | `view`                            |

## Public Endpoints

Public endpoints do not require authentication.

:::tip
1s cache is enabled for all public endpoints. If you need real-time data, please choose one of the following options:
- Use the [WebSocket](/advanced-trade/docs/ws-overview) (recommended as this will provide the fastest product and market trades updates).
- Set `cache-control: no-cache` header on the API requests to bypass caching.
- Use the authenticated endpoints.
:::

| API                                                                                            | Method | Resource                                |
| :--------------------------------------------------------------------------------------------- | :----- | :-------------------------------------- |
| [Get Server Time](/advanced-trade/reference/retailbrokerageapi_getservertime)                  | GET    | `/time`                                 |
| [Get Public Product Book](/advanced-trade/reference/retailbrokerageapi_getpublicproductbook)   | GET    | `/market/product_book`                  |
| [List Public Products](/advanced-trade/reference/retailbrokerageapi_getpublicproducts)         | GET    | `/market/products`                      |
| [Get Public Product](/advanced-trade/reference/retailbrokerageapi_getpublicproduct)            | GET    | `/market/products/{product_id}`         |
| [Get Public Product Candles](/advanced-trade/reference/retailbrokerageapi_getpubliccandles)    | GET    | `/market/products/{product_id}/candles` |
| [Get Public Market Trades](/advanced-trade/reference/retailbrokerageapi_getpublicmarkettrades) | GET    | `/market/products/{product_id}/ticker`  |

<br /><br />

**See Also:**

- [Getting Started with Advanced Trade](./getting-started.mdx)
- [Pro API Mapping](./rest-api-pro-mapping.md)



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/rest-api-auth.mdx -->

---
title: "Advanced Trade API Authentication"
sidebar_label: "Authentication"
slug: "rest-api-auth"
---

{/* Display code samples in tabbed view */}
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

{/* Import reusable content snippets */}
{/* Snippets don't render headers as links in the right-hand nav which is why there are so many */}
import CDPAuthMakingRequests   from './_snippet-cdp-auth-making-requests.mdx';
import CDPAuthGeneratingJWT    from './_snippet-cdp-auth-generating-jwt.mdx';
import CDPAuthCodeSamples      from './_snippet-cdp-auth-code-samples.mdx';

This guide explains how to authenticate requests to the Advanced Trade REST API endpoints and WebSocket server channels. It assumes that you have already [created API keys](./getting-started.mdx) on the [Coinbase Developer Platform](https://portal.cdp.coinbase.com). 

## Making Requests

<CDPAuthMakingRequests />

### Generating a JWT

<CDPAuthGeneratingJWT />

### Code Samples

<CDPAuthCodeSamples />



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/getting-started.mdx -->

---
title: "Getting Started with Advanced Trade APIs"
sidebar_label: "Getting Started"
slug: "getting-started"
---

{/* Import reusable content snippets */}
{/* Snippets don't render headers as links in the right-hand nav which is why there are so many */}
import CDPAuthCreatingKeys     from './_snippet-cdp-auth-creating-keys.mdx';

To get started with Advanced Trade APIs, create an API in your [API settings](https://coinbase.com/settings/api).

Use your API key to authenticate requests to permissioned endpoints of the Advanced Trade [REST API](./rest-api-auth.mdx) and [WebSocket API](./ws-auth.mdx) channels.

:::info Legacy API Keys
Legacy authentication is currently still supported for existing keys, but legacy key creation is now disabled.
:::

:::info Coinbase Developer Portal (CDP)
API Keys can also be created and managed on the [Coinbase Developer Portal](https://portal.cdp.coinbase.com) (CDP). CDP provides advanced developer tooling and access to other APIs across Coinbase.
:::

<CDPAuthCreatingKeys />


## OAuth2

Use OAuth authentication if you're building an application for many users on top of the Advanced Trade APIs. See [Coinbase App OAuth2 Integration](/coinbase-app/docs/coinbase-app-integration) to get a client set up and make authenticated calls.



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/security.mdx -->

---
title: "Security Best Practices"
sidebar_label: "Security Best Practices"
slug: "security"
---

This page provides guidance on how you can manage your credentials.


## Auth Schemes

The Advanced Trade API and the adjacent Coinbase App APIs support the following authentication schemes. 

| Scheme        | Who Should Use                                 | When to Use    |
|:--------------|:-----------------------------------------------|:---------------|
| [CDP API keys](./getting-started.mdx)  | Individuals or apps for individual use<br/><br/>You have security keys enabled on your account | <ul><li>With all Advanced REST APIs & WebSocket channels</li><li>With new Advanced API features like Portfolios</li><li>Can be used on Coinbase App APIs</li></ul> |
| [OAuth2](./getting-started.mdx#oauth2) | Applications serving many users                | <ul><li>Can be used with Advanced REST API</li><li>Can be used with Coinbase App APIs</li></ul>  |
| Legacy keys <br />- [REST](./rest-api-auth-legacy.mdx)<br />- [WebSocket](./ws-auth-legacy.md)       | Individuals or apps for individual use | <ul> <li>Can be used with Advanced REST API & WebSocket channels (except new features)</li><li>Can be used with Coinbase App APIs</li></ul> |


## Storing Credentials Securely

Store your credentials securely. If someone obtains your `api_secret` with the `wallet:transfer:send` permission, they will be able to withdraw all the digital currency out of your account.

Avoid storing API keys in your source code repository. API keys are typically securely injected in your application runtime via environment variables. Learn more about environment variables [The Twelve-Factor App](https://12factor.net/config). Separating credentials from your code base and database is always good practice.

API key access is turned off by default on all accounts. To implement an API key integration, you therefore must first enable it,and then take necessary precautions to store the API key securely. You can always regenerate your API key (or disable it) if you feel it has been compromised.


## Validating SSL Certificates

It is important that your application validates our SSL certificate when it connects over `https`. This helps prevent a [man-in-the-middle attack](http://en.wikipedia.org/wiki/Man-in-the-middle_attack). If you are using a client library, this may be turned on by default, but you should confirm this. Whenever you see 'verify SSL' you should always ensure it is set to true.


## Additional Key Security

For enhanced API key security, we recommend that you **allowlist IP addresses** that are permitted to make requests with a particular API key.

You can specify IP addresses to allowlist when [creating a new API key](./getting-started.mdx) or editing an existing one.

<figcaption><i>Click to enlarge</i></figcaption> <img src={require('../assets/images/edit-api-key.png').default} width="800" alt="Image of Coinbase Developer Platform" />



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/_snippet-auth-v3-endpoints.mdx -->

:::caution Most v3 endpoints require authentication unless otherwise noted

The [Advanced Trade REST API](/advanced-trade/reference/retailbrokerageapi_getaccounts) comprises all [`v3` endpoints](/advanced-trade/docs/rest-api-overview#advanced-trade-endpoints). It does not duplicate the Coinbase App `v2` endpoints for core Coinbase functions (some of which need authentication as well). 
:::



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/_snippet-cdp-auth-code-samples.mdx -->

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

The easiest way to generate a JWT is to use the built-in functions in our [Python SDK](./sdk-overview) as described below.

Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.

<Tabs>
<TabItem value="python_sdk" label="Python SDK">

1. Install the SDK.

   ```
   pip3 install coinbase-advanced-py
   ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```python
from coinbase import jwt_generator

api_key = "organizations/{org_id}/apiKeys/{key_id}"
api_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

request_method = "GET"
request_path = "/api/v3/brokerage/accounts"

def main():
    jwt_uri = jwt_generator.format_jwt_uri(request_method, request_path)
    jwt_token = jwt_generator.build_rest_jwt(jwt_uri, api_key, api_secret)
    print(jwt_token)

if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="python" label="Python">

1. Install dependencies `PyJWT` and `cryptography`.

   ```
   pip install PyJWT==2.8.0
   pip install cryptography==42.0.5
   ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```python
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name       = "organizations/{org_id}/apiKeys/{key_id}"
key_secret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
request_method = "GET"
request_host   = "api.coinbase.com"
request_path   = "/api/v3/brokerage/accounts"
def build_jwt(uri):
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)
    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
        'uri': uri,
    }
    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )
    return jwt_token
def main():
    uri = f"{request_method} {request_host}{request_path}"
    jwt_token = build_jwt(uri)
    print(jwt_token)
if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="go" label="Go">

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` to manage your dependencies.
4. In the console, run `go run main.go`. This outputs the command, `export JWT=`.
5. Set your JWT with the generated output, or export the JWT to the environment with `export JWT=$(go run main.go)`.
6. Make your request, for example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```go
package main

import (
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"math"
	"math/big"
	"time"

	log "github.com/sirupsen/logrus"
	"gopkg.in/go-jose/go-jose.v2"
	"gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
	keyName       = "organizations/{org_id}/apiKeys/{key_id}"
	keySecret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
	requestMethod = "GET"
	requestHost   = "api.coinbase.com"
	requestPath   = "/api/v3/brokerage/accounts"
)

type APIKeyClaims struct {
	*jwt.Claims
	URI string `json:"uri"`
}

func buildJWT(uri string) (string, error) {
	block, _ := pem.Decode([]byte(keySecret))
	if block == nil {
		return "", fmt.Errorf("jwt: Could not decode private key")
	}

	key, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	sig, err := jose.NewSigner(
		jose.SigningKey{Algorithm: jose.ES256, Key: key},
		(&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
	)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	cl := &APIKeyClaims{
		Claims: &jwt.Claims{
			Subject:   keyName,
			Issuer:    "cdp",
			NotBefore: jwt.NewNumericDate(time.Now()),
			Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
		},
		URI: uri,
	}
	jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}
	return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
	r, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}
	return r.String(), nil
}

func main() {
	uri := fmt.Sprintf("%s %s%s", requestMethod, requestHost, requestPath)

	jwt, err := buildJWT(uri)

	if err != nil {
		log.Errorf("error building jwt: %v", err)
	}
	fmt.Println(jwt)
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

1. Install JSON Web Token:

   ```
   npm install jsonwebtoken
   ```

2. In the console, run: `node main.js` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(node main.js)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```javascript
const { sign } = require("jsonwebtoken");
const crypto = require("crypto");

const key_name = "organizations/{org_id}/apiKeys/{key_id}";
const key_secret =
  "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";
const request_method = "GET";
const url = "api.coinbase.com";
const request_path = "/api/v3/brokerage/accounts";

const algorithm = "ES256";
const uri = request_method + " " + url + request_path;

const token = sign(
  {
    iss: "cdp",
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: key_name,
    uri,
  },
  key_secret,
  {
    algorithm,
    header: {
      kid: key_name,
      nonce: crypto.randomBytes(16).toString("hex"),
    },
  }
);
console.log("export JWT=" + token);
```

</TabItem>
<TabItem value="php" label="PHP">

1. Add PHP dependencies with Composer (for JWT and environment variable management):

   ```
   composer require firebase/php-jwt
   composer require vlucas/phpdotenv
   ```

2. Run `generate_jwt.php` (or a filename of your choice).

3. Output the JWT to the command line and use a shell script to export it:

   ```
   export JWT=$(php generate_jwt.php)
   ```

4. Make your request, for example:

   ```
   curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
   ```

<br />

> Code Snippet

```php
<?php
require 'vendor/autoload.php';
use Firebase\JWT\JWT;
use \Dotenv\Dotenv;

// Load environment variables
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

function buildJwt() {
    $keyName = $_ENV['NAME'];
    $keySecret = str_replace('\\n', "\n", $_ENV['PRIVATE_KEY']);
    $request_method = 'GET';
    $url = 'api.coinbase.com';
    $request_path = '/api/v3/brokerage/accounts';

    $uri = $request_method . ' ' . $url . $request_path;
    $privateKeyResource = openssl_pkey_get_private($keySecret);
    if (!$privateKeyResource) {
        throw new Exception('Private key is not valid');
    }
    $time = time();
    $nonce = bin2hex(random_bytes(16));  // Generate a 32-character hexadecimal nonce
    $jwtPayload = [
        'sub' => $keyName,
        'iss' => 'cdp',
        'nbf' => $time,
        'exp' => $time + 120,  // Token valid for 120 seconds from now
        'uri' => $uri,
    ];
    $headers = [
        'typ' => 'JWT',
        'alg' => 'ES256',
        'kid' => $keyName,  // Key ID header for JWT
        'nonce' => $nonce  // Nonce included in headers for added security
    ];
    $jwtToken = JWT::encode($jwtPayload, $privateKeyResource, 'ES256', $keyName, $headers);
    return $jwtToken;
}
```

</TabItem>
<TabItem value="java" label="Java">

1. Add Java Dependencies to your project's Maven or Gradle configuration:

   ```
   nimbus-jose-jwt (version 9.39), bcpkix-jdk18on (version 1.78), and java-dotenv (version 5.2.2)
   ```

2. Compile your Java application to generates a JWT, for example:

   ```
   mvn compile
   ```

3. Capture and export the JWT output from your Java application to an environment variable:

   ```
   export JWT=$(mvn exec:java -Dexec.mainClass=Main)
   ```

4. Make an API Request, for example:

   ```
   curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
   ```

<br />

> Code Snippet

```java
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;
import java.security.interfaces.ECPrivateKey;
import java.util.Map;
import java.util.HashMap;
import java.time.Instant;
import java.util.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.io.StringReader;
import java.security.PrivateKey;
import java.security.Security;
import io.github.cdimascio.dotenv.Dotenv;

public class Main {
    public static void main(String[] args) throws Exception {
        // Register BouncyCastle as a security providerx
        Security.addProvider(new BouncyCastleProvider());

        // Load environment variables
        Dotenv dotenv = Dotenv.load();
        String privateKeyPEM = dotenv.get("PRIVATE_KEY").replace("\\n", "\n");
        String name = dotenv.get("NAME");

        // create header object
        Map<String, Object> header = new HashMap<>();
        header.put("alg", "ES256");
        header.put("typ", "JWT");
        header.put("kid", name);
        header.put("nonce", String.valueOf(Instant.now().getEpochSecond()));

        // create uri string for current request
        String requestMethod = "GET";
        String url = "api.coinbase.com/api/v3/brokerage/accounts";
        String uri = requestMethod + " " + url;

        // create data object
        Map<String, Object> data = new HashMap<>();
        data.put("iss", "cdp");
        data.put("nbf", Instant.now().getEpochSecond());
        data.put("exp", Instant.now().getEpochSecond() + 120);
        data.put("sub", name);
        data.put("uri", uri);

        // Load private key
        PEMParser pemParser = new PEMParser(new StringReader(privateKeyPEM));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        Object object = pemParser.readObject();
        PrivateKey privateKey;

        if (object instanceof PrivateKey) {
            privateKey = (PrivateKey) object;
        } else if (object instanceof org.bouncycastle.openssl.PEMKeyPair) {
            privateKey = converter.getPrivateKey(((org.bouncycastle.openssl.PEMKeyPair) object).getPrivateKeyInfo());
        } else {
            throw new Exception("Unexpected private key format");
        }
        pemParser.close();

        // Convert to ECPrivateKey
        KeyFactory keyFactory = KeyFactory.getInstance("EC");
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());
        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);

        // create JWT
        JWTClaimsSet.Builder claimsSetBuilder = new JWTClaimsSet.Builder();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            claimsSetBuilder.claim(entry.getKey(), entry.getValue());
        }
        JWTClaimsSet claimsSet = claimsSetBuilder.build();

        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.ES256).customParams(header).build();
        SignedJWT signedJWT = new SignedJWT(jwsHeader, claimsSet);

        JWSSigner signer = new ECDSASigner(ecPrivateKey);
        signedJWT.sign(signer);

        String sJWT = signedJWT.serialize();
        System.out.println(sJWT);
    }
}
```

</TabItem>
<TabItem value="cpp" label="C++">

1. Install C++ project dependencies like so:

   ```
   apt-get update
   apt-get install libcurlpp-dev libssl-dev
   git clone https://github.com/Thalhammer/jwt-cpp
   cd jwt-cpp
   mkdir build && cd build
   cmake ..
   make
   make install
   ```

2. After you've saved your code to a file name, for example main.cpp, compile the program:

   ```
   g++ main.cpp -o myapp -lcurlpp -lcurl -lssl -lcrypto -I/usr/local/include -L/usr/local/lib -ljwt -std=c++17
   ```

3. Capture and export the JWT output from your C++ application to an environment variable:

   ```
   export JWT=$(./myapp)
   ```

4. Make an API Request, for example:

   ```
   curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
   ```

<br />

> Code Snippet

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <jwt-cpp/jwt.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/pem.h>
#include <openssl/rand.h>

std::string create_jwt() {
    // Set request parameters
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";
    std::string request_method = "GET";
    std::string url = "api.coinbase.com";
    std::string request_path = "/api/v3/brokerage/accounts";
    std::string uri = request_method + " " + url + request_path;

    // Generate a random nonce
    unsigned char nonce_raw[16];
    RAND_bytes(nonce_raw, sizeof(nonce_raw));
    std::string nonce(reinterpret_cast<char*>(nonce_raw), sizeof(nonce_raw));

    // Create JWT token
    auto token = jwt::create()
        .set_subject(key_name)
        .set_issuer("cdp")
        .set_not_before(std::chrono::system_clock::now())
        .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{120})
        .set_payload_claim("uri", jwt::claim(uri))
        .set_header_claim("kid", jwt::claim(key_name))
        .set_header_claim("nonce", jwt::claim(nonce))
        .sign(jwt::algorithm::es256(key_name, key_secret));

    return token;
};

int main() {
    try {
        std::string token = create_jwt();
        std::cout << "Generated JWT Token: " << token << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
};
```

</TabItem>
<TabItem value="typescript" label="TypeScript">
1. Install the JSON Web Token and TypeScript dependencies:

    ```bash
    npm install jsonwebtoken
    npm install @types/jsonwebtoken
    npm install -g typescript
    ```

2. Create a TypeScript file named `main.ts` and add the following code:

    ```typescript
    import * as jwt from 'jsonwebtoken';
    import * as crypto from 'crypto';

    const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
    const keySecret = `-----BEGIN EC PRIVATE KEY-----
    YOUR PRIVATE KEY
    -----END EC PRIVATE KEY-----`;
    const requestMethod = 'GET';
    const requestHost = 'api.coinbase.com';
    const requestPath = '/api/v3/brokerage/accounts';
    const algorithm = 'ES256';

    const uri = `${requestMethod} ${requestHost}${requestPath}`;

    const generateJWT = (): string => {
      const payload = {
        iss: 'cdp',
        nbf: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 120,
        sub: keyName,
        uri,
      };

      const header = {
        alg: algorithm,
        kid: keyName,
        nonce: crypto.randomBytes(16).toString('hex'),
      };

      return jwt.sign(payload, keySecret, { algorithm, header });
    };

    const main = () => {
      const token = generateJWT();
      console.log(token);
    };

    main();
    ```

3. Compile the TypeScript file to JavaScript:

    ```bash
    tsc main.ts
    ```

    This will generate a `main.js` file.

4. Run the generated JavaScript file:

    ```bash
    node main.js
    ```

5. Set the JWT to the output, or export the JWT to the environment with:

    ```bash
    export JWT=$(node main.js)
    ```

6. Make your request, example:

    ```bash
    curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
    ```


> Code Snippet

```typescript
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----`;
const requestMethod = 'GET';
const requestHost = 'api.coinbase.com';
const requestPath = '/api/v3/brokerage/accounts';
const algorithm = 'ES256';

const uri = `${requestMethod} ${requestHost}${requestPath}`;

const generateJWT = (): string => {
  const payload = {
    iss: 'cdp',
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: keyName,
    uri,
  };

  const header = {
    alg: algorithm,
    kid: keyName,
    nonce: crypto.randomBytes(16).toString('hex'),
  };

  return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
  const token = generateJWT();
  console.log(token);
};

main();
```

</TabItem>
<TabItem value="dotnet" label="C#">

### .NET 6.0

1. Create a new console project by running the following command:

    ```
    dotnet new console
    ```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.


3.  Install C# project dependencies like so:

        ```
        dotnet add package Microsoft.IdentityModel.Tokens
        dotnet add package System.IdentityModel.Tokens.Jwt
        dotnet add package Jose-JWT
        ```

4.  Build the project by running the following command:

    ```
    dotnet build
    ```

5.  Run the project by running the following command:

    ```
    dotnet run
    ```

<br />

> Code Snippet

```dotnet
// Environment is .NET 6.0 C#

using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using Jose;

namespace JwtTest {
    internal class Program {

        static Random random = new Random();

        static void Main(string[] args) {

            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string key = parseKey(cbPrivateKey);
            string endpoint = "api.coinbase.com/api/v3/brokerage/accounts";
            string token = generateToken(name, key, $"GET {endpoint}");

            Console.WriteLine($"Token is valid? {isTokenValid(token, name, key)}");
            Console.WriteLine("Call API...");
            Console.WriteLine(CallApiGET($"https://{endpoint}", token));

        }


        static string generateToken(string name, string secret, string uri) {
             var privateKeyBytes = Convert.FromBase64String(secret); // Assuming PEM is base64 encoded
             using var key = ECDsa.Create();
             key.ImportECPrivateKey(privateKeyBytes, out _);

             var payload = new Dictionary<string, object>
             {
                 { "sub", name },
                 { "iss", "coinbase-cloud" },
                 { "nbf", Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "exp", Convert.ToInt64((DateTime.UtcNow.AddMinutes(1) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "uri", uri }
             };

             var extraHeaders = new Dictionary<string, object>
             {
                 { "kid", name },
                 // add nonce to prevent replay attacks with a random 10 digit number
                 { "nonce", randomHex(10) },
                 { "typ", "JWT"}
             };

             var encodedToken = JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

            // print token
            Console.WriteLine(encodedToken);
            return encodedToken;
        }

        static bool isTokenValid(string token, string tokenId, string secret) {
            if (token == null)
                return false;

            var key = ECDsa.Create();
            key?.ImportECPrivateKey(Convert.FromBase64String(secret), out _);

            var securityKey = new ECDsaSecurityKey(key) { KeyId = tokenId };

            try {
                var tokenHandler = new JwtSecurityTokenHandler();
                tokenHandler.ValidateToken(token, new TokenValidationParameters {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = securityKey,
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ClockSkew = TimeSpan.Zero
                }, out var validatedToken);

                return true;
            } catch {
                return false;
            }
        }

        static string parseKey(string key) {
            List<string> keyLines = new List<string>();
            keyLines.AddRange(key.Split('\n', StringSplitOptions.RemoveEmptyEntries));

            keyLines.RemoveAt(0);
            keyLines.RemoveAt(keyLines.Count - 1);

            return String.Join("", keyLines);
        }


        static string randomHex(int digits) {
            byte[] buffer = new byte[digits / 2];
            random.NextBytes(buffer);
            string result = String.Concat(buffer.Select(x => x.ToString("X2")).ToArray());
            if (digits % 2 == 0)
                return result;
            return result + random.Next(16).ToString("X");
        }

        static string CallApiGET(string url, string bearerToken = "") {
           using (var client = new HttpClient()) {

                using (var request = new  HttpRequestMessage(HttpMethod.Get, url)) {
                    if (bearerToken != "")
                        request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", bearerToken);
                    var response = client.Send(request);

                    if (response != null)
                        return response.Content.ReadAsStringAsync().Result;
                    else
                        return "";

                }
           }
        }
    }
}
```

### .NET 4.7.2

1. Create a new console project by running the following command:

    ```
    dotnet new console
    ```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.

3.  Install C# project dependencies like so:

        ```
        dotnet add package Microsoft.IdentityModel.Tokens
        dotnet add package System.IdentityModel.Tokens.Jwt
        dotnet add package Jose-JWT
        ```

4.  Build the project by running the following command:

    ```
    dotnet add package System.IdentityModel.Tokens.Jwt
    dotnet add package BouncyCastle.NetCore
    dotnet add package Microsoft.IdentityModel.Tokens
    dotnet add package System.Net.Http
    ```

5.  Run the project by running the following command:

    ```
    dotnet run
    ```

<br />

> Code Snippet

```dotnet
// Environment is .NET 4.7.2
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Net.Http;
using System.Security.Cryptography;
using Microsoft.IdentityModel.Tokens;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;
using System.IO;

namespace JwtTest
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string endpoint = "api.coinbase.com/api/v3/brokerage/products";
            string token = GenerateToken(name, cbPrivateKey, $"GET {endpoint}");

            Console.WriteLine($"Generated Token: {token}");
            Console.WriteLine("Calling API...");
            Console.WriteLine(CallApiGET($"https://{endpoint}", token));
        }

        static string GenerateToken(string name, string privateKeyPem, string uri)
        {
            // Load EC private key using BouncyCastle
            var ecPrivateKey = LoadEcPrivateKeyFromPem(privateKeyPem);

            // Create security key from the manually created ECDsa
            var ecdsa = GetECDsaFromPrivateKey(ecPrivateKey);
            var securityKey = new ECDsaSecurityKey(ecdsa);

            // Signing credentials
            var credentials = new SigningCredentials(securityKey, SecurityAlgorithms.EcdsaSha256);

            var now = DateTimeOffset.UtcNow;

            // Header and payload
            var header = new JwtHeader(credentials);
            header["kid"] = name;
            header["nonce"] = GenerateNonce(); // Generate dynamic nonce

            var payload = new JwtPayload
            {
                { "iss", "coinbase-cloud" },
                { "sub", name },
                { "nbf", now.ToUnixTimeSeconds() },
                { "exp", now.AddMinutes(2).ToUnixTimeSeconds() },
                { "uri", uri }
            };

            var token = new JwtSecurityToken(header, payload);

            var tokenHandler = new JwtSecurityTokenHandler();
            return tokenHandler.WriteToken(token);
        }

        // Method to generate a dynamic nonce
        static string GenerateNonce(int length = 64)
        {
            byte[] nonceBytes = new byte[length / 2]; // Allocate enough space for the desired length (in hex characters)
            using (var rng = RandomNumberGenerator.Create())
            {
                rng.GetBytes(nonceBytes);
            }
            return BitConverter.ToString(nonceBytes).Replace("-", "").ToLower(); // Convert byte array to hex string
        }

        // Method to load EC private key from PEM using BouncyCastle
        static ECPrivateKeyParameters LoadEcPrivateKeyFromPem(string privateKeyPem)
        {
            using (var stringReader = new StringReader(privateKeyPem))
            {
                var pemReader = new PemReader(stringReader);
                var keyPair = pemReader.ReadObject() as AsymmetricCipherKeyPair;
                if (keyPair == null)
                    throw new InvalidOperationException("Failed to load EC private key from PEM");

                return (ECPrivateKeyParameters)keyPair.Private;
            }
        }

        // Method to convert ECPrivateKeyParameters to ECDsa
        static ECDsa GetECDsaFromPrivateKey(ECPrivateKeyParameters privateKey)
        {
            var q = privateKey.Parameters.G.Multiply(privateKey.D).Normalize();
            var qx = q.AffineXCoord.GetEncoded();
            var qy = q.AffineYCoord.GetEncoded();

            var ecdsaParams = new ECParameters
            {
                Curve = ECCurve.NamedCurves.nistP256, // Adjust if you're using a different curve
                Q =
                {
                    X = qx,
                    Y = qy
                },
                D = privateKey.D.ToByteArrayUnsigned()
            };

            return ECDsa.Create(ecdsaParams);
        }

        // Method to call the API with a GET request
        static string CallApiGET(string url, string bearerToken = "")
        {
            using (var client = new HttpClient())
            {
                using (var request = new HttpRequestMessage(HttpMethod.Get, url))
                {
                    if (!string.IsNullOrEmpty(bearerToken))
                        request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", bearerToken);
                    var response = client.SendAsync(request).Result;

                    if (response != null)
                        return response.Content.ReadAsStringAsync().Result;
                    else
                        return "";
                }
            }
        }
    }
}

```

</TabItem>

<TabItem value="Ruby" label="Ruby">

1. Install dependencies `JWT` and `OpenSSL`.

   ```
   gem install JWT
   gem install OpenSSL
   ```

2. In the console, run: `ruby main.rb` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(ruby main.rb)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```ruby
require 'jwt'
require 'openssl'
require 'time'
require 'securerandom'

Key_name = "organizations/{org_id}/apiKeys/{key_id}"
Key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

request_method = "GET"
request_host   = "api.coinbase.com"
request_path = "/api/v3/brokerage/accounts"


def build_jwt(uri)
    header = {
      typ: 'JWT',
      kid: Key_name,
      nonce: SecureRandom.hex(16)
    }

    claims = {
      sub: Key_name,
      iss: 'cdp',
      aud: ['cdp_service'],
      nbf: Time.now.to_i,
      exp: Time.now.to_i + 120, # Expiration time: 2 minute from now.
      uri: uri
    }

    private_key = OpenSSL::PKey::read(Key_secret)
    JWT.encode(claims, private_key, 'ES256', header)
  end


token = build_jwt("#{request_method.upcase} #{request_host}#{request_path}")
puts token
```

</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/rest-api-auth-legacy.mdx -->

---
title: "Advanced Trade API Legacy Key Authentication"
sidebar_label: "Legacy Keys"
slug: "rest-api-auth-legacy"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

You can create and activate new API keys in your [API settings](https://coinbase.com/settings/api).
Please note, legacy API key authentication is supported for both Advanced Trade and Coinbase App APIs for existing keys. You can no longer create new keys using legacy process.

Legacy API keys are for individuals or applications for individual use. They can be used with Advanced REST APIs & WebSocket channels (except new features).

## Signing Requests

All Advanced Trade REST API requests with legacy API keys must contain the following headers:

| Header                | Description                                           |
|:----------------------|:------------------------------------------------------|
| `CB-ACCESS-KEY`       | API key as a string (that you create on coinbase.com) |
| `CB-ACCESS-SIGN`      | Encoded signature using API secret                    |
| `CB-ACCESS-TIMESTAMP` | Timestamp for your request                            |

:::tip
Advanced Trade **does not** require a `PASSPHRASE` as did Coinbase Pro.
:::


### Creating a Signature

1. Create a signature string by concatenating the values of these query parameters with the `+` operator: `timestamp + method + requestPath + body`.

    - `timestamp` is the same as the `CB-ACCESS-TIMESTAMP` header (+/-30 seconds)
    - `method` should be UPPER CASE
    - `requestPath` is the full path (minus the base URL and query parameters), for example:
        - `/api/v3/brokerage/orders/historical/fills`
        - `/api/v3/brokerage/products/BTC-USD/ticker`
    - `body` is the request body string -- it is omitted if there is no request body (typically for` GET` requests)

2. Create a sha256 HMAC object with your API secret on the signature string.
3. Get the hexadecimal string representation of the sha256 HMAC object and pass that in as the `CB-ACCESS-SIGN` header.

:::caution lowercase signature
A signature must be in lowercase letters or the program throws a 401 error.
:::

### Signature Code Samples

The following examples demonstrate how to generate a signature in Python, Ruby, and JavaScript:

<Tabs>
<TabItem value="python" label="Python">

```python
import json, hmac, hashlib, time, base64
#timestamp = str(int(time.time())) 
#request.method = GET or POST
#request.path_url.split('?')[0] = /api/v3/brokerage/orders/historical/batch
message = timestamp + request.method + request.path_url.split('?')[0] + str(request.body or '')
signature = hmac.new(secretKey.encode('utf-8'), message.encode('utf-8'), digestmod=hashlib.sha256).digest()
print(signature.hex(), ts)
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
timestamp = Time.now.to_i
payload = "#{timestamp}#{method}#{request_path}#{body}";
# create a sha256 hmac with the secret
signature = OpenSSL::HMAC.hexdigest('sha256', secret, payload)
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```js
const CryptoJS = require('crypto-js');
function sign(str, secret) {
  const hash = CryptoJS.HmacSHA256(str, secret);
  return hash.toString();
}
const timestamp = Math.floor(Date.now() / 1000).toString();
const str = timestamp + req.Method + req.Path + req.Body 
const sig = sign(str, apiSecret)
```

</TabItem>
</Tabs>

:::tip
The Advanced Trade `requestPath` should only include the path of the API endpoint in the string for hashing. It should _not_ include the base URL (protocol and domain) _nor_ any query parameters. By contrast, the Coinbase App `requestPath` does include query parameters. 
:::

| API                 | `requestPath`               | Valid Example                               |
|:--------------------|:----------------------------|:--------------------------------------------|
| Advanced (v3)       | API endpoint                | `/api/v3/brokerage/products/BTC-USD/ticker` |
| [Coinbase App (v2)](/coinbase-app/docs/api-key-authentication#creating-a-signature) | API endpoint + query params | `/v2/exchange-rates?currency=USD` |


## Making Requests

All private API requests must include CB-ACCESS-* headers:

1. Set a timestamp for the `CB-ACCESS-TIMESTAMP` header.
2. Create an encoded signature as the `CB-ACCESS-SIGN` header (with the API secret).
3. Set your legacy API key for the `CB-ACCESS-KEY` header.
4. Apply the headers to the request. You are ready to send.

### Example Request

```shell
curl https://api.coinbase.com/v3/brokerage/accounts \
  --header "CB-ACCESS-KEY: <your api key>" \
  --header "CB-ACCESS-SIGN: <the user generated message signature>" \
  --header "CB-ACCESS-TIMESTAMP: <a timestamp for your request>"
```

All requests should have content type `application/json` and the body must be valid JSON.

```ruby
# Ruby code sample of a GET Request to product ticker

require 'uri'
require 'net/http'
require 'openssl'
 
url = URI("https://coinbase.com/api/v3/brokerage/products/BTC-USD/ticker?limit=3")
request_path= "/api/v3/brokerage/products/BTC-USD/ticker"
body = ""
method = "GET"
 
timestamp = Time.now.to_i
payload = "#{timestamp}#{method}#{request_path}#{body}"
# create a sha256 hmac with the secret
signature = OpenSSL::HMAC.hexdigest('sha256', $SECRET_KEY, payload)
 
http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true
 
request = Net::HTTP::Get.new(url)
request["accept"] = 'application/json'
request["CB-ACCESS-KEY"] = $ACCESS_KEY
request["CB-ACCESS-SIGN"] = signature
request["CB-ACCESS-TIMESTAMP"] = timestamp
 
response = http.request(request)
puts response.read_body
``` 



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/rest-api-postman.mdx -->

---
title: "Advanced Trade Postman Files"
sidebar_label: "Postman Files"
slug: "rest-api-postman"
hide_table_of_contents: false
---

The following Postman collection and environment files are available for download. 

- <a href="/downloads/advanced-trade/coinbase_advanced_trading.postman_collection.json" download target="blank">Coinbase Developer Platform Advanced Trade Postman Collection</a>
- <a href="/downloads/advanced-trade/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> 

We recommend testing authentication and relevant endpoints with these files as this will help our team troubleshoot any problems. 

:::info
Coinbase Cloud is in the process of being rebranded as Coinbase Developer Platform (CDP). Some documentation and naming conventions may still reflect the old branding.
:::

## Coinbase Developer Platform Collection

### Step 1: Download Postman

If don't have Postman installed, download and install [Postman](https://www.postman.com/downloads/) from their website.

### Step 2: Download and Import Files

1. **Download Collection:**
    - Download the <a href="/downloads/advanced-trade/coinbase_advanced_trading.postman_collection.json" download target="blank">Coinbase Developer Platform Advanced Trade Postman Collection</a>

2. **Import Collection into Postman:**
    - Open Postman.
    - Click on **Import** in the upper left corner.
    - Select the downloaded JSON file and import it.

### Step 3: Configure Environment Variables

Once the files are imported, you need to configure your environment variables.

1. **Download Postman Environemnt:**
   - <a href="/downloads/advanced-trade/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> 
2. **Import Environment into Postman:**
    - Open Postman.
    - Click on **Import** in the upper left corner.
    - Select the downloaded JSON file and import it.

3. **Select the Environment:**
   - In Postman, click on the environment dropdown near the top right of the screen and select "Coinbase Developer Platform Postman Environment".

4. **Set Up Variables:**
   - Click the Environments tab under My Workspace on the left of the screen
   - Select the "Coinbase Developer Platform Postman Environment".
   - Configure the following variables: <br /><br />

   | Variable     | Current value                                                                             |
   | ------------ | ----------------------------------------------------------------------------------------- |
   | `name`       | `"organizations/{ORG_ID}/apiKeys/{KEY_ID}"` (Include quotes)                              |
   | `privateKey` | `"-----BEGIN EC PRIVATE KEY-----\{KEY}\n-----END EC PRIVATE KEY-----\n"` (Include quotes) |

   :::note
   Ensure that the values are entered exactly as shown, including the quotes.
   :::

### Step 4: Authenticate and Test Endpoints

1. **Send Requests:**
   - Navigate to the "Collections" tab in Postman.
   - Expand the "Coinbase Developer Platform Postman Collection".
   - Select any request and click **Send** to test the endpoint.

2. **Check Responses:**
    - Ensure that the responses are as expected.
    - If you encounter any issues, refer to the detailed response messages to understand the problem.

### Important Notes

:::caution Confirm Environment
Make sure the correct environment is selected by checking the check mark to the right of the environment name in Postman.



<!-- File: /Users/tinahe/docs/projects/advanced-trade/docs/_snippet-cdp-auth-generating-jwt.mdx -->

Regardless of which [code snippet](#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
2. Replace the request method and path you want to test. If the URI has a UUID in the path, include that UUID here, e.g., `/api/v3/brokerage/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9`.
3. Run the generation script that prints the command `export JWT=...`.
4. Run the generated command to save your JWT. 

  :::caution
  Your JWT expires after 2 minutes, after which all requests are unauthenticated.
  :::

  :::caution
  You must generate a different JWT for each unique API request.
  :::


<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-accounts.mdx -->

---
title: "Wallet API: Accounts (Deprecated)"
sidebar_label: "Accounts"
slug: "api-accounts"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::announcement Deprecated Select Wallet and Account APIs on Feb 15
On February 15, 2024, the following Coinbase App v2 APIs were deprecated:  

- [Create Wallet](#create-wallet-deprecated)
- [Update Account](#update-account-deprecated)
- [Delete Account](#delete-account-deprecated)

Available workarounds: 

- To create a new wallet, transact with the currency on [Coinbase](https://www.coinbase.com/) or via [Coinbase App Transaction APIs](./api-transactions.mdx).
- To change the name of a wallet, contact [Coinbase Support](https://help.coinbase.com/en/contact-us).
- To close your account, visit your [Coinbase Account profile](https://accounts.coinbase.com/profile).
:::


## Table of Endpoints

| Name                                | Method | Endpoint                   | Legacy Scope             | CDP API Key Scope         |
|:------------------------------------|:-------|:---------------------------|:-------------------------|:----------------------------|
| [Create Wallet](#create-wallet-deprecated)    | GET    | `/v2/accounts/{asset-id}`  | `wallet:accounts:create` | Not supported (deprecated)  |
| [List Accounts](#list-accounts)     | GET    | `/v2/accounts`             | `wallet:accounts:read`   | `view`                      |
| [Show Account](#show-account)       | GET    | `/v2/accounts/:account_id` | `wallet:accounts:read`   | `view`                      |
| [Update Account](#update-account-deprecated)  | PUT    | `/v2/accounts/:account_id` | `wallet:accounts:update` | Not supported (deprecated)  |                        
| [Delete Account](#delete-account-deprecated)   | DELETE | `/v2/accounts/:account_id` | `wallet:accounts:delete` | Not supported (deprecated)  |                        


## Overview

The **Account resource** represents all of a user's accounts, including cryptocurrency wallets, fiat currency accounts, and vaults. This is represented in the `type` field. New types may be added in the future, so make sure this won't break your implementation.

User can only have one primary account and its type can only be `wallet`.

| Parameter                                 | Description                                             |
|:------------------------------------------|:--------------------------------------------------------|
| `id` _string_                             | Resource ID                                             |
| `name` _string_                           | User or system defined name                             |
| `primary` _boolean_                       | Primary account (or not)                                |
| `type` _string, enumerable_               | Account's type. Valid values: `wallet`, `fiat`, `vault` |
| `currency` _hash_                       | Account's currency                                      |
| `balance` _money hash_                    | Crypto balance                                          |
| `created_at` _timestamp_                  |                                                         |
| `updated_at` _timestamp_                  |                                                         |
| `resource` _string, constant **account**_ |                                                         |
| `resource_path` _string_                  |                                                         |

#### Account Resource

```json
{
  "id": "2bbf394c-193b-5b2a-9155-3b4732659ede",
  "name": "My Wallet",
  "primary": true,
  "type": "wallet",
  "currency" : {
      "address_regex" : "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
      "asset_id" : "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
      "code" : "BTC",
      "color" : "#F7931A",
      "exponent" : 8,
      "name" : "Bitcoin",
      "slug" : "bitcoin",
      "sort_index" : 100,
      "type" : "crypto"
  }
  "balance": {
      "amount": "39.59000000",
      "currency": "BTC"
  },
  "created_at": "2024-01-31T20:49:02Z",
  "updated_at": "2024-01-31T20:49:02Z",
  "resource": "account",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede"
}
```


## Create Wallet (Deprecated)

Create new wallet.

### HTTP request

`GET https://api.coinbase.com/v2/accounts/{asset-id}`

### Scopes

- `wallet:accounts:create`

### Examples

#### Request 

```
curl --location --request GET 'https://api.coinbase.com/v2/accounts/LTC' \
--header 'CB-ACCESS-KEY:<key>' \
--header 'CB-ACCESS-SIGN: <hash>' \
--header 'CB-ACCESS-TIMESTAMP: 1665694716' \
--header 'CB-VERSION: 2022-05-07' 
```

#### Response (200)

```
{
  "data": {
    "id": "f5d0397a-0e0b-5c00-8fcc-b5e9fea21b0b",
    "name": "LTC Wallet",
    "primary": true,
    "type": "wallet",
    "currency": {
      "code": "LTC",
      "name": "Litecoin",
      "color": "#A6A9AA",
      "sort_index": 104,
      "exponent": 8,
      "type": "crypto",
      "address_regex": "^((L|M)[a-km-zA-HJ-NP-Z1-9]{25,34})|^(ltc1([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{39}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{59}))$",
      "asset_id": "c9c24c6e-c045-5fde-98a2-00ea7f520437",
      "slug": "litecoin"
    },
    "balance": {
      "amount": "0.00000000",
      "currency": "LTC"
    },
    "created_at": "2022-10-13T21:07:04Z",
    "updated_at": "2022-10-13T21:07:04Z",
    "resource": "account",
    "resource_path": "/v2/accounts/f5d0397a-0e0b-5c00-8fcc-b5e9fea21b0b",
    "allow_deposits": true,
    "allow_withdrawals": true
  }
}
```


## List Accounts

List a current user's accounts to which the authentication method has access to.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts`

### Scopes

- `wallet:accounts:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

accounts = client.accounts
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

accounts = client.get_accounts()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccounts({}, function(err, accounts) {
  console.log(accounts);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "58542935-67b5-56e1-a3f9-42686e07fa40",
      "name": "My Vault",
      "primary": false,
      "type": "vault",
      "currency" : {
         "address_regex" : "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
         "asset_id" : "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
         "code" : "BTC",
         "color" : "#F7931A",
         "exponent" : 8,
         "name" : "Bitcoin",
         "slug" : "bitcoin",
         "sort_index" : 100,
         "type" : "crypto"
      }
      "balance": {
        "amount": "4.00000000",
        "currency": "BTC"
      },
      "created_at": "2024-01-31T20:49:02Z",
      "updated_at": "2024-01-31T20:49:02Z",
      "resource": "account",
      "resource_path": "/v2/accounts/58542935-67b5-56e1-a3f9-42686e07fa40",
      "ready": true
    },
    {
      "id": "2bbf394c-193b-5b2a-9155-3b4732659ede",
      "name": "My Wallet",
      "primary": true,
      "type": "wallet",
      "currency" : {
         "address_regex" : "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
         "asset_id" : "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
         "code" : "BTC",
         "color" : "#F7931A",
         "exponent" : 8,
         "name" : "Bitcoin",
         "slug" : "bitcoin",
         "sort_index" : 100,
         "type" : "crypto"
      }
      "balance": {
        "amount": "39.59000000",
        "currency": "BTC"
      },
      "created_at": "2024-01-31T20:49:02Z",
      "updated_at": "2024-01-31T20:49:02Z",
      "resource": "account",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede"
    }
  ]
}
```


## Show Account

Show (or get) a current user's account. To access the primary account for a given currency, a currency string (e.g., `BTC` or `ETH`) can be used instead of the account ID in the URL.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id`

### Scopes

- `wallet:accounts:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede \
    -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

account = client.account("2bbf394c-193b-5b2a-9155-3b4732659ede")
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

account = client.get_account("2bbf394c-193b-5b2a-9155-3b4732659ede")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount("2bbf394c-193b-5b2a-9155-3b4732659ede", function(err, account) {
  console.log(account);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "2bbf394c-193b-5b2a-9155-3b4732659ede",
    "name": "My Wallet",
    "primary": true,
    "type": "wallet",
      "currency" : {
         "address_regex" : "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
         "asset_id" : "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
         "code" : "BTC",
         "color" : "#F7931A",
         "exponent" : 8,
         "name" : "Bitcoin",
         "slug" : "bitcoin",
         "sort_index" : 100,
         "type" : "crypto"
      }
    "balance": {
      "amount": "39.59000000",
      "currency": "BTC"
    },
    "created_at": "2024-01-31T20:49:02Z",
    "updated_at": "2024-01-31T20:49:02Z",
    "resource": "account",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede"
  }
}
```


## Update Account (Deprecated)

Modify a user's account.

### HTTP Request

`PUT https://api.coinbase.com/v2/accounts/:account_id`

### Scopes

- `wallet:accounts:update`

### Arguments

| Parameter | Type   | Required | Description  | 
|:----------|:-------|:---------|:-------------|
| name      | string | Optional | Account name |

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b \
  -X PUT
  -H 'Content-Type: application/json'
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
  -d '{"name": "New account name"}'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

account = client.update_account('82de7fcd-db72-5085-8ceb-bee19303080b',
                                {name: 'New account name'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

account = client.update_account('82de7fcd-db72-5085-8ceb-bee19303080b',
                                name='New account name')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.update({'name': 'New account name'}, function(err, acct) {
    console.log(acct);
  });
});
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "data": {
    "id": "82de7fcd-db72-5085-8ceb-bee19303080b",
    "name": "New account name",
    "primary": false,
    "type": "wallet",
      "currency" : {
         "address_regex" : "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
         "asset_id" : "5b71fc48-3dd3-540c-809b-f8c94d0e68b5",
         "code" : "BTC",
         "color" : "#F7931A",
         "exponent" : 8,
         "name" : "Bitcoin",
         "slug" : "bitcoin",
         "sort_index" : 100,
         "type" : "crypto"
      }
    "balance": {
      "amount": "0.00000000",
      "currency": "BTC"
    },
    "created_at": "2023-03-31T15:21:58-07:00",
    "updated_at": "2023-03-31T15:21:58-07:00",
    "resource": "account",
    "resource_path": "/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b"
  }
}
```


## Delete Account (Deprecated)

Remove a user's account. You cannot remove:

- Primary accounts
- Accounts with non-zero balance
- Fiat accounts
- Vaults with a pending withdrawal

### HTTP Request

`DELETE https://api.coinbase.com/v2/accounts/:account_id`

### Scopes

- `wallet:accounts:delete`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b \
  -X DELETE
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

account = client.delete_account('82de7fcd-db72-5085-8ceb-bee19303080b')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

account = client.delete_account('82de7fcd-db72-5085-8ceb-bee19303080b')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.delete(function(err, resp) {
    console.log(resp);
  });
});
```

</TabItem>
</Tabs>

#### Response (204 No Content)



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-sells.mdx -->

---
title: "Wallet API: Sells (Deprecated)"
sidebar_label: "Sells (Deprecated)"
slug: "api-sells"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::announcement Deprecated Buys & Sells APIs on Nov 30, 2023
On November 30, 2023, the Coinbase App v2 **[Buys](./api-buys.mdx)** and **Sells** APIs were deprecated.

- To create new buys/sells, use v3 [Advanced Trade APIs](/advanced-trade/docs/welcome). <br />
- To view existing orders, use v2 [Coinbase App Transaction API](./api-transactions.mdx).

| Deprecated API                                                                                         |                                                                                               | Recommended API                                                        |
| :----------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| [Place Buy Order](./api-buys.mdx#place-buy-order) / [Place Sell Order](./api-sells.mdx#place-sell-order) | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [Create Order](/advanced-trade/reference/retailbrokerageapi_postorder) |
| [List Buys](./api-buys.mdx#list-buys) / [List Sells](./api-sells.mdx#list-sells)                         | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [List Transactions](./api-transactions.mdx#list-transactions)           |
| [Show Buy](./api-buys.mdx#show-buy) / [Show Sell](./api-sells.mdx#show-sell)                             | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [Show Transaction](./api-transactions.mdx#show-transaction)             |

**Note**: To expand all available resources, pass `expand=all`.

- cURL example: `https://api.coinbase.com/v2/accounts/{AccountId}/transactions?expand[]=sell&expand[]=buy`
- Replace `AccountId` with your real Account ID to retrieve the fees.
  :::

## Table of Endpoints

| Name                                  | Method | Endpoint                                         | Scope                 |
| :------------------------------------ | :----- | :----------------------------------------------- | :-------------------- |
| [Place Sell Order](#place-sell-order) | POST   | `/v2/accounts/:account_id/sells/:sell_id/commit` | `wallet:sells:create` |
| [Commit Sell](#commit-sell)           | POST   | `/v2/accounts/:account_id/sells/:sell_id/commit` | `wallet:sells:create` |
| [List Sells](#list-sells)             | GET    | `/v2/accounts/:account_id/sells`                 | `wallet:sells:read`   |
| [Show Sell](#show-sell)               | GET    | `/v2/accounts/:account_id/sells/:sell_id`        | `wallet:sells:read`   |

## Overview

The **Sell resource** represents any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto) using a payment method (either a bank or a fiat account). Each committed sell also has an associated transaction.

Sells can be started with `commit: false` which is useful when displaying the confirmation for a sell. These sells will never complete and receive an associated transaction unless they are committed separately.

| Parameter                              | Description                                                                                      |
| :------------------------------------- | :----------------------------------------------------------------------------------------------- |
| `id` _string_                          | Resource ID                                                                                      |
| `status` _string, enumerable_          | Status of the sell. Valid values: `created`, `completed`, `canceled`                             |
| `payment_method` _hash_                | Associated payment method (e.g., a bank, fiat account)                                           |
| `transaction` _hash_                   | Associated transaction (e.g., a bank, fiat account)                                              |
| `amount` _money hash_                  | Amount of any supported asset                                                                    |
| `total` _money hash_                   | Fiat amount with fees                                                                            |
| `subtotal` _money hash_                | Fiat amount without fees                                                                         |
| `fee` _money hash_                     | Fees associated to this sell                                                                     |
| `created_at` _timestamp_               |                                                                                                  |
| `updated_at` _timestamp_               |                                                                                                  |
| `resource` _string, constant **sell**_ |                                                                                                  |
| `resource_path` _string_               |                                                                                                  |
| `committed` _boolean_                  | Has this sell been committed?                                                                    |
| `instant` _boolean_                    | Was this sell executed instantly?                                                                |
| `payout_at` _timestamp, optional_      | When a sell isn't executed instantly, it receives a payout date for the time it will be executed |

#### Example Sell Resource

```json
{
  "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
  "status": "completed",
  "payment_method": {
    "id": "83562370-3e5c-51db-87da-752af5ab9559",
    "resource": "payment_method",
    "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
  },
  "transaction": {
    "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
  },
  "amount": {
    "amount": "1.00000000",
    "currency": "BTC"
  },
  "total": {
    "amount": "9.75",
    "currency": "USD"
  },
  "subtotal": {
    "amount": "9.90",
    "currency": "USD"
  },
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-02-11T16:54:02-08:00",
  "resource": "sell",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells/67e0eaec-07d7-54c4-a72c-2e92826897df",
  "committed": true,
  "instant": false,
  "fee": {
    "amount": "0.15",
    "currency": "USD"
  },
  "payout_at": "2015-02-18T16:54:00-08:00"
}
```

## Place Sell Order

Sells a user-defined amount of any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto).

You can define sell amounts with either the `amount` or `total` parameter:

- `amount` sells the amount in the defined asset. It's recommended that you use a cryptocurrency as the `currency` value, but if you specify a fiat currency, the amount is converted.

- `total` credits the defined total value, and after fees are taken out, sells the remaining amount of the defined asset. It's recommended that you use the currency of the payment method as the currency parameter, but if you specify a different currency, the amount is converted.

Given the price of digital currency depends on the time of the call and amount of the sell, it's recommended to use the `commit: false` parameter to create an uncommitted sell to get a quote and then to commit that with a separate request.

If you need to query the sell price without locking in the sell, you can use `quote: true` option. This returns an unsaved sell and unlike `commit: false`, this sell can't be completed. This option is useful when you need to show the detailed sell price quote for the user when they are filling a form or similar situation.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/sells`

### Scopes

- `wallet:sells:create`

### Arguments

| Parameter                 | Type    | Required | Description                                                                                                          |
| :------------------------ | :------ | :------- | :------------------------------------------------------------------------------------------------------------------- |
| `amount`                  | string  | Required | Sell amount                                                                                                          |
| `total`                   | string  | Optional | Sell amount with fees (alternative to `amount`)                                                                      |
| `currency`                | string  | Required | Currency for the `amount`                                                                                            |
| `payment_method`          | string  | Optional | ID of the payment method for the sell. Payment methods can be listed using the `GET /payment-methods` API call       |
| `agree_btc_amount_varies` | boolean | Optional | Whether or not you would still like to sell if you have to wait for your money to arrive to lock in a price          |
| `commit`                  | boolean | Optional | If `false`, this sell will not be immediately completed. Use the `commit` call to complete it. Default value: `true` |
| `quote`                   | boolean | Optional | If `true`, response will return an unsave sell for detailed price quote. Default value: `false`                      |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/sells /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{
    "amount": "10",
    "currency": "BTC",
    "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"
  }'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

sell = client.sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                   {"amount" => "10",
                    "currency" => "BTC",
                    "payment_method" => "83562370-3e5c-51db-87da-752af5ab9559"})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

sell = client.sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                   amount="10",
                   currency="BTC",
                   payment_method="83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.sell(
      {
        amount: "10",
        currency: "BTC",
        payment_method: "83562370-3e5c-51db-87da-752af5ab9559",
      },
      function (err, tx) {
        console.log(tx);
      }
    );
  }
);
```

</TabItem>
</Tabs>

#### Response (201)

```json
{
  "data": {
    "id": "a333743d-184a-5b5b-abe8-11612fc44ab5",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "763d1401-fd17-5a18-852a-9cca5ac2f9c0",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/763d1401-fd17-5a18-852a-9cca5ac2f9c0"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "98.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "99.00",
      "currency": "USD"
    },
    "created_at": "2015-04-01T18:43:37-07:00",
    "updated_at": "2015-04-01T18:43:37-07:00",
    "resource": "sell",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells/a333743d-184a-5b5b-abe8-11612fc44ab5",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "10.1",
      "currency": "USD"
    },
    "payout_at": "2015-04-07T18:43:37-07:00"
  }
}
```

## Commit Sell

Completes a sell that is created in `commit: false` state.

If the exchange rate has changed since the sell was created, this call will fail with the error _“The exchange rate updated while you were waiting. The new total is shown below”_.

The sell's total will also be updated. You can repeat the `/commit` call to accept the new values and commit the sell at the new rates.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/sells/:sell_id/commit`

### Scopes

- `wallet:sells:create`

### Arguments

_None_

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/sells/a333743d-184a-5b5b-abe8-11612fc44ab5/commit \
  -X POST \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

sell = client.commit_sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                          'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

sell = client.commit_sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                          'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getSell("a333743d-184a-5b5b-abe8-11612fc44ab5", function (err, tx) {
      tx.commit(function (err, resp) {
        console.log(resp);
      });
    });
  }
);
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "data": {
    "id": "a333743d-184a-5b5b-abe8-11612fc44ab5",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "763d1401-fd17-5a18-852a-9cca5ac2f9c0",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions763d1401-fd17-5a18-852a-9cca5ac2f9c0"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "98.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "99.00",
      "currency": "USD"
    },
    "created_at": "2015-04-01T18:43:37-07:00",
    "updated_at": "2015-04-01T18:43:37-07:00",
    "resource": "sell",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells/a333743d-184a-5b5b-abe8-11612fc44ab5",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "10.1",
      "currency": "USD"
    },
    "payout_at": "2015-04-07T18:43:37-07:00"
  }
}
```

## List Sells

Lists sells for an account.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/sells`

### Scopes

- `wallet:sells:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

sells = client.list_sells('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_sells('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getSells(function (err, txs) {
      console.log(txs);
    });
  }
);
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "9e14d574-30fa-5d85-b02c-6be0d851d61d",
      "status": "created",
      "payment_method": {
        "id": "83562370-3e5c-51db-87da-752af5ab9559",
        "resource": "payment_method",
        "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
      },
      "transaction": {
        "id": "4117f7d6-5694-5b36-bc8f-847509850ea4",
        "resource": "transaction",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/4117f7d6-5694-5b36-bc8f-847509850ea4"
      },
      "amount": {
        "amount": "10.00000000",
        "currency": "BTC"
      },
      "total": {
        "amount": "98.01",
        "currency": "USD"
      },
      "subtotal": {
        "amount": "99.00",
        "currency": "USD"
      },
      "created_at": "2015-03-26T23:43:59-07:00",
      "updated_at": "2015-03-26T23:44:09-07:00",
      "resource": "sell",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells/9e14d574-30fa-5d85-b02c-6be0d851d61d",
      "committed": true,
      "instant": false,
      "fee": {
        "amount": "10.1",
        "currency": "USD"
      },
      "payout_at": "2015-04-01T23:43:59-07:00"
    }
  ]
}
```

## Show Sell

Show an individual sell.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/sells/:sell_id`

### Scopes

- `wallet:sells:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/sells/dd3183eb-af1d-5f5d-a90d-cbff946435ff /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

sell = client.list_sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                        'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

sell = client.get_sell('2bbf394c-193b-5b2a-9155-3b4732659ede',
                       'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getSell("dd3183eb-af1d-5f5d-a90d-cbff946435ff", function (err, tx) {
      console.log(tx);
    });
  }
);
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "9e14d574-30fa-5d85-b02c-6be0d851d61d",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "4117f7d6-5694-5b36-bc8f-847509850ea4",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/4117f7d6-5694-5b36-bc8f-847509850ea4"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "98.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "99.00",
      "currency": "USD"
    },
    "created_at": "2015-03-26T23:43:59-07:00",
    "updated_at": "2015-03-26T23:44:09-07:00",
    "resource": "sell",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/9e14d574-30fa-5d85-b02c-6be0d851d61d",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "10.1",
      "currency": "USD"
    },
    "payout_at": "2015-04-01T23:43:59-07:00"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/coinbase-app-permissions.mdx -->

---
title: "Coinbase App OAuth2 Permissions"
sidebar_label: "OAuth2 Permissions"
slug: "coinbase-app-permissions"
---

Different applications require different access to user accounts, and Coinbase App provides many options to fine-tune the access. Options range from accounts to API endpoints accessed by API consumer. For full list of options, see [OAuth2 reference](./coinbase-app-reference.md).

## Account Access

Coinbase App applications can request different access to user's wallets. This access is defined by a drop down selection on the consent page when the user connects to the app. See the example below.

<img src={require('../assets/images/account-access.png').default} width="350" alt=""  />  

Note that Wallet access is still used together with OAuth2 scopes (see below). This means that `account=all` combined with `scope=wallet:buys:create` can create buys on all of user's wallets but won't for example give access to sell on any of their accounts.

## OAuth2 Permission Scopes

For OAuth2, permissions are specified by including an additional `scope` parameter in your OAuth2 request. For example, your app may only need to view a user's accounts and transaction history, but may not need or want the ability to send/receive and buy/sell a [digital asset](https://help.coinbase.com/en/coinbase/supported-crypto). Multiple permissions should be separated with a comma character in the URL (i.e. `&scope=wallet:accounts:read,wallet:transactions:read`).

It's recommended that you only ask for permissions that your application needs. If you need to obtain more permissions later, you can re-authenticate the user, forcing the user to consider authorizing additional permissions the next time s/he opens the app.

Here is an example request URL with a `scope` parameter on the end:

```
https://login.coinbase.com/oauth2/auth?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=YOUR_CALLBACK_URL&scope=wallet:accounts:read,wallet:transactions:read
```
[Full list of permission (scopes)](./permissions-scopes.md)

## Send Limits

To better protect Coinbase users, the `wallet:transactions:send` permission requires additional OAuth2 authorize parameters and [two factor authentication](./coinbase-app-2fa.md). Here's an example of how to set and modify the send limit in an authorize request:

<img src={require('../assets/images/send-limits.png').default} width="350" alt=""  />  

For new applications, the send limit amount is limited to $1.00 per user. Users can modify this limit on the consent page when they successfully authenticate and connect to your app for the first time. For better security and user experience, Coinbase recommends that you encourage your users to personalize their limits to their needs.



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-users.mdx -->

---
title: "Wallet API: Users/User (Deprecated)"
sidebar_label: "Users/User (Deprecated)"
slug: "api-users"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                                               | Method | Endpoint             | Legacy Scope                                                                  | CDP API Key Scope  |
|:-------------------------------------------------------------------|:-------|:---------------------|:------------------------------------------------------------------------------|:---------------------|
| [Show Current User](#show-current-user)                            | GET    | `/v2/user`           | - N/A for public data <br /> - `wallet:user:read` <br />- `wallet:user:email` | `view`               |
| [Show Authorization Information](#show-authorization-information)  | GET    | `/v2/user/auth`      | N/A                                                                           | N/A                  |
| [(Removed Feb 9)](./changelog.mdx#2024-feb-09) Update Current User |        |                      |                                                                               |                      |
| [(Removed Mar 6)](./changelog.mdx#2024-mar-06) Show User           | GET    | `/v2/users/:user_id` | N/A                                                                           | N/A                  |

:::info
- `/user` refers to the current user making the request.
- `/users` allows you to pass an ID of a User from whom you want data.
:::

## Overview

The **User resource** represents generic user information. By default, only public information is shared without any scopes. More detailed information or email can be requested with additional scopes.

| Parameter                              | Description                             |
|:---------------------------------------|:----------------------------------------|
| `id` _string_                          | Resource ID                             |
| `name` _string, optional_              | User's public name                      |
| `username` _string, optional_          | Payment method's native currency        |
| `profile_location` _string, optional_  | Location for user's public profile      |
| `profile_bio` _string, optional_       | Bio for user's public profile           |
| `profile_url` _string, optional_       | Public profile location if user has one |
| `avatar_url` _string_                  | User's avatar url                       |
| `resource` _string, constant_ **user** |                                         |
| `resource_path` _string_               |                                         |

#### User's Public Info (default)

```json
{
  "id": "9da7a204-544e-5fd1-9a12-61176c5d4cd8",
  "name": "User One",
  "username": "user1",
  "profile_location": null,
  "profile_bio": null,
  "profile_url": "https://coinbase.com/user1",
  "avatar_url": "https://images.coinbase.com/avatar?h=vR%2FY8igBoPwuwGren5JMwvDNGpURAY%2F0nRIOgH%2FY2Qh%2BQ6nomR3qusA%2Bh6o2%0Af9rH&s=128",
  "resource": "user",
  "resource_path": "/v2/user"
}
```

#### Detailed Info of Authenticated User (`wallet:user:read`)

```json
{
  ...
  "time_zone": "Pacific Time (US & Canada)",
  "native_currency": "USD",
  "bitcoin_unit": "bits",
  "country": {
    "code": "US",
    "name": "United States"
  },
  "created_at": "2015-01-31T20:49:02Z"
}
```

#### Authenticated User with Email (`wallet:user:email`)

```json
{
  ...
  "email": "user1@example.com"
}
```

## Show Current User

Get current user's public information. To get user's email or private information, use permissions `wallet:user:email` and `wallet:user:read`. If current request has a `wallet:transactions:send` scope, then the response will contain a boolean `sends_disabled` field that indicates if the user's send functionality has been disabled.

### HTTP Request

`GET https://api.coinbase.com/v2/user`

### Scopes

- _No scope required for public data_
- `wallet:user:read`
- `wallet:user:email`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/user /
   -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

user = client.current_user
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

user = client.get_current_user()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getCurrentUser(function(err, user) {
  console.log(user);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "9da7a204-544e-5fd1-9a12-61176c5d4cd8",
    "name": "User One",
    "username": "user1",
    "profile_location": null,
    "profile_bio": null,
    "profile_url": "https://coinbase.com/user1",
    "avatar_url": "https://images.coinbase.com/avatar?h=vR%2FY8igBoPwuwGren5JMwvDNGpURAY%2F0nRIOgH%2FY2Qh%2BQ6nomR3qusA%2Bh6o2%0Af9rH&s=128",
    "resource": "user",
    "resource_path": "/v2/user"
  }
}
```

## Show Authorization Information

Get current user's authorization information including granted scopes and send limits when using OAuth2 authentication.

### HTTP Request

`GET https://api.coinbase.com/v2/user/auth`

### Scopes

- _No permission required_

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/user/auth /
   -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

client.auth_info
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

user = client.get_auth_info()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getCurrentUser(function(err, user) {
  user.showAuth(function(err, auth) {
    console.log(auth);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "method": "oauth",
    "scopes": [
        "wallet:user:read",
        "wallet:user:email"
    ],
    "oauth_meta": {}
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-key-auth-legacy.mdx -->

---
title: "Coinbase App Legacy Keys"
sidebar_label: "Legacy Keys"
slug: "api-key-auth-legacy"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

You can create and activate new API keys in your [API settings](https://coinbase.com/settings/api).
Please note, legacy API key authentication is supported for Coinbase App APIs for existing keys. You can no longer create new keys using legacy process.

## Making a Request

All REST requests must contain the following headers:

- `CB-ACCESS-KEY` API key as a string
- `CB-ACCESS-SIGN` Message signature (see below)
- `CB-ACCESS-TIMESTAMP` Timestamp for your request

All request bodies should have content type `application/json` and be valid JSON.

Example request:

```shell
curl https://api.coinbase.com/v2/user \
  --header "CB-ACCESS-KEY: <your api key>" \
  --header "CB-ACCESS-SIGN: <the user generated message signature>" \
  --header "CB-ACCESS-TIMESTAMP: <a timestamp for your request>"
```

## Selecting a Timestamp

The `CB-ACCESS-TIMESTAMP` header MUST be number of seconds since [Unix Epoch](https://en.wikipedia.org/wiki/Unix_time) in UTC.

Your timestamp must be within 30 seconds of the API service time, or your request will be considered expired and rejected. If you think there is a time skew between your server and the API servers, use the [time API endpoint](./api-time.mdx) to query for the API server time.

## Creating a Signature

The `CB-ACCESS-SIGN` header is generated by creating a sha256 HMAC using the secret key on the prehash string `timestamp + method + requestPath + body` (where `+` represents string concatenation). 

- `timestamp` is the same as the `X-CB-ACCESS-TIMESTAMP` header.

- `method` should be UPPER CASE.

- `requestPath` is the full path and query parameters of the URL, e.g.: `/v2/exchange-rates?currency=USD`.

- `body` is the request body string. It is omitted if there is no request body (typically for GET requests).

## Signature Examples

The following examples demonstrate how to generate a signature using a legacy key:

<Tabs>

<TabItem value="python" label="Python">

```python
# Requires python-requests. Install with pip or easy-install
##  Install with pip: pip install requests
##  Install with easy-install: easy_install requests

import json, hmac, hashlib, time, requests
from requests.auth import AuthBase

# Before implementation, set environmental variables with the names API_KEY and API_SECRET
API_KEY = 'API_KEY'
API_SECRET = 'API_SECRET'

# Create custom authentication for Coinbase API
class CoinbaseWalletAuth(AuthBase):
    def __init__(self, api_key, secret_key):
        self.api_key = api_key
        self.secret_key = secret_key

    def __call__(self, request):
        timestamp = str(int(time.time()))
        message = timestamp + request.method + request.path_url + (request.body or '')
        signature = hmac.new(self.secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()

        request.headers.update({
            'CB-ACCESS-SIGN': signature,
            'CB-ACCESS-TIMESTAMP': timestamp,
            'CB-ACCESS-KEY': self.api_key,
        })
        return request

api_url = 'https://api.coinbase.com/v2/'
auth = CoinbaseWalletAuth(API_KEY, API_SECRET)

# Get current user
r = requests.get(api_url + 'user', auth=auth)
print r.json()
# {u'data': {u'username': None, u'resource': u'user', u'name': u'User'...

# Send funds
tx = {
    'type': 'send',
    'to': 'user@example.com',
    'amount': '10.0',
    'currency': 'USD',
}
r = requests.post(api_url + 'accounts/primary/transactions', json=tx, auth=auth)
print r.json()
# {u'data': {u'status': u'pending', u'amount': {u'currency': u'BTC'...
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'openssl'
require 'json'

class CoinbaseWallet
  def initialize(key, secret)
    @key = key
    @secret = secret
  end

  def signature(request_path='', body='', timestamp=nil, method='GET')
    body = body.to_json if body.is_a?(Hash)
    timestamp = Time.now.to_i if !timestamp

    message = "#{timestamp}#{method}#{request_path}#{body}"

    # create a sha256 hmac with the secret
    hash = OpenSSL::HMAC.hexdigest('sha256', @secret, message)
  end
end
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
// npm install crypto
var crypto = require('crypto');
// npm install request
var request = require('request');

// Set these in your environment, or enter them here with the actual string
var apiKey = '';
var apiSecret = '';


//get unix time in seconds
var timestamp = Math.floor(Date.now() / 1000);

// set the parameter for the request message
var req = {
    method: 'GET',
    path: '/v2/exchange-rates?currency=USD',
    body: ''
};

var message = timestamp + req.method + req.path + req.body;
console.log(message);

//create a hexedecimal encoded SHA256 signature of the message
var signature = crypto.createHmac("sha256", apiSecret).update(message).digest("hex");

//create the request options object
var options = {
    baseUrl: 'https://api.coinbase.com/',
    url: req.path,
    method: req.method,
    headers: {
        'CB-ACCESS-SIGN': signature,
        'CB-ACCESS-TIMESTAMP': timestamp,
        'CB-ACCESS-KEY': apiKey,
        'CB-VERSION': '2015-07-22'
    }
};

request(options,function(err, response){
    if (err) console.log(err);
    console.log(response.body);
});
```

</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-exchange-rates.mdx -->

---
title: "Data API: Exchange Rates"
sidebar_label: "Exchange Rates"
slug: "api-exchange-rates"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                      | Method | Endpoint             | Scope |
|:------------------------------------------|:-------|:---------------------|:------|
| [Get Exchange Rates](#get-exchange-rates) | GET    | `/v2/exchange-rates` | N/A   |


## Get Exchange Rates

Get current exchange rates. Default base currency is `USD` but it can be defined as any supported currency (see `Currencies` endpoint). Returned rates will define the exchange rate for one unit of the base currency.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/exchange-rates`

### Scopes

- _No permission required_

### Arguments

| Parameter | Type   | Required | Description                    |
|:----------|:-------|:---------|:-------------------------------|
| currency  | string | Optional | Base currency (default: `USD`) |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/exchange-rates?currency=BTC
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

rates = client.exchange_rates({currency: 'BTC'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

rates = client.get_exchange_rates(currency='BTC')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getExchangeRates({'currency': 'BTC'}, function(err, rates) {
  console.log(rates);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "currency": "BTC",
    "rates": {
      "AED": "36.73",
      "AFN": "589.50",
      "ALL": "1258.82",
      "AMD": "4769.49",
      "ANG": "17.88",
      "AOA": "1102.76",
      "ARS": "90.37",
      "AUD": "12.93",
      "AWG": "17.93",
      "AZN": "10.48",
      "BAM": "17.38",
      ...
    }
  }
}
```


<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-deposits.mdx -->

---
title: "Wallet API: Deposits"
sidebar_label: "Deposits"
slug: "api-deposits"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                  | Method | Endpoint                                               | Legacy Scope             | CDP API Key Scope     |
|:--------------------------------------|:-------|:-------------------------------------------------------|:-------------------------|:------------------------|
| [Deposit Funds](#deposit-funds)       | POST   | `/v2/accounts/:account_id/deposits`                    | `wallet:deposits:create` |`transfer`               |
| [Commit Deposit](#commit-deposit)     | POST   | `/v2/accounts/:account_id/deposits/:deposit_id/commit` | `wallet:deposits:create` |`transfer`               |
| [List Deposits](#list-deposits)       | GET    | `/v2/accounts/:account_id/deposits`                    | `wallet:deposits:read`   |`view`                   |
| [Show Deposit](#show-deposit)         | GET    | `/v2/accounts/:account_id/deposits/:deposit_id`        | `wallet:deposits:read`   |`view`                   |


## Overview

The **Deposit resource** represents a deposit of funds using a payment method (e.g., a bank). Each committed deposit also has an associated transaction.

:::tip
You can [start a withdrawal](#deposit-funds) with the flag, `commit: false`, which is useful if you want to display a deposit before executing. Deposits made with `commit` set to `false` will not complete nor receive an associated transaction until a separate [commit](#commit-a-deposit) request is made.
:::

| Parameter                                 | Description                                                             |
|:------------------------------------------|:------------------------------------------------------------------------|
| `id` _string_                             | Resource ID                                                             |
| `status` _string, enumerable_             | Status of the deposit. Valid values: `created`, `completed`, `canceled` |
| `payment_method` _hash_                   | Associated payment method (e.g., a bank)                                |
| `transaction` _hash_                      | Associated transaction (e.g., a bank, fiat account)                     |
| `amount` _money hash_                     | Amount                                                                  |
| `subtotal` _money hash_                   | Amount without fees                                                     |
| `fee` _money hash_                        | Fees associated to this deposit                                         |
| `created_at` _timestamp_                  |                                                                         |
| `updated_at` _timestamp_                  |                                                                         |
| `resource` _string, constant **deposit**_ |                                                                         |
| `resource_path` _string_                  |                                                                         |
| `committed` _boolean_                     | Has this deposit been committed?                                        |
| `payout_at` _timestamp, optional_         | When a deposit isn't executed instantly, it receives a payout date for the time it will be executed |

#### Example Deposit Resource

```json
{
  "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
  "status": "completed",
  "payment_method": {
    "id": "83562370-3e5c-51db-87da-752af5ab9559",
    "resource": "payment_method",
    "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
  },
  "transaction": {
    "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
  },
  "amount": {
    "amount": "10.00",
    "currency": "USD"
  },
  "subtotal": {
    "amount": "10.00",
    "currency": "USD"
  },
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-02-11T16:54:02-08:00",
  "resource": "deposit",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
  "committed": true,
  "fee": {
    "amount": "0.00",
    "currency": "USD"
  },
  "payout_at": "2015-02-18T16:54:00-08:00"
}
```


## Deposit Funds

Deposits user-defined amount of funds to a fiat account.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/deposits`

### Scopes

- `wallet:deposits:create`

### Arguments

| Parameter        | Type    | Required | Description               |
|:-----------------|:--------|:---------|:--------------------------|
| `amount`         | string  | Required | Deposit amount            |
| `currency`       | string  | Required | Currency for the `amount` |
| `payment_method` | string  | Required | ID of payment method to be used for the deposit. List Payment Methods: `GET /payment-methods` |
| `commit`         | boolean | Optional | If `false`, this deposit is not immediately completed. Use the `commit` call to complete it. Default value: `true` |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/deposits /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{
    "amount": "10",
    "currency": "USD",
    "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"
  }'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

deposit = client.deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                         {"amount" => "10",
                          "currency" => "USD",
                          "payment_method" => "83562370-3e5c-51db-87da-752af5ab9559"})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

deposit = client.deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                         amount="10",
                         currency="USD",
                         payment_method="83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.deposit({"amount": "10",
                   "currency": "USD",
                   "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"}, function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>

#### Response (201)

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "deposit",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```

## Commit Deposit

Completes a [deposit](#deposit-funds) that is created in `commit: false` state.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/deposits/:deposit_id/commit`

### Scopes

- `wallet:deposits:create`

### Arguments

_None_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/deposits/a333743d-184a-5b5b-abe8-11612fc44ab5/commit /
  -X POST \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

deposit = client.commit_deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

deposit = client.commit_deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getDeposit('a333743d-184a-5b5b-abe8-11612fc44ab5', function(err, tx) {
    tx.commit(function(err, resp) {
      console.log(resp);
    });
  });
});
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "deposit",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```


## List Deposits

Lists fiat deposits for an account.

:::caution
Deposits are only listed for fiat accounts and wallets. To list deposits associated with a crypto account/wallet, use [List Transactions](/coinbase-app/docs/api-transactions#list-transactions).
:::

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/deposits`

### Scopes

- `wallet:deposits:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

deposits = client.list_deposits('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_deposits('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getDeposits(function(err, txs) {
    console.log(txs);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
      "status": "completed",
      "payment_method": {
        "id": "83562370-3e5c-51db-87da-752af5ab9559",
        "resource": "payment_method",
        "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
      },
      "transaction": {
        "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        "resource": "transaction",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
      },
      "amount": {
        "amount": "10.00",
        "currency": "USD"
      },
      "subtotal": {
        "amount": "10.00",
        "currency": "USD"
      },
      "created_at": "2015-01-31T20:49:02Z",
      "updated_at": "2015-02-11T16:54:02-08:00",
      "resource": "deposit",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
      "committed": true,
      "fee": {
        "amount": "0.00",
        "currency": "USD"
      },
      "payout_at": "2015-02-18T16:54:00-08:00"
    }
  ]
}
```


## Show Deposit

Get one deposit by deposit Id.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/deposits/:deposit_id`

### Scopes

- `wallet:deposits:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

deposit = client.list_deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                              'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

deposit = client.get_deposit('2bbf394c-193b-5b2a-9155-3b4732659ede',
                             'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getDeposit('dd3183eb-af1d-5f5d-a90d-cbff946435ff', function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "completed",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "deposit",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/deposits/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-transactions.mdx -->

---
title: "Wallet API: Transactions"
sidebar_label: "Transactions"
slug: "api-transactions"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<a name="announcement"></a>

:::announcement Added, Updated, Removed Parameters

Starting **30 October 2024**, select parameters for Coinbase App v2 [Send Money](#send-money) and [Transfer Money](#transfer-money-between-accounts) APIs will be added, updated, and removed.

**ADDED**
- [Arguments](#arguments): `network` (optional)

**UPDATED**
- [Arguments](#arguments): `to` now supports sends to phone numbers along with blockchain addresses and emails

**REMOVED**
-  [Arguments](#arguments): `financial_institution_website`
-  [Arguments](#arguments): `to_financial_institution`
-  [Arguments](#arguments): `skip_notifications`
-  [Arguments](#arguments): `instant_buy`
-  [Arguments](#arguments): `referrer`
-  [Arguments](#arguments): `commit`
-  [Arguments](#arguments): `fee`
-  [Arguments](#arguments): `no_destination_tag`
-  [Arguments](#arguments): `admin_id`
-  [Arguments](#arguments): `coinbase_initiated`

-  [Transfer Money](#transfer-money-between-accounts)

Note: These changes are relevant to all countries except Singapore, Netherlands, Canada, France, and Bermuda
:::


## Table of Endpoints

| Name                                               | Method | Endpoint                                                | Legacy Scope                   | CDP API Key Scope |
|:---------------------------------------------------|:-------|:--------------------------------------------------------|:-------------------------------|:--------------------|
| [Send Money](#send-money)                          | POST   | `/v2/accounts/:account_id/transactions`                 | `wallet:transactions:send`     | `transfer`          |
| [Transfer Money](#transfer-money-between-accounts) | POST   | `/v2/accounts/:account_id/transactions`                 | `wallet:transactions:transfer` | `transfer`          |
| [List Transactions](#list-transactions)            | GET    | `/v2/accounts/:account_id/transactions`                 | `wallet:transactions:read`     | `view`              |
| [Show Transaction](#show-transaction)              | GET    | `/v2/accounts/:account_id/transactions/:transaction_id` | `wallet:transactions:read`     | `view`              |

## Overview

The **Transaction resource** represents an event on the account. An `amount` can be positive (credit) or negative (debit). Transactions with counterparties have either a `to` or `from` field. 

:::caution
As transactions represent multiple objects, resources with new `type` or `status` values may be added over time. See more about [enumerable values](./fields.md#enumerable-values).
:::

### Transaction Types

:::caution
The `send` type is no longer the default type and is now restricted to sending transactions only. 

A new type, `tx`, is now the default and uncategorized. We are working on reducing transactions belonging to `tx` and implementing dedicated types as much as possible.
:::

Transaction types currently available:

|  New  | Transaction Type             | Description                                                               |
| :---: | :--------------------------- | :------------------------------------------------------------------------ |
|       | `advanced_trade_fill`        | Fills for an advanced trade order                                         |
|       | `buy`                        | Buy a digital asset                                                       |
|   x   | `clawback`                   | Recover money already disbursed                                           |
|   x   | `derivatives_settlement`     | Daily settlement between spot and futures accounts for US futures product |
|   x   | `earn_payout`                | Payout for user earn on Coinbase                                          |
|       | `fiat_deposit`               | Deposit funds into a fiat account from a financial institution            |
|       | `fiat_withdrawal`            | Withdraw funds from a fiat account                                        |
|   x   | `incentives_shared_clawback` | Clawback incentive payout from customer account                           |
|   x   | `intx_deposit`               | Deposit crypto to customer international account                          |
|   x   | `intx_withdrawal`            | Withdraw crypto from customer international account                       |
|       | `receive`                    | Receive a digital asset                                                   |
|       | `request`                    | Request a digital asset from a user or email                              |
|       | `sell`                       | Sell a digital asset                                                      |
|       | `send`                       | Send a [supported digital asset](https://www.coinbase.com/trade) to a corresponding address or email. <br /> <br />Note: Previously functioned as a default catch-all type. Now it is restricted to send transactions only. |
|   x   | `staking_transfer`           | Funds from primary account moved to staked account                        |
|   x   | `subscription_rebate`        | Transaction for Coinbase subscription rebate                              |
|   x   | `subscription`               | Transaction for Coinbase subscription                                     |
|       | `trade`                      | Exchange one cryptocurrency for another cryptocurrency or fiat currency   |
|       | `transfer`                   | Transfer funds between two of your own accounts                           |
|   x   | `tx`                         | **Default transaction type, uncategorized.** <br /> <br />Note: Previously defined as the `send` type. |
|   x   | `unstaking_transfer`         | Funds from staked funds moved to primary account                          |
|   x   | `unsupported_asset_recovery` | Recover unsupported ERC-20s deposited to Coinbase on ethereum mainnet     |
|   x   | `unwrap_asset`               | Unwrap wrapped assets, e.g. cbETH, to wrappable assets, e.g. staked ETH   |
|       | `vault_withdrawal`           | Withdraw funds from a vault account                                       |
|   x   | `wrap_asset`                 | Wrap wrappable assets, e.g. staked ETH, to wrapped assets, e.g. cbETH     |

### Transaction Statuses

Transaction statuses vary based on the type of the transaction. As both types and statuses can change over time, we recommend that you use `details` field for constructing human readable descriptions of transactions. Currently available statuses are:

| Transaction Status      | Description                                             |
| :---------------------- | :------------------------------------------------------ |
| `canceled`              | Transaction was canceled                                |
| `completed`             | Completed transactions (e.g., a send or a buy)          |
| `expired`               | Conditional transaction expired due to external factors |
| `failed`                | Failed transactions (e.g., failed buy)                  |
| `pending`               | Pending transactions (e.g., a send or a buy)            |
| ` waiting_for_clearing` | Vault withdrawal is waiting to be cleared               |
| `waiting_for_signature` | Vault withdrawal is waiting for approval                |

### Parameters

:::caution removed multiple params for list/show
On 31 Mar 2024, multiple parameters were removed for [List Transactions](#list-transactions) and [Show Transaction](#show-transaction).
:::

| Parameter                                     | Type         | Required | Description                |
|:----------------------------------------------|:-------------|:---------|:---------------------------|
| `id`                                          | string       | Required | Transaction ID             |
| `type`                                        | string, enum | Required | Transaction type           |
| `status`                                      | string, enum | Required | Status                     |
| `amount`                                      | money hash   | Required | Amount of any [supported digital asset](https://www.coinbase.com/trade). Value is negative to indicate the debiting of funds for the following transaction type cases: <ul> <li><code>advanced_trade_fill</code>, sell</li> <li><code>pro_deposit</code></li> </ul> |
| `native_amount`                               | money hash   | Required | Amount in user's native currency. Value is negative to indicate the debiting of funds for the following transaction type cases: <ul> <li><code>advanced_trade_fill</code>, sell</li> <li><code>pro_deposit</code></li> </ul> |
| `description`                                 | string       | Required | User defined description   |
| `created_at`                                  | timestamp    | Required |                            |
| `updated_at`                                  | timestamp    | Required | <b>Removed for List/Show Tx on 7 Feb</b> |
| `resource`, _constant **transaction**_        | string       | Required |                            |
| `resource_path`                               | string       | Required |                            |
| `instant_exchange`                            | boolean      | Required | <b>Removed for List/Show Tx on 7 Feb</b>  |
| [`advanced_trade_fill`](#advanced-trade-fill) | hash         | Required | Only provided if the transaction type is `advanced_trade_fill`. Contains information about the fill posted. |
| [`details`](#details)                         | hash         | Required | <b>Removed for List/Show Tx on 7 Feb</b> <br />Detailed information about the transaction |
| [`network`](#network)                         | hash         | Optional | Info about crypto networks including on-chain transaction hashes. Only available for certain types of transactions. |
| `to`                                          | hash         | Optional | Receiving party of a debit transaction. Usually another resource but can be another type like email. Only available for certain types of transactions. |
| [`from`](#from)                               | hash         | Optional | Originating party of a credit transaction. Usually another resource, but can be another type like Bitcoin network. Only available for certain types of transactions. |
| `address`                                     | hash         | Optional | <b>Removed for List/Show Tx on 7 Feb</b> <br />Associated crytpo address for received payment |
| `application`                                 | hash         | Optional | <b>Removed for List/Show Tx on 7 Feb</b> <br />Associated OAuth2 application |
| `cancelable`                                  | boolean      | Optional | <b>New for List/Show Tx on 7 Feb</b> <br />Allowed to cancel transaction; ONLY provided when transaction is a SEND  |
| `idem`                                        | string       | Optional | <b>New for List/Show Tx on 7 Feb</b> <br />Idempotency key of transaction; ONLY provided when transaction is a SEND |
| `buy`                                         | hash         | Optional | <b>New for List/Show Tx on 7 Feb</b> <br />Only provided if transaction type is a buy     |
| `sell`                                        | hash         | Optional | <b>New for List/Show Tx on 7 Feb</b> <br />Only provided if transaction type is a sell    |
| `trade`                                       | hash         | Optional | <b>New for List/Show Tx on 7 Feb</b> <br />Only provided if transaction type is a trade   |

### Advanced Trade Fill

| Parameter    | Type         | Description                                                  |
|:-------------|:-------------|:-------------------------------------------------------------|
| `fill_price` | string       | Price this fill was posted at                                |
| `product_id` | string       |                                                              |
| `order_id`   | string       | The UUID of the order this fill belongs to                   |
| `commission` |              | Commission per fill of the order. Always represented in quote currency.  |
| `order_side` | string, enum | Side the order was placed on. Possible values: `BUY`, `SELL` |
 
### Details 

:::caution removed details for list/show and send money
On 31 Mar 2024, the details object was removed for [List Transactions](#list-transactions) and [Show Transaction](#show-transaction).

On 30 Oct 2024, the details object will be removed for [Send Money](#send-money).
:::

| Parameter          | Type           | Description                                                                                        |
| :----------------- | :------------- | :------------------------------------------------------------------------------------------------- |
| `title`            | string         | Description of transaction with currency. Example: "Received Bitcoin"                              |
| `subsidebar_label` | string or null |                                                                                                    |
| `header`           | string         | Amount received, in amount and equivalent native amount. Example: "Received 0.005378 BTC ($49.92)" |
| `health`           | string         | Health of transaction. Example: "Positive"                                                         |

### Network

:::caution removed status_description for list/show
On 31 Mar 2024, `status_description` was removed for [List Transactions](#list-transactions) and [Show Transaction](#show-transaction).

On 30 Oct 2024, `status_description` will be removed for [Send Money](#send-money).
:::

| Parameter            | Type           | Description                                                             |
| :------------------- | :------------- | :---------------------------------------------------------------------- |
| `status`             | string, enum   | Possible values: <ul> <li><code>off_blockchain</code></li> <li><code>confirmed</code></li> <li><code>pending</code></li> <li><code>unconfirmed</code></li> </ul> |
| `status_description` | string or null | <b>Removed for List/Show Tx on 7 Feb</b> <br />Description of status |
| `hash`               | string         | <b>New for List/Show Tx on 7 Feb</b> <br />Hash for onchain transactions; ONLY provided when transaction is a SEND |
| `transaction_fee`    | hash           | <b>New for List/Show Tx on 7 Feb</b> <br />Transaction fee; ONLY provided when transaction is a SEND               |
| `network_name`       | string         | <b>New for List/Show Tx on 7 Feb</b> <br />Name of transaction network; ONLY provided when transaction is a SEND   |

### From

:::caution removed currency for list/show
On 31 Mar 2024, `currency` was removed for [List Transactions](#list-transactions) and [Show Transaction](#show-transaction).
:::

| Parameter       | Type           | Description                                                              |
|:----------------|:---------------|:-------------------------------------------------------------------------|
| `id`            | string         | <b>Updated for List/Show Tx on 7 Feb</b> <br /> UUID (and after Feb 7, account) of user who the transaction is from |
| `resource`      | string or null | <b>Updated for List/Show Tx on 7 Feb</b> <br />user (and after Feb 7, account) |
| `resource_path` | string         | <b>Updated for List/Show Tx on 7 Feb</b> <br /><ul><li>If resource is user, this path is in the form of v2/users/\{userUUID\}</li><li>(after Feb 7) If resource is account, the path is in the form of /v2/accounts/\{accountUUID\}></li></ul> |
| `currency`      | string         | <b>Removed for List/Show Tx on 7 Feb</b> <br />Currency user sent |

### Resource Examples 

#### Transaction Resource (Send)

```json
{
  "id": "57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
  "type": "send",
  "status": "pending",
  "amount": {
    "amount": "-0.00133",
    "currency": "BTC"
  },
  "native_amount": {
    "amount": "-0.01",
    "currency": "USD"
  },
  "description": null,
  "created_at": "2015-03-11T13:13:35-07:00",
  "updated_at": "2015-03-26T15:55:43-07:00",
  "resource": "transaction",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
  "idem": "df087dce-92a8-45cf-b112-60aad22c0976",
  "network": {
    "status": "pending",
	"transaction_fee": {
	  "amount": "0.00033",
	  "currency": "BTC"
	},
    "transaction_amount": {
	  "amount": "0.001",
	  "currency": "ETH"
    }
  },
  "to": {
    "resource": "ethereum_address",
    "address": "0xabc"
  }
}
```

#### Transaction Resource (Buy)

```json
{
  "id": "8250fe29-f5ef-5fc5-8302-0fbacf6be51e",
  "type": "buy",
  "status": "pending",
  "amount": {
    "amount": "1.00000000",
    "currency": "BTC"
  },
  "native_amount": {
    "amount": "10.00",
    "currency": "USD"
  },
  "description": null,
  "created_at": "2015-03-26T13:42:00-07:00",
  "updated_at": "2015-03-26T15:55:45-07:00",
  "resource": "transaction",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/8250fe29-f5ef-5fc5-8302-0fbacf6be51e",
  "details": {
    "title": "Bought bitcoin",
    "subtitle": "using Capital One Bank"
  }
}
```

## Send Money

Send funds to a network address for any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto), or email address, or phone number of the recipient. No transaction fees are required for off-blockchain cryptocurrency transactions.

:::tip
Coinbase recommends that you always supply a unique `idem` field for each transaction.
:::

:::danger
The Send money API is asynchronous, which means that Coinbase may delay or cancel the send when necessary. Coinbase recommends that you poll the `status` field for the `completed` state with the [Show a Transaction](#show-a-transaction) API. You can also see if a transaction is `pending` in the Send Money API response. 
:::

When used with OAuth2 authentication, this endpoint requires [two factor authentication](./coinbase-app-2fa.md).

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/transactions`

### Scopes

- `wallet:transactions:send`

### Arguments

| Parameter                       | Type    | Required | Description                                                                |
|:--------------------------------|:--------|:---------|:---------------------------------------------------------------------------|
| `type`, _constant **send**_     | string  | Required | Type `send` is required when sending money                                 |
| `to`                            | string  | Required | A blockchain address, email or phone number of the recipient                         |
| `amount`                        | string  | Required | Amount to be sent                                                          |
| `currency`                      | string  | Required | Currency of the `amount`                                                   |
| `description`                   | string  | Optional | Notes to be included in the email to the recipient                         |
| `idem`                          | string  | Optional | **[Recommended]** A token to ensure [idempotence](http://en.wikipedia.org/wiki/Idempotence). If a previous transaction with the same `idem` parameter exists for this sender, that previous transaction is returned and a new one is _not_ created. Max length is 100 characters. |
| `destination_tag`               | string  | Optional | For select currencies, `destination_tag` or `memo` indicates the beneficiary or destination of a payment for select currencies. Example: `{ "type" : "send", "to": "address", "destination_tag" : "memo", "amount": "", "currency": "" }` |
| `network`                       | string  | Optional | Network to be sent on for a blockchain address send. If not specified, send will be executed on the default network for that currency. Ex: "ethereum", "polygon", etc. |

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{
    "type": "send",
    "to": "1AUJ8z5RuHRTqD1eikyfUUetzGmdWLGkpT",
    "amount": "0.1",
    "currency": "BTC",
    "idem": "9316dd16-0c05",
    "network": "bitcoin",
  }'
  ```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

tx = client.send('2bbf394c-193b-5b2a-9155-3b4732659ede',
                 {'to' => '1AUJ8z5RuHRTqD1eikyfUUetzGmdWLGkpT',
                  'amount' => '0.1',
                  'currency' => 'BTC',
                  'idem' => '9316dd16-0c05'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

tx = client.send_money('2bbf394c-193b-5b2a-9155-3b4732659ede',
                       to='1AUJ8z5RuHRTqD1eikyfUUetzGmdWLGkpT',
                       amount='0.1',
                       currency='BTC',
                       idem='9316dd16-0c05')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.sendMoney({'to': '1AUJ8z5RuHRTqD1eikyfUUetzGmdWLGkpT',
                     'amount': '0.1',
                     'currency': 'BTC',
                     'idem': '9316dd16-0c05'}, function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>


#### Response (201)

```json
{
  "data": {
    "id": "3c04e35e-8e5a-5ff1-9155-00675db4ac02",
    "type": "send",
    "status": "pending",
    "amount": {
      "amount": "-0.10000000",
      "currency": "BTC"
    },
    "native_amount": {
      "amount": "-1.00",
      "currency": "USD"
    },
    "description": null,
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-03-31T17:25:29-07:00",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/3c04e35e-8e5a-5ff1-9155-00675db4ac02",
    "network": {
      "status": "pending",
    },
    "to": {
      "resource": "bitcoin_address",
      "address": "1AUJ8z5RuHRTqD1eikyfUUetzGmdWLGkpT"
    }
  }
}
```

## Transfer Money (between accounts)

:::caution no longer supported
Starting 30 Oct 2024, Transfer Money will be deprecated and no longer supported.
:::

Transfer any [Coinbase supported digital asset](https://help.coinbase.com/en/coinbase/supported-crypto) between two of a single user's accounts. Accounts must support the same currency for transfers to be successful. The following transfers are allowed:

- `wallet` to `wallet`
- `wallet` to `vault`

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/transactions`

### Scopes

- `wallet:transactions:transfer`

### Arguments

| Parameter                       | Type   | Required | Description                          |
| :------------------------------ | :----- | :------- | :----------------------------------- |
| `type`, _constant **transfer**_ | string | Required | Type `transfer` is required          |
| `to`                            | string | Required | ID of the receiving account          |
| `amount`                        | string | Required | Amount to be transferred             |
| `currency`                      | string | Required | Currency for the `amount`            |
| `description`                   | string | Optional | Notes to be included in the transfer |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{
    "type": "transfer",
    "to": "58542935-67b5-56e1-a3f9-42686e07fa40",
    "amount": "1"
  }'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

tx = client.transfer('2bbf394c-193b-5b2a-9155-3b4732659ede',
                     {'to' => '58542935-67b5-56e1-a3f9-42686e07fa40',
                      'amount' => '1')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

tx = client.transfer_money('2bbf394c-193b-5b2a-9155-3b4732659ede',
                           to='58542935-67b5-56e1-a3f9-42686e07fa40',
                           amount='1')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.transferMoney({'to': '58542935-67b5-56e1-a3f9-42686e07fa40',
                         'amount': '1'}, function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>


#### Response (201)

```json
{
  "data": {
    "id": "2e9f48cd-0b05-5f7c-9056-17a8acb408ad",
    "type": "request",
    "status": "pending",
    "amount": {
      "amount": "1.00000000",
      "currency": "BTC"
    },
    "native_amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "description": null,
    "created_at": "2015-04-01T10:37:11-07:00",
    "updated_at": "2015-04-01T10:37:11-07:00",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/2e9f48cd-0b05-5f7c-9056-17a8acb408ad",
    "to": {
      "resource": "email",
      "email": "email@example.com"
    },
    "details": {
      "title": "Requested bitcoin",
      "subtitle": "from email@example.com"
    }
  },
}
```

## List Transactions

Lists the transactions of an account by account ID. 

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/transactions`

### Scopes

- `wallet:transactions:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

txs = client.transactions('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_transactions('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">


```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getTransactions(function(err, txs) {
    console.log(txs);
  });
});
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "4117f7d6-5694-5b36-bc8f-847509850ea4",
      "type": "buy",
      "status": "pending",
      "amount": {
        "amount": "486.34313725",
        "currency": "BTC"
      },
      "native_amount": {
        "amount": "4863.43",
        "currency": "USD"
      },
      "description": null,
      "created_at": "2015-03-26T23:44:08-07:00",
      "updated_at": "2015-03-26T23:44:08-07:00",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/4117f7d6-5694-5b36-bc8f-847509850ea4",
      "details": {
        "title": "Bought bitcoin",
        "subtitle": "using Capital One Bank"
      }
    },
    {
      "id": "005e55d1-f23a-5d1e-80a4-72943682c055",
      "type": "request",
      "status": "pending",
      "amount": {
        "amount": "0.10000000",
        "currency": "BTC"
      },
      "native_amount": {
        "amount": "1.00",
        "currency": "USD"
      },
      "description": "",
      "created_at": "2015-03-24T18:32:35-07:00",
      "updated_at": "2015-01-31T20:49:02Z",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/005e55d1-f23a-5d1e-80a4-72943682c055",
      "to": {
        "resource": "email",
        "email": "rb@coinbase.com"
      },
      "details": {
        "title": "Requested bitcoin",
        "subtitle": "from rb@coinbase.com"
      }
    },
    {
      "id": "ff01bbc6-c4ad-59e1-9601-e87b5b709458",
      "type": "transfer",
      "status": "completed",
      "amount": {
        "amount": "-5.00000000",
        "currency": "BTC"
      },
      "native_amount": {
        "amount": "-50.00",
        "currency": "USD"
      },
      "description": "",
      "created_at": "2015-03-12T15:51:38-07:00",
      "updated_at": "2015-01-31T20:49:02Z",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/ff01bbc6-c4ad-59e1-9601-e87b5b709458",
      "to": {
        "id": "58542935-67b5-56e1-a3f9-42686e07fa40",
        "resource": "account",
        "resource_path": "/v2/accounts/58542935-67b5-56e1-a3f9-42686e07fa40"
      },
      "details": {
        "title": "Transfered bitcoin",
        "subtitle": "to Secondary Account"
      }
    },
    {
      "id": "57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
      "type": "send",
      "status": "completed",
      "amount": {
        "amount": "-0.00100000",
        "currency": "BTC"
      },
      "native_amount": {
        "amount": "-0.01",
        "currency": "USD"
      },
      "description": null,
      "created_at": "2015-03-11T13:13:35-07:00",
      "updated_at": "2015-03-26T15:55:43-07:00",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
      "network": {
        "status": "off_blockchain",
        "name": "bitcoin"
      },
      "to": {
        "id": "a6b4c2df-a62c-5d68-822a-dd4e2102e703",
        "resource": "user",
        "resource_path": "/v2/users/a6b4c2df-a62c-5d68-822a-dd4e2102e703"
      },
      "details": {
        "title": "Send bitcoin",
        "subtitle": "to User 2"
      }
    }
  ]
}
```


## Show Transaction

Get a single transaction for an account.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/transactions/:transaction_id`

### Scopes

- `wallet:transactions:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/57ffb4ae-0c59-5430-bcd3-3f98f797a66c /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

tx = client.transaction('2bbf394c-193b-5b2a-9155-3b4732659ede', '57ffb4ae-0c59-5430-bcd3-3f98f797a66c')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

tx = client.get_transaction('2bbf394c-193b-5b2a-9155-3b4732659ede', '57ffb4ae-0c59-5430-bcd3-3f98f797a66c')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getTransaction('57ffb4ae-0c59-5430-bcd3-3f98f797a66c', function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "data": {
    "id": "57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
    "type": "send",
    "status": "completed",
    "amount": {
      "amount": "-0.00100000",
      "currency": "BTC"
    },
    "native_amount": {
      "amount": "-0.01",
      "currency": "USD"
    },
    "description": null,
    "created_at": "2015-03-11T13:13:35-07:00",
    "updated_at": "2015-03-26T15:55:43-07:00",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
    "network": {
      "status": "off_blockchain",
      "name": "bitcoin"
    },
    "to": {
      "id": "a6b4c2df-a62c-5d68-822a-dd4e2102e703",
      "resource": "user",
      "resource_path": "/v2/users/a6b4c2df-a62c-5d68-822a-dd4e2102e703"
    },
    "details": {
      "title": "Send bitcoin",
      "subtitle": "to User 2"
    }
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-currencies.mdx -->

---
title: "Data API: Currencies"
sidebar_label: "Currencies"
slug: "api-currencies"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Table of Endpoints

| Name                                          | Method | Endpoint                | Scope |
|:----------------------------------------------|:-------|:------------------------|:------|
| [Get Fiat Currencies](#get-fiat-currencies)   | GET    | `/v2/currencies`        | N/A   |
| [Get Cryptocurrencies](#get-cryptocurrencies) | GET    | `/v2/currencies/crypto` | N/A   |


## Get Fiat Currencies

Lists known fiat currencies. Currency codes conform to the ISO 4217 standard where possible. Currencies with no representation in ISO 4217 may use a custom code.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/currencies`

### Scopes

- _No permission required_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/currencies
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

currencies = client.currencies
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

currencies = client.get_currencies()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getCurrencies(function(err, currencies) {
  console.log(currencies);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": [
    {
      "id": "AED",
      "name": "United Arab Emirates Dirham",
      "min_size": "0.01000000"
    },
    {
      "id": "AFN",
      "name": "Afghan Afghani",
      "min_size": "0.01000000"
    },
    {
      "id": "ALL",
      "name": "Albanian Lek",
      "min_size": "0.01000000"
    },
    {
      "id": "AMD",
      "name": "Armenian Dram",
      "min_size": "0.01000000"
    }
  ],
  ...
}
```


## Get Cryptocurrencies

Lists known cryptocurrencies. 

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/currencies/crypto`

### Scopes

- _No permission required_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/currencies
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

currencies = client.currencies
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

currencies = client.get_currencies()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getCurrencies(function(err, currencies) {
  console.log(currencies);
});
```

</TabItem>
</Tabs>

#### Response

```json
[
  {
    "code": "BTC",
    "name": "Bitcoin",
    "color": "#F7931A",
    "sort_index": 100,
    "exponent": 8,
    "type": "crypto",
    "address_regex": "^([13][a-km-zA-HJ-NP-Z1-9]{25,34})|^(bc1[qzry9x8gf2tvdw0s3jn54khce6mua7l]([qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38}|[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{58}))$",
    "asset_id": "5b71fc48-3dd3-540c-809b-f8c94d0e68b5"
  },
  {
    "code": "ETH",
    "name": "Ethereum",
    "color": "#627EEA",
    "sort_index": 102,
    "exponent": 8,
    "type": "crypto",
    "address_regex": "^(?:0x)?[0-9a-fA-F]{40}$",
    "asset_id": "d85dce9b-5b73-5c3c-8978-522ce1d1c1b4"
  },
  {
    "code": "ETH2",
    "name": "Ethereum 2",
    "color": "#8E76FF",
    "sort_index": 161,
    "exponent": 8,
    "type": "crypto",
    "address_regex": "^(?:0x)?[0-9a-fA-F]{40}$",
    "asset_id": "3bec5bf3-507a-51ba-8e41-dc953b1a5c4d"
  },
  {
    "code": "ETC",
    "name": "Ethereum Classic",
    "color": "#59D4AF",
    "sort_index": 103,
    "exponent": 8,
    "type": "crypto",
    "address_regex": "^(?:0x)?[0-9a-fA-F]{40}$",
    "asset_id": "c16df856-0345-5358-8a70-2a78c804e61f"
  }
]
```


<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/changelog.mdx -->

---
title: "Coinbase App Changelog"
sidebar_label: "Changelog"
slug: "changelog"
---

These release notes list recent changes to the Coinbase App API.

### 2024-OCT-22
Starting 30 Oct 2024, Transactions API will be updated to enable multichain sends and phone number support. Transfer Money and several other fields are being deprecated. These changes are relevant to all countries except Singapore, Netherlands, Canada, France, and Bermuda. Please view our new documentation [here](./api-transactions.mdx).

### 2024-SEP-23

Accounts API updated to return Loan Collateral accounts for users that have them, even if 0 notional balance. Accounts are of type 'collateral'.

### 2024-SEP-13

Announced Notifications feature deprecation, v2/transactions endpoint will be removed Oct. 1 2024.

### 2024-AUG-16

Sign in with Coinbase is now known as Coinbase App API. No changes to API functionality occurs with this rename. CDP Portal and documentation pages have been updated.

### 2024-AUG-07

Updated the OAuth2 docs to link to [Coinbase Developer Platform](https://portal.cdp.coinbase.com) (CDP) for creating and managing OAuth applications.

### 2024-JUN-12

Updated Transactions documentation to correct that Advanced Trade Fill commission is per fill and not per order.

### 2024-APR-18

Updated the docs to reflect:

- Coinbase Cloud is now [Coinbase Developer Platform](https://portal.cdp.coinbase.com) (CDP)
- Sign in with Coinbase now supports API keys created on CDP
- [Legacy Keys](./api-key-auth-legacy.mdx) are now optional

### 2024-APR-18

Updated the docs to reflect:

- Coinbase Cloud is now [Coinbase Developer Platform](https://portal.cdp.coinbase.com) (CDP)
- Sign in with Coinbase now supports API keys created on CDP
- [Legacy Keys](./api-key-auth-legacy.mdx) are now optional

### 2024-APR-05

Updated the OAuth2 docs:

- [Revoke example](./coinbase-app-access-and-refresh-tokens.md#revoking-an-access-token): Update revoke example to match requirements.

### 2024-APR-02

Sign in with Coinbase API can now be accessed using Cloud API Keys. The [SIWC API Key Authentication guide](./api-key-authentication.mdx) and endpoint scopes were updated accordingly.

### 2024-MAR-28

Updated the OAuth2 docs:

- [OAuth2 URLs](./coinbase-app-reference.md): Changed URLs to new Unified Login versions.
- [Revoke requirements](./coinbase-app-reference.md#revoke): Noted that Revoke now requires client credentials to be passed in.
  Deprecated the following legacy pages:
  - [Client Libraries](./client-libraries.md)
  - [OAuth2 Mobile Integration](./coinbase-app-mobile.md)

### 2024-MAR-07

Announced the upcoming **March 27** replacement of [SIWC v2 Payment Method](./api-payment-methods.mdx) endpoints with [Advanced Trade v3 Payment Method](/advanced-trade/reference/retailbrokerageapi_getpaymentmethods) endpoints.

### 2024-MAR-06

Removed support for the [Show User](./api-users.mdx) endpoint: `GET https://api.coinbase.com/v2/users/:user_id`

### 2024-MAR-05

- Added the following new [transaction types](./api-transactions.mdx#transaction-types), including `tx` as a new default and catch-call type that will be refactored over time into dedicated types.
- Updated the `send` type so that is no longer a catch-all type but restricted to send only.

| Transaction Type             | Description                                                                     |
| :--------------------------- | :------------------------------------------------------------------------------ |
| `clawback`                   | Recover money already disbursed                                                 |
| `derivatives_settlement`     | Daily settlement between spot and futures accounts for US futures product       |
| `earn_payout`                | Payout for user earn on Coinbase                                                |
| `incentives_shared_clawback` | Clawback incentive payout from customer account                                 |
| `intx_deposit`               | Deposit crypto to customer international account                                |
| `intx_withdrawal`            | Withdraw crypto from customer international account                             |
| `staking_transfer`           | Funds from primary account moved to staked account                              |
| `subscription_rebate`        | Transaction for Coinbase subscription rebate                                    |
| `subscription`               | Transaction for Coinbase subscription                                           |
| `tx`                         | Default transaction type, uncategorized. Previously defined as the `send` type. |
| `unstaking_transfer`         | Funds from staked funds moved to primary account                                |
| `unsupported_asset_recovery` | Recover unsupported ERC-20s deposited to Coinbase on ethereum mainnet           |
| `unwrap_asset`               | Unwrap wrapped assets, e.g. cbETH, to wrappable assets, e.g. staked ETH         |
| `wrap_asset`                 | Wrap wrappable assets, e.g. staked ETH, to wrapped assets, e.g. cbETH           |

### 2024-FEB-13

Updated OAuth2 docs:

- [token expiration](./coinbase-app-access-and-refresh-tokens.md): Access tokens expire in 1 hour (not 2).
- [state requirements](/coinbase-app/docs/coinbase-app-reference#:~:text=Must%20be%20at%20least%208%20characters%20long): The `state` parameter must be at least 8 characters long.
- [account access](./coinbase-app-permissions.mdx#account-access): Access to user wallets now defined by a drop down on the consent page.
- [send limit flow](./coinbase-app-permissions.mdx#send-limits): `wallet:transactions:send` requires additional OAuth2 parameters and 2FA.
- [scopes](./permissions-scopes.md#supported-scopes): The scope `offline_access` returns a refresh token.

### 2024-FEB-09

Removed the deprecated endpoint, [Update Current User](./api-users.mdx): `PUT https://api.coinbase.com/v2/user`.

### 2024-FEB-02

Announced multiple changes to the [Transaction](./api-transactions.mdx) APIs.

- Feb 7: Select parameters are being deprecated, added, or updated.
- Mar 31: Deprecated parameters are being removed.

### 2024-JAN-23

Announced the upcoming Feb 15 deprecation of select [Account](./api-accounts.mdx) endpoints.

Also marked all [User](./api-users.mdx) endpoints as _having been_ deprecated.

| Deprecated API                                           |                                                                                                      | Recommended Workaround                                                                             |
| :------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------- |
| [Create Wallet](./api-accounts.mdx#create-wallet-deprecated)   | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | Transact on [Coinbase](https://www.coinbase.com/) or via [SIWC Transaction APIs](api-transactions) |
| [Update Account](./api-accounts.mdx#update-account-deprecated) | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | To update wallet name, contact [Coinbase Support](https://help.coinbase.com/en/contact-us)         |
| [Delete Account](./api-accounts.mdx#delete-account-deprecated) | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | To close account, visit your [Coinbase Account profile](https://accounts.coinbase.com/profile)     |

### 2023-OCT-23

Announced the upcoming Nov 30 deprecation of select [Buys](./api-buys.mdx) and [Sells](./api-sells.mdx) APIs:

| Deprecated API                                                                               |                                                                                                      | Recommended API                                                        |
| :------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| [Place Buy Order](./api-buys#place-buy-order.mdx) / [Place Sell Order](./api-sells.mdx#place-sell-order) | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | [Create Order](/advanced-trade/reference/retailbrokerageapi_postorder) |
| [List Buys](./api-buys.mdx#list-buys) / [List Sells](api-sells.mdx#list-sells)                         | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | [List Transactions](./api-transactions#list-transactions)                |
| [Show Buy](./api-buys.mdx#show-buy) / [Show Sell](./api-sells.mdx#show-sell)                             | <img src={require('../assets/images/arrow-12-16-808080.png').default} alt="Arrow pointing right." /> | [Show Transaction](./api-transactions.mdx#show-transaction)                  |



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-payment-methods.mdx -->

---
title: "Wallet API: Payment Methods (Deprecated)"
sidebar_label: "Payment Methods (Deprecated)"
slug: "api-payment-methods"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::announcement Replacing Payment Methods API
On **March 27, 2024** Coinbase App v2 Payment Methods API were replaced by v3 [Advanced Trade APIs](/advanced-trade/reference/retailbrokerageapi_getpaymentmethods).

Also, requests to v2 Payment Methods APIs now return an error response. See the [Advanced Trade documentation](/advanced-trade/docs/rest-api-overview) for support.
:::

## Table of Endpoints

| Name                                          | Method | Endpoint                                  | Legacy Scope                  | CDP API Key Scope |
| :-------------------------------------------- | :----- | :---------------------------------------- | :---------------------------- | :---------------- |
| [List Payment Methods](#list-payment-methods) | GET    | `/v2/payment-methods`                     | `wallet:payment-methods:read` | `view`            |
| [Show Payment Method](#show-payment-method)   | GET    | `/v2/payment-methods/:payment_method_id/` | `wallet:payment-methods:read` | `view`            |


## Overview

The **Payment Method resource** represents the different kinds of payment methods that can be used when buying and selling any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto).

As fiat accounts can be used for buying and selling, they have an associated payment method. This type of a payment method also has a `fiat_account` reference to the actual account.

### Supported Payment Types

#### Common Types

The following payment types are commonly used:

- `ach_bank_account` - Regular US bank account
- `sepa_bank_account` - European SEPA bank account
- `ideal_bank_account` - iDeal bank account (Europe)
- `fiat_account` - Fiat nominated Coinbase account
- `bank_wire` - Bank wire (US only)
- `credit_card` - Credit card (can't be used for buying/selling)
- `secure3d_card` - Secure3D verified payment card
- `eft_bank_account` - Canadian EFT bank account
- `interac` - Interac Online for Canadian bank accounts

#### Complete List

Coinbase App supports the following payment types:

```
PAYMENT_METHOD_TYPE_UNKNOWN = 0;
---
ACH = 11;
APPLE_PAY = 15;
CBIT = 34;
COINBASE_FIAT_ACCOUNT = 18;
DENEB_IMPS = 22;
DENEB_UPI = 21;
DIRECT_DEPOSIT_ACCOUNT = 19;
FEDWIRE = 1;
GIFTCARD = 23;
GOOGLE_PAY = 17;
IDEAL = 7;
INTERAC = 33;
INTRA_BANK = 2;
OPEN_BANKING = 30;
PAYPAL_ACCOUNT = 12;
PIX_DEPOSIT = 28;
PIX_WITHDRAWAL = 29;
QD = 8;
REMITLY = 14;
RTP = 16;
SEPA = 4;
SEPA_V2 = 26;
SG_FAST = 32;
SIGNET = 31;
SOFORT = 6;
SWIFT = 3;
UK = 5;
WORLDPAY_CARD = 13;
ZAAKPAY_MOBIKWIK = 20;
ZENGIN_DEPOSIT = 9;
ZENGIN_DEPOSIT_V2 = 25;
ZENGIN_WITHDRAWAL = 10;
ZENGIN_WITHDRAWAL_V2 = 24;
ZEPTO = 27;
```

### Deposit Limits

If the user the has optional `wallet:payment-methods:limits` permission, the `limits` field is embedded into payment method data. It contains information about buy, instant buy, sell, and deposit limits (there are no limits for withdrawals at this time).

As each one of these can have several limits, you should always look for the lowest remaining value when performing the relevant action.

| Parameter                                        | Description                               |
| :----------------------------------------------- | :---------------------------------------- |
| `id` _string_                                    | Resource ID                               |
| `type` _string, enumerable_                      | Payment method type                       |
| `Name` _string_                                  | Payment method name                       |
| `currency` _string_                              | Payment method's native currency          |
| `primary_buy` _boolean_                          | Is primary buying method?                 |
| `primary_sell` _boolean_                         | Is primary selling method?                |
| `allow_buy` _boolean_                            | Is buying allowed with this method?       |
| `allow_sell` _boolean_                           | Is selling allowed with this method?      |
| `instant_buy` _boolean_                          | Does this method allow for instant buys?  |
| `instant_sell` _boolean_                         | Does this method allow for instant sells? |
| `created_at` _timestamp_                         |                                           |
| `updated_at` _timestamp_                         |                                           |
| `resource` _string, constant_ **payment_method** |                                           |
| `resource_path` _string_                         |                                           |

#### Payment Method Info (default)

```json
{
  "id": "83562370-3e5c-51db-87da-752af5ab9559",
  "type": "ach_bank_account",
  "name": "International Bank *****1111",
  "currency": "USD",
  "primary_buy": true,
  "primary_sell": true,
  "allow_buy": true,
  "allow_sell": true,
  "allow_deposit": true,
  "allow_withdraw": true,
  "instant_buy": false,
  "instant_sell": false,
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-02-11T16:53:57-08:00",
  "resource": "payment_method",
  "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
}
```

#### Additional Payment Method Limit Info (`wallet:payment-methods:limits`)

```json
{
  ...
  "limits": {
    "buy": [
      {
        "period_in_days": 1,
        "total": {
          "amount": "3000.00",
          "currency": "USD"
        },
        "remaining": {
          "amount": "3000.00",
          "currency": "USD"
        }
      }
    ],
    "instant_buy": [
      {
        "period_in_days": 7,
        "total": {
          "amount": "0.00",
          "currency": "USD"
        },
        "remaining": {
          "amount": "0.00",
          "currency": "USD"
        }
      }
    ],
    "sell": [
      {
        "period_in_days": 1,
        "total": {
          "amount": "3000.00",
          "currency": "USD"
        },
        "remaining": {
          "amount": "3000.00",
          "currency": "USD"
        }
      }
    ],
    "deposit": [
      {
        "period_in_days": 1,
        "total": {
          "amount": "3000.00",
          "currency": "USD"
        },
        "remaining": {
          "amount": "3000.00",
          "currency": "USD"
        }
      }
    ]
  },
}
```

## List Payment Methods

Lists the current user's payment methods.

### HTTP Request

`GET https://api.coinbase.com/v2/payment-methods`

### Scopes

- `wallet:payment-methods:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/payment-methods \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

pms = client.payment_methods
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

pms = client.get_payment_methods()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getPaymentMethods(function (err, pms) {
  console.log(pms);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "127b4d76-a1a0-5de7-8185-3657d7b526ec",
      "type": "fiat_account",
      "name": "USD Wallet",
      "currency": "USD",
      "primary_buy": false,
      "primary_sell": false,
      "allow_buy": true,
      "allow_sell": true,
      "allow_deposit": true,
      "allow_withdraw": true,
      "instant_buy": true,
      "instant_sell": true,
      "created_at": "2015-02-24T14:30:30-08:00",
      "updated_at": "2015-02-24T14:30:30-08:00",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/127b4d76-a1a0-5de7-8185-3657d7b526ec",
      "fiat_account": {
        "id": "a077fff9-312b-559b-af98-146c33e27388",
        "resource": "account",
        "resource_path": "/v2/accounts/a077fff9-312b-559b-af98-146c33e27388"
      }
    },
    {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "type": "ach_bank_account",
      "name": "International Bank *****1111",
      "currency": "USD",
      "primary_buy": true,
      "primary_sell": true,
      "allow_buy": true,
      "allow_sell": true,
      "allow_deposit": true,
      "allow_withdraw": true,
      "instant_buy": false,
      "instant_sell": false,
      "created_at": "2015-01-31T20:49:02Z",
      "updated_at": "2015-02-11T16:53:57-08:00",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    }
  ]
}
```

## Show Payment Method

Get a single payment method (of the current user) by payment method ID.

### HTTP Request

`GET https://api.coinbase.com/v2/payment-methods/:payment_method_id/`

### Scopes

- `wallet:payment-methods:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559 /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

pm = client.payment_method("83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

pm = client.get_payment_method("83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getPaymentMethod(
  "83562370-3e5c-51db-87da-752af5ab9559",
  function (err, pm) {
    console.log(pm);
  }
);
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "83562370-3e5c-51db-87da-752af5ab9559",
    "type": "ach_bank_account",
    "name": "International Bank *****1111",
    "currency": "USD",
    "primary_buy": true,
    "primary_sell": true,
    "allow_buy": true,
    "allow_sell": true,
    "allow_deposit": true,
    "allow_withdraw": true,
    "instant_buy": false,
    "instant_sell": false,
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:53:57-08:00",
    "resource": "payment_method",
    "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/getting-started.mdx -->

---
title: "Getting Started with Coinbase App"
sidebar_label: "Getting Started"
slug: "getting-started"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import CDPAuthCreatingKeys     from '../../../projects/advanced-trade/docs/_snippet-cdp-auth-creating-keys.mdx';
import createCdpApiKeys from '../assets/images/cdp-key-create.png';

To get started with Coinbase App, [create an API key](#creating-api-keys) on the [Coinbase Developer Platform](https://portal.cdp.coinbase.com) (CDP). 

:::info
API Key authentication should only be used to access your own account. To securely access the accounts of other Coinbase users, use [Coinbase App (OAuth2)](./coinbase-app-overview.md).
:::


## Creating API Keys

To create a CDP API key:

1. Navigate to the [CDP Access page](https://portal.cdp.coinbase.com/access/api).
1. Select the **API Keys** tab.
1. Click the **Create API key** button.
1. Enter an API key nickname and click **Create & Download**.
1. Secure your private/public key pair in a safe location.

Use the **Configure** button to regenerate a key (by deleting and recrating), or building an alllowlist (by clicking edit and API restrictions).

:::caution 3rd party apps
CDP API keys may not yet be supported by all third-party applications.
:::

<img src={createCdpApiKeys} width="750" alt="" />



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/security.mdx -->

---
title: "Security Best Practices"
sidebar_label: "Security Best Practices"
slug: "security"
---

This page provides guidance on how you can manage your credentials.


## Storing Credentials Securely

Store your credentials securely. If someone obtains your `api_secret` with the `wallet:transfer:send` permission, they will be able to withdraw all the digital currency out of your account.

Avoid storing API keys in your source code repository. API keys are typically securely injected in your application runtime via environment variables. Learn more about environment variables at [The Twelve-Factor App](https://12factor.net/config). Separating credentials from your code base and database is always good practice.

API key access is turned off by default on all accounts. To implement an API key integration, you therefore must first enable it,and then take necessary precautions to store the API key securely. You can always regenerate your API key (or disable it) if you feel it has been compromised.


## Validating SSL Certificates

It is important that your application validates our SSL certificate when it connects over `https`. This helps prevent a [man-in-the-middle attack](http://en.wikipedia.org/wiki/Man-in-the-middle_attack). If you are using a client library, this may be turned on by default, but you should confirm this. Whenever you see 'verify SSL' you should always ensure it is set to true.


## Additional Key Security

For enhanced API key security, we recommend that you **allowlist IP addresses** that are permitted to make requests with a particular API key.

You can specify IP addresses to allowlist when [creating a new API key](./getting-started.mdx) or editing an existing one.

<figcaption><i>Click to enlarge</i></figcaption> <img src={require('../assets/images/edit-api-key.png').default} width="800" alt="Image of Coinbase Developer Platform" />



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-time.mdx -->

---
title: "Data API: Time"
sidebar_label: "Time"
slug: "api-time"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                  | Method | Endpoint   | Scope |
|:--------------------------------------|:-------|:-----------|:------|
| [Get Current Time](#get-current-time) | GET    | `/v2/time` | N/A   |


## Get Current Time

Get the API server time.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/time`

### Scopes

- _No permission required_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/time
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

time = client.time
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

time = client.get_time()
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY', 
                         'apiSecret': 'API SECRET'});

client.getTime(function(err, time) {
  console.log(time);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "iso": "2015-06-23T18:02:51Z",
    "epoch": 1435082571
  }
}
```


<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/quickstart.mdx -->

---
title: "Coinbase App Quickstart"
sidebar_label: "Quickstart"
slug: "quickstart"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This quickstart shows you how to make a Coinbase App request. 

- First, use a [CDP API Key](./getting-started.mdx) to generate a JSON Web Token (JWT) for an API. 
- Next, set the JWT as a Authorization Bearer header to make an authenticated request.

```
# Example request to get account
curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/v2/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9/addresses'
```


## Generating a JWT

Regardless of which [code snippet](#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
2. Replace the request method and the path you want to test. If the URI has a UUID in the path you should include that UUID here, e.g., `/v2/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9/addresses`.
3. Run the generation script that prints the command `export JWT=...`.
4. Run the generated command to save your JWT.

:::caution
Your JWT expires after 2 minutes, after which all requests are unauthenticated.
:::

:::caution
You must generate a different JWT for each unique API request.
:::


## Code Samples

The easiest way to generate a JWT is to use the built-in functions in our [Python SDK](/advanced-trade/docs/sdk-overview) as described below.

Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.

<Tabs>
<TabItem value="python_sdk" label="Python SDK">

1. Install the SDK.

    ```
    pip3 install coinbase-advanced-py
    ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `eval $(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/v2/accounts'`

```python
from coinbase import jwt_generator

api_key = "organizations/{org_id}/apiKeys/{key_id}"
api_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

request_method = "GET"
request_path = "/v2/accounts"

def main():
    jwt_uri = jwt_generator.format_jwt_uri(request_method, request_path)
    jwt_token = jwt_generator.build_rest_jwt(jwt_uri, api_key, api_secret)
    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="python" label="Python">

1. Install dependencies `PyJWT` and `cryptography`.

    ```
    pip install PyJWT
    pip install cryptography
    ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `eval $(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```python
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name       = "organizations/{org_id}/apiKeys/{key_id}"
key_secret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
request_method = "GET"
request_host   = "api.coinbase.com"
request_path   = "/v2/accounts"
def build_jwt(uri):
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)
    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
        'uri': uri,
    }
    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )
    return jwt_token
def main():
    uri = f"{request_method} {request_host}{request_path}"
    jwt_token = build_jwt(uri)
    print(f"export JWT={jwt_token}")
if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="go" label="Go">

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` to manage your dependencies.
4. In the console, run `go run main.go`. This outputs the command, `export JWT=`.
5. Set your JWT with the generated output, or export the JWT to the environment with `eval $(go run main.go)`.
6. Make your request, for example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```go
package main

import (
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"math"
	"math/big"
	"time"

	log "github.com/sirupsen/logrus"
	"gopkg.in/go-jose/go-jose.v2"
	"gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
	keyName       = "organizations/{org_id}/apiKeys/{key_id}"
	keySecret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
	requestMethod = "GET"
	requestHost   = "api.coinbase.com"
	requestPath   = "/v2/accounts"
)

type APIKeyClaims struct {
	*jwt.Claims
	URI string `json:"uri"`
}

func buildJWT(uri string) (string, error) {
	block, _ := pem.Decode([]byte(keySecret))
	if block == nil {
		return "", fmt.Errorf("jwt: Could not decode private key")
	}

	key, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	sig, err := jose.NewSigner(
		jose.SigningKey{Algorithm: jose.ES256, Key: key},
		(&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
	)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	cl := &APIKeyClaims{
		Claims: &jwt.Claims{
			Subject:   keyName,
			Issuer:    "cdp",
			NotBefore: jwt.NewNumericDate(time.Now()),
			Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
		},
		URI: uri,
	}
	jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}
	return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
	r, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}
	return r.String(), nil
}

func main() {
	uri := fmt.Sprintf("%s %s%s", requestMethod, requestHost, requestPath)

	jwt, err := buildJWT(uri)

	if err != nil {
		log.Errorf("error building jwt: %v", err)
	}
	fmt.Println("export JWT=" + jwt)
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

1. Install JSON Web Token:

    ```
    npm install jsonwebtoken
    ```
2. In the console, run: `node main.js` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `eval $(node main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```javascript
const { sign } = require('jsonwebtoken');
const crypto = require('crypto');

const key_name = 'organizations/{org_id}/apiKeys/{key_id}';
const key_secret = '-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n';
const request_method = 'GET';
const url = 'api.coinbase.com';
const request_path = '/v2/accounts';

const algorithm = 'ES256';
const uri = request_method + ' ' + url + request_path;

const token = sign(
    {
        iss: 'cdp',
        nbf: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 120,
        sub: key_name,
        uri,
    },
    key_secret,
    {
        algorithm,
        header: {
            kid: key_name,
            nonce: crypto.randomBytes(16).toString('hex'),
        },
    }
);
console.log('export JWT=' + token);
```

</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-prices.mdx -->

---
title: "Data API: Prices"
sidebar_label: "Prices"
slug: "api-prices"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                              | Method | Endpoint                         | Scope |
|:----------------------------------|:-------|:---------------------------------|:------|
| [Get Buy Price](#get-buy-price)   | GET    | `/v2/prices/:currency_pair/buy`  | N/A   |
| [Get Sell Price](#get-sell-price) | GET    | `/v2/prices/:currency_pair/sell` | N/A   |
| [Get Spot Price](#get-spot-price) | GET    | `/v2/prices/:currency_pair/spot` | N/A   |


## Get Buy Price

Get the total price to buy one bitcoin or ether.

Note that exchange rates fluctuates so the price is only correct for seconds at the time. This buy price includes standard Coinbase fee (1%) but excludes any other fees including bank fees. If you need more accurate price estimate for a specific payment method or amount, see buy bitcoin endpoint and `quote: true` option.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/prices/:currency_pair/buy`

### Scopes

- _No permission required_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/prices/BTC-USD/buy \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

price = client.buy_price({currency_pair: 'BTC-USD'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

price = client.get_buy_price(currency_pair = 'BTC-USD')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getBuyPrice({'currencyPair': 'BTC-USD'}, function(err, price) {
  console.log(price);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "amount": "1020.25",
    "currency": "USD"
  }
}
```

## Get Sell Price

Get the total price to sell one bitcoin or ether.

Note that exchange rates fluctuates so the price is only correct for seconds at the time. This sell price includes standard Coinbase fee (1%) but excludes any other fees including bank fees. If you need more accurate price estimate for a specific payment method or amount, see sell bitcoin endpoint and `quote: true` option.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/prices/:currency_pair/sell`

### Scopes

- _No permission required_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/prices/BTC-USD/sell /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

price = client.sell_price({currency_pair: 'BTC-USD'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

price = client.get_sell_price(currency_pair = 'BTC-USD')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getSellPrice({'currencyPair': 'BTC-USD'}, function(err, price) {
  console.log(price);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "amount": "1010.25",
    "currency": "USD"
  }
}
```

## Get Spot Price

Get the current market price for bitcoin. This is usually somewhere in between the buy and sell price.

Note that exchange rates fluctuates so the price is only correct for seconds at the time.

You can also get historic prices with `date` parameter.

**This endpoint doesn't require authentication.**

### HTTP Request

`GET https://api.coinbase.com/v2/prices/:currency_pair/spot`

### Scopes

- _No permission required_

### Arguments

| Parameter | Type   | Required | Description                                            |
|:----------|:-------|:---------|:-------------------------------------------------------|
| date      | string | Optional | For historic spot price, use format `YYYY-MM-DD` (UTC) |

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/prices/BTC-USD/spot \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

price = client.spot_price({currency_pair: 'BTC-USD'})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

price = client.get_spot_price(currency_pair = 'BTC-USD')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;
var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getSpotPrice({'currencyPair': 'BTC-USD'}, function(err, price) {
  console.log(price);
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "amount": "1015.00",
    "currency": "USD"
  }
}
```


<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-buys.mdx -->

---
title: "Wallet API: Buys (Deprecated)"
sidebar_label: "Buys (Deprecated)"
slug: "api-buys"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::announcement Deprecated Buys & Sells APIs on Nov 30 2023
On November 30, 2023, the Coinbase App v2 **Buys** and **[Sells](./api-sells.mdx)** APIs were deprecated.

- To create new buys/sells, use v3 [Advanced Trade APIs](/advanced-trade/docs/welcome). <br />
- To view existing orders, use v2 [Coinbase App Transaction API](./api-transactions.mdx).

| Deprecated API                                                                                         |                                                                                               | Recommended API                                                        |
| :----------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------- |
| [Place Buy Order](api-buys.mdx#place-buy-order) / [Place Sell Order](api-sells.mdx#place-sell-order) | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [Create Order](/advanced-trade/reference/retailbrokerageapi_postorder) |
| [List Buys](api-buys.mdx#list-buys) / [List Sells](api-sells.mdx#list-sells)                         | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [List Transactions](api-transactions#list-transactions)           |
| [Show Buy](api-buys.mdx#show-buy) / [Show Sell](api-sells.mdx#show-sell)                             | <img src={require('../assets/images/arrow-12-16.png').default} alt="Arrow pointing right." /> | [Show Transaction](api-transactions#show-transaction)             |

**Note**: To expand all available resources, pass `expand=all`.

- cURL example: `https://api.coinbase.com/v2/accounts/{AccountId}/transactions?expand[]=sell&expand[]=buy`
- Replace `AccountId` with your real Account ID to retrieve the fees.
  :::

## Table of Endpoints

| Name                                | Method | Endpoint                                       | Scope                |
| :---------------------------------- | :----- | :--------------------------------------------- | :------------------- |
| [Place Buy Order](#place-buy-order) | POST   | `/v2/accounts/:account_id/buys`                | `wallet:buys:create` |
| [Commit Buy](#commit-buy)           | POST   | `/v2/accounts/:account_id/buys/:buy_id/commit` | `wallet:buys:create` |
| [List Buys](#list-buys)             | GET    | `/v2/accounts/:account_id/buys`                | `wallet:buys:read`   |
| [Show Buy](#show-buy)               | GET    | `/v2/accounts/:account_id/buys/:buy_id`        | `wallet:buys:read`   |

## Overview

The **Buy resource** represents a purchase of any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto) using a payment method (either a bank or a fiat account). Each committed buy also has an associated transaction.

Buys can be started with `commit: false` which is useful when displaying the confirmation for a buy. These buys will never complete and receive an associated transaction unless they are committed separately.

When using this endpoint, it is possible that our system will not be able to process the buy as normal. If this is the case, our system will return a `400` error with an `id` of `unknown_error`.

| Parameter                             | Description                                                                                     |
| :------------------------------------ | :---------------------------------------------------------------------------------------------- |
| `id` _string_                         | Resource ID                                                                                     |
| `status` _string, enumerable_         | Status of the buy (valid values: `created`, `completed`, `canceled`)                            |
| `payment_method` _hash_               | Associated payment method (e.g., a bank, fiat account)                                          |
| `transaction` _hash_                  | Associated transaction (e.g., a bank, fiat account)                                             |
| `amount` _money hash_                 | Amount of supported digital asset                                                               |
| `total` _money hash_                  | Fiat amount with fees                                                                           |
| `subtotal` _money hash_               | Fiat amount without fees                                                                        |
| `fee` _money hash_                    | Fee associated to this buy                                                                      |
| `created_at` _timestamp_              |                                                                                                 |
| `updated_at` _timestamp_              |                                                                                                 |
| `resource` _string, constant **buy**_ |                                                                                                 |
| `resource_path` _string_              |                                                                                                 |
| `committed` _boolean_                 | Has this buy been committed?                                                                    |
| `instant` _boolean_                   | Was this buy executed instantly?                                                                |
| `payout_at` _timestamp, optional_     | When a buy isn't executed instantly, it receives a payout date for the time it will be executed |

### Example Buy Resource

```json
{
  "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
  "status": "completed",
  "payment_method": {
    "id": "83562370-3e5c-51db-87da-752af5ab9559",
    "resource": "payment_method",
    "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
  },
  "transaction": {
    "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
  },
  "amount": {
    "amount": "1.00000000",
    "currency": "BTC"
  },
  "total": {
    "amount": "10.25",
    "currency": "USD"
  },
  "subtotal": {
    "amount": "10.10",
    "currency": "USD"
  },
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-02-11T16:54:02-08:00",
  "resource": "buy",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
  "committed": true,
  "instant": false,
  "fee": {
    "amount": "0.15",
    "currency": "USD"
  },
  "payout_at": "2015-02-18T16:54:00-08:00"
}
```

## Place Buy Order

Buys a user-defined amount of any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto).

:::caution
The `account_id` to place the buy order must be the `account_id` associated with the cryptocurrency you would like to buy. If you prefer to use a fiat account as the payment method, use the `payment_method` parameter.
:::

You can define buy amounts with either the `amount` or `total` parameter:

- `amount` buys the amount in the defined asset. It's recommended that you use a cryptocurrency as the `currency` value, but if you specify a fiat currency, the amount is converted.

- `total` debits the defined total value, and after fees are taken out, buys the defined asset with the remaining amount. It's recommended that you use the currency of the payment method as the currency parameter, but if you specify a different currency, the amount is converted.

Given the price of digital currency depends on the time of the call and on the amount of purchase, it's recommended to use the `commit: false` parameter to create an uncommitted buy to show the confirmation for the user or get the final quote, and commit that with a separate request.

If you need to query the buy price without locking in the buy, you can use `quote: true` option. This returns an unsaved buy and unlike `commit: false`, this buy can't be completed. This option is useful when you need to show the detailed buy price quote for the user when they are filling a form or similar situation.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/buys`

### Scopes

- `wallet:buys:create`

### Arguments

| Parameter                 | Type    | Required | Description                                                                                                                       |
| :------------------------ | :------ | :------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| `amount`                  | string  | Required | Buy amount without fees                                                                                                           |
| `total`                   | string  | Optional | Buy amount with fees (alternative to `amount`)                                                                                    |
| `currency`                | string  | Required | Currency for the `amount`                                                                                                         |
| `payment_method`          | string  | Optional | ID of the payment method that should be used for the buy. Payment methods can be listed using the `GET /payment-methods` API call |
| `agree_btc_amount_varies` | boolean | Optional | Whether or not you would still like to buy if you have to wait for your money to arrive to lock in a price                        |
| `commit`                  | boolean | Optional | If `false`, this buy will not be immediately completed. Use the `commit` call to complete it. Default value: `true`               |
| `quote`                   | boolean | Optional | If `true`, the response returns an unsave buy for detailed price quote. Default value: `false`                                    |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/buys /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{"amount": "10", "currency": "BTC", "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"}'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

buy = client.buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                 {"amount" => "10",
                  "currency" => "BTC",
                  "payment_method" => "83562370-3e5c-51db-87da-752af5ab9559"})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

buy = client.buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                 amount="10",
                 currency="BTC",
                 payment_method="83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.buy(
      {
        amount: "10",
        currency: "BTC",
        payment_method: "83562370-3e5c-51db-87da-752af5ab9559",
      },
      function (err, tx) {
        console.log(tx);
      }
    );
  }
);
```

</TabItem>
</Tabs>

#### Response (201)

```json
{
  "data": {
    "id": "a333743d-184a-5b5b-abe8-11612fc44ab5",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "763d1401-fd17-5a18-852a-9cca5ac2f9c0",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "102.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "101.00",
      "currency": "USD"
    },
    "created_at": "2015-04-01T18:43:37-07:00",
    "updated_at": "2015-04-01T18:43:37-07:00",
    "resource": "buy",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/a333743d-184a-5b5b-abe8-11612fc44ab5",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "1.01",
      "currency": "USD"
    },
    "payout_at": "2015-04-07T18:43:37-07:00"
  }
}
```

## Commit Buy

Completes a buy that is created in `commit: false` state.

If the exchange rate has changed since the buy was created, this call will fail with the error _“The exchange rate updated while you were waiting. The new total is shown below”_.

The buy's total will also be updated. You can repeat the `/commit` call to accept the new values and start the buy at the new rates.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/buys/:buy_id/commit`

### Scopes

- `wallet:buys:create`

### Arguments

_None_

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/buys/a333743d-184a-5b5b-abe8-11612fc44ab5/commit /
  -X POST \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

buy = client.commit_buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                        'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

buy = client.commit_buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                        'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getBuy("a333743d-184a-5b5b-abe8-11612fc44ab5", function (err, tx) {
      tx.commit(function (err, resp) {
        console.log(resp);
      });
    });
  }
);
```

</TabItem>
</Tabs>

#### Response (200)

```json
{
  "data": {
    "id": "a333743d-184a-5b5b-abe8-11612fc44ab5",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "763d1401-fd17-5a18-852a-9cca5ac2f9c0",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "102.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "101.00",
      "currency": "USD"
    },
    "created_at": "2015-04-01T18:43:37-07:00",
    "updated_at": "2015-04-01T18:43:37-07:00",
    "resource": "buy",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/a333743d-184a-5b5b-abe8-11612fc44ab5",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "1.01",
      "currency": "USD"
    },
    "payout_at": "2015-04-07T18:43:37-07:00"
  }
}
```

## List Buys

Lists buys for an account.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/buys`

### Scopes

- `wallet:buys:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

buys = client.list_buys('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_buys('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getBuys(function (err, txs) {
      console.log(txs);
    });
  }
);
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "9e14d574-30fa-5d85-b02c-6be0d851d61d",
      "status": "created",
      "payment_method": {
        "id": "83562370-3e5c-51db-87da-752af5ab9559",
        "resource": "payment_method",
        "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
      },
      "transaction": {
        "id": "4117f7d6-5694-5b36-bc8f-847509850ea4",
        "resource": "transaction",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
      },
      "amount": {
        "amount": "10.00000000",
        "currency": "BTC"
      },
      "total": {
        "amount": "102.01",
        "currency": "USD"
      },
      "subtotal": {
        "amount": "101.00",
        "currency": "USD"
      },
      "created_at": "2015-03-26T23:43:59-07:00",
      "updated_at": "2015-03-26T23:44:09-07:00",
      "resource": "buy",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/9e14d574-30fa-5d85-b02c-6be0d851d61d",
      "committed": true,
      "instant": false,
      "fee": {
        "amount": "1.01",
        "currency": "USD"
      },
      "payout_at": "2015-04-01T23:43:59-07:00"
    }
  ]
}
```

## Show Buy

Show an individual buy.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/buys/:buy_id`

### Scopes

- `wallet:buys:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/dd3183eb-af1d-5f5d-a90d-cbff946435ff /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

buy = client.list_buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                      'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

buy = client.get_buy('2bbf394c-193b-5b2a-9155-3b4732659ede',
                     'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require("coinbase").Client;

var client = new Client({ apiKey: "API KEY", apiSecret: "API SECRET" });

client.getAccount(
  "2bbf394c-193b-5b2a-9155-3b4732659ede",
  function (err, account) {
    account.getBuy("dd3183eb-af1d-5f5d-a90d-cbff946435ff", function (err, tx) {
      console.log(tx);
    });
  }
);
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "9e14d574-30fa-5d85-b02c-6be0d851d61d",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "4117f7d6-5694-5b36-bc8f-847509850ea4",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "102.01",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "101.00",
      "currency": "USD"
    },
    "created_at": "2015-03-26T23:43:59-07:00",
    "updated_at": "2015-03-26T23:44:09-07:00",
    "resource": "buy",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/9e14d574-30fa-5d85-b02c-6be0d851d61d",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "1.01",
      "currency": "USD"
    },
    "payout_at": "2015-04-01T23:43:59-07:00"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-notifications.mdx -->

---
title: "Coinbase App Notifications API"
sidebar_label: "Notifications (Deprecated)"
slug: "api-notifications"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::announcement Notifications endpoint to be removed on Oct 1
On October 1, 2024, the Coinbase App v2 Notifications will be removed. Requests to v2/notifications will return 410 response.
:::

## Table of Endpoints

| Name                                        | Method | Endpoint                              | Scope                          |
|:--------------------------------------------|:-------|:--------------------------------------|:-------------------------------|
| [List Notifications](#list-notifications)   | GET    | `/v2/notifications`                   | `wallet:addresses:new-payment` |
| [Show Notification](#show-notification)     | GET    | `/v2/notifications/:notifications_id` | `wallet:notifications:read`    |


## Overview

Notifications let you subscribe to OAuth and API key updates. Notifications are sent as HTTP POST requests (webhooks) to a notification endpoint, which the developer can set for their OAuth application or API key settings.

Each notification contains the following information:

- Type - Action that triggered the event
- Data - Data of the resource at the time of the event
- Additional data - Additional data associated with the event
- User - Owner of the resource (useful with OAuth applications)
- Account - Account of the resource
- Delivery information

If notification delivery fails, it is re-tried hourly for up to three days. If you ever need to access notifications afterwards, you can query them using notification API endpoints. Content of the notification will not change even if the referenced resource changes over time.

To secure your notifications, you should obfuscate your notification URL and verify the origin of the callback by validating it against the Coinbase callback IP addresses and signature (`CB-SIGNATURE` header). See [notifications](./notifications.md).

Outbound notifications (webhooks) are versioned using the API version defined in the user's [CDP API settings](https://portal.cdp.coinbase.com/access/oauth).


## Supported Notification Types

Each type is named with `service:resource:action`. For example, confirming a buy on the Wallet API is `wallet:buys:completed`. 

To protect sensitive information, read permission for the resource is required to receive notifications for the resource type. For example, an API key needs to have `wallet:buys:read` permission to receive a notification for `wallet:buys:completed`. 

| Notification Type              | Required Permission                                      | Description                     |
|:-------------------------------|:---------------------------------------------------------|:--------------------------------|
| `ping`                         | _None_                                                   | Send at any time to verify that the notification URL works |
| `wallet:addresses:new-payment` | `wallet:addresses:read`                                  | New payment has been made to an **on-chain** crypto [address](./api-addresses.mdx) |
| `wallet:buys:created`          | `wallet:buys:read` or `wallet:buys:create`               | A buy has been created          |
| `wallet:buys:completed`        | `wallet:buys:read` or `wallet:buys:create`               | A buy has been completed        |
| `wallet:buys:canceled`         | `wallet:buys:read` or `wallet:buys:create`               | A buy has been canceled         |
| `wallet:sells:created`         | `wallet:sells:read` or `wallet:sells:create`             | A sell has been created         |
| `wallet:sells:completed`       | `wallet:sells:read` or `wallet:sells:create`             | A sell has been completed       |
| `wallet:sells:canceled`        | `wallet:sells:read` or `wallet:sells:create`             | A sell has been canceled        |
| `wallet:deposits:created`      | `wallet:deposits:read` or `wallet:deposits:create`       | A deposit has been created      |
| `wallet:deposits:completed`    | `wallet:deposits:read` or `wallet:deposits:create`       | A deposit has been completed    |
| `wallet:deposits:canceled`     | `wallet:deposits:read` or `wallet:deposits:create`       | A deposit has been canceled     |
| `wallet:withdrawals:created`   | `wallet:withdrawals:read` or `wallet:withdrawals:create` | A withdrawal has been created   |
| `wallet:withdrawals:completed` | `wallet:withdrawals:read` or `wallet:withdrawals:create` | A withdrawal has been completed |
| `wallet:withdrawals:canceled`  | `wallet:withdrawals:read` or `wallet:withdrawals:create` | A withdrawal has been canceled  |


| Fields                                         | Description                                                                   |
|:-----------------------------------------------|:------------------------------------------------------------------------------|
| `id` _string_                                  | Resource ID                                                                   |
| `type` _string_                                | Notification type                                                             |
| `data` _hash, optional_                        | Notification data. You can also use `resource` key with other available data. For `type: ping`, `data` is an empty hash. |
| `user` _hash_                                  | Related user (useful when separating OAuth notifications)                     |
| `account` _hash_                               | Related account                                                               |
| `delivery_attempts` _integer_                  | Number of delivery attempts (excluded from webhook)                           |
| `delivery_response` _hash_                     | Information about last delivery (excluded from webhook)                       |
| `created_at` _timestamp_                       |                                                                               |
| `updated_at` _timestamp_                       |                                                                               |
| `resource` _string, constant_ **notification** |                                                                               |
| `resource_path` _string_                       |                                                                               |
| `subscriber` _hash_                            | Separate different notification subsribers in list notifications endpoint     |



## New Payment 

New payment to a Bitcoin Address. 

### Scope 

`wallet:addresses:new-payment`

### Example Response

```json
{
  "id": "5a6956f9-94bb-5c15-99f3-a2a690347674",
  "type": "wallet:addresses:new-payment",
  "data": {
    "id": "c556eec7-53c2-576c-9158-c2eaa7c7ffca",
    "address": "mr4xYGzGMnw5tbbu2qyBBGdKwA4ktufbPy",
    "name": null,
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-01-31T20:49:02Z",
    "resource": "address",
    "resource_path": "/v2/accounts/c334783a-e72c-5e25-bf43-e182345f28c6/addresses/c556eec7-53c2-576c-9158-c2eaa7c7ffca"
  },
  "user": {
    "id": "5b5b60b6-2cd3-5f88-8539-3a78cd111b49",
    "resource": "user",
    "resource_path": "/v2/users/5b5b60b6-2cd3-5f88-8539-3a78cd111b49"
  },
  "account": {
    "id": "c334783a-e72c-5e25-bf43-e182345f28c6",
    "resource": "account",
    "resource_path": "/v2/accounts/c334783a-e72c-5e25-bf43-e182345f28c6"
  },
  "delivery_attempts": 0,
  "created_at": "2015-01-31T20:49:02Z",
  "resource": "notification",
  "resource_path": "/v2/notifications/5a6956f9-94bb-5c15-99f3-a2a690347674",
  "additional_data": {
    "hash": "749f267f9d238c978fe3e79a6c1f34070b0b8e5a3de8623d1bd144760bf79a5f",
    "amount": {
      "amount": "0.10000000",
      "currency": "BTC"
    },
    "transaction": {
      "id": "fe7b729d-62c6-5978-95ca-6cc1f9d23119",
      "resource": "transaction",
      "resource_path": "/v2/accounts/c334783a-e72c-5e25-bf43-e182345f28c6/transactions/fe7b729d-62c6-5978-95ca-6cc1f9d23119"
    }
  }
}
```

## Completed Buy 

### Scope 

`wallet:buys:completed`


### Example Response

```json
{
  "id": "6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338",
  "type": "wallet:buys:completed",
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "completed",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "1.00000000",
      "currency": "BTC"
    },
    "total": {
      "amount": "10.25",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.10",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "buy",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "instant": false,
    "fee": {
      "amount": "0.15",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  },
  "additional_data": {},
  "user": {
    "id": "f01c821e-bb35-555f-a4da-548672963119",
    "resource": "user",
    "resource_path": "/v2/users/f01c821e-bb35-555f-a4da-548672963119"
  },
  "account": {
    "id": "8d5f086c-d7d5-58ee-890e-c09b3d8d4434",
    "resource": "account",
    "resource_path": "/v2/accounts/8d5f086c-d7d5-58ee-890e-c09b3d8d4434"
  },
  "delivery_attempts": 0,
  "created_at": "2015-11-10T19:15:06Z",
  "resource": "notification",
  "resource_path": "/v2/notifications/6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338"
}
```

## List Notifications

Lists notifications where the current user was the subscriber (owner of the API key or OAuth application).

### HTTP Request

`GET https://api.coinbase.com/v2/notifications`

### Scope

`wallet:notifications:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/notifications \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

notifications = client.notifications
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

notifications = client.get_notifications()
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getNotifications({}, function(err, notifications) {
  console.log(notifications);
});
```

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
      {
      "id": "6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338",
      "type": "wallet:buys:completed",
      "data": {
        "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
        "status": "completed",
        "payment_method": {
          "id": "83562370-3e5c-51db-87da-752af5ab9559",
          "resource": "payment_method",
          "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
        },
        "transaction": {
          "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
          "resource": "transaction",
          "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
        },
        "amount": {
          "amount": "1.00000000",
          "currency": "BTC"
        },
        "total": {
          "amount": "10.25",
          "currency": "USD"
        },
        "subtotal": {
          "amount": "10.10",
          "currency": "USD"
        },
        "created_at": "2015-01-31T20:49:02Z",
        "updated_at": "2015-02-11T16:54:02-08:00",
        "resource": "buy",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
        "committed": true,
        "instant": false,
        "fees": [
          {
            "type": "coinbase",
            "amount": {
              "amount": "0.00",
              "currency": "USD"
            }
          },
          {
            "type": "bank",
            "amount": {
              "amount": "0.15",
              "currency": "USD"
            }
          }
        ],
        "payout_at": "2015-02-18T16:54:00-08:00"
      },
      "user": {
        "id": "f01c821e-bb35-555f-a4da-548672963119",
        "resource": "user",
        "resource_path": "/v2/users/f01c821e-bb35-555f-a4da-548672963119"
      },
      "account": {
        "id": "8d5f086c-d7d5-58ee-890e-c09b3d8d4434",
        "resource": "account",
        "resource_path": "/v2/accounts/8d5f086c-d7d5-58ee-890e-c09b3d8d4434"
      },
      "delivery_attempts": 0,
      "created_at": "2015-11-10T19:15:06Z",
      "resource": "notification",
      "resource_path": "/v2/notifications/6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338"
    }
  ]
}
```

</TabItem>
</Tabs>


## Show Notification

Show a notification for which the current user was a subsciber.

### HTTP Request

`GET https://api.coinbase.com/v2/notifications/:notifications_id`

### Scope

`wallet:notifications:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/notifications/0fdfb26e-bd26-5e1c-b055-7b935e57fa33 \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

notification = client.notification('0fdfb26e-bd26-5e1c-b055-7b935e57fa33')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

notification = client.get_notification('0fdfb26e-bd26-5e1c-b055-7b935e57fa33')
```

</TabItem>
<TabItem value="js" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getNotification('0fdfb26e-bd26-5e1c-b055-7b935e57fa33', function(err, notification) {
  console.log(notification);
});
```

</TabItem>
</Tabs>


#### Response

```json
{
  "data":
  {
    "id": "6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338",
    "type": "wallet:buys:completed",
    "data": {
      "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
      "status": "completed",
      "payment_method": {
        "id": "83562370-3e5c-51db-87da-752af5ab9559",
        "resource": "payment_method",
        "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
      },
      "transaction": {
        "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        "resource": "transaction",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
      },
      "amount": {
        "amount": "1.00000000",
        "currency": "BTC"
      },
      "total": {
        "amount": "10.25",
        "currency": "USD"
      },
      "subtotal": {
        "amount": "10.10",
        "currency": "USD"
      },
      "created_at": "2015-01-31T20:49:02Z",
      "updated_at": "2015-02-11T16:54:02-08:00",
      "resource": "buy",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
      "committed": true,
      "instant": false,
      "fee": {
        "amount": "0.15",
        "currency": "USD"
      },
      "payout_at": "2015-02-18T16:54:00-08:00"
    },
    "user": {
      "id": "f01c821e-bb35-555f-a4da-548672963119",
      "resource": "user",
      "resource_path": "/v2/users/f01c821e-bb35-555f-a4da-548672963119"
    },
    "account": {
      "id": "8d5f086c-d7d5-58ee-890e-c09b3d8d4434",
      "resource": "account",
      "resource_path": "/v2/accounts/8d5f086c-d7d5-58ee-890e-c09b3d8d4434"
    },
    "delivery_attempts": 0,
    "created_at": "2015-11-10T19:15:06Z",
    "resource": "notification",
    "resource_path": "/v2/notifications/6bf0ca21-0b2f-5e8a-b95e-7bd7eaccc338"
  }
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-postman.mdx -->

---
title: "Coinbase App Postman Files"
sidebar_label: "Postman Files"
slug: "api-postman"
hide_table_of_contents: false
---

The following Postman collection and environment files are available for download. 

- <a href="/downloads/coinbase-app/coinbase_app.postman_collection.json" download target="blank">Coinbase Developer Platform Coinbase App Postman Collection</a>
- <a href="/downloads/coinbase-app/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> 

We recommend testing authentication and relevant endpoints with these files as this will help our team troubleshoot any problems. 

:::info
Coinbase Cloud is in the process of being rebranded as Coinbase Developer Platform (CDP). Some documentation and naming conventions may still reflect the old branding.
:::

## Coinbase Developer Platform Collection

### Step 1: Download Postman

If don't have Postman installed, download and install [Postman](https://www.postman.com/downloads/) from their website.

### Step 2: Download and Import Files

1. **Download Collection:**
    - Download the <a href="/downloads/coinbase-app/coinbase_app.postman_collection.json" download target="blank">Coinbase Developer Platform Coinbase App Postman Collection</a>

2. **Import Collection into Postman:**
    - Open Postman.
    - Click on **Import** in the upper left corner.
    - Select the downloaded JSON file and import it.

### Step 3: Configure Environment Variables

Once the files are imported, you need to configure your environment variables.

1. **Download Postman Environemnt:**
   - <a href="/downloads/coinbase-app/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> 
2. **Import Environment into Postman:**
    - Open Postman.
    - Click on **Import** in the upper left corner.
    - Select the downloaded JSON file and import it.

3. **Select the Environment:**
   - In Postman, click on the environment dropdown near the top right of the screen and select "Coinbase Developer Platform Postman Environment".

4. **Set Up Variables:**
   - Click the Environments tab under My Workspace on the left of the screen
   - Select the "Coinbase Developer Platform Postman Environment".
   - Configure the following variables: <br /><br />

   | Variable     | Current value                                                                             |
   | ------------ | ----------------------------------------------------------------------------------------- |
   | `name`       | `"organizations/{ORG_ID}/apiKeys/{KEY_ID}"` (Include quotes)                              |
   | `privateKey` | `"-----BEGIN EC PRIVATE KEY-----\{KEY}\n-----END EC PRIVATE KEY-----\n"` (Include quotes) |

   :::note
   Ensure that the values are entered exactly as shown, including the quotes.
   :::

### Step 4: Authenticate and Test Endpoints

1. **Send Requests:**
   - Navigate to the "Collections" tab in Postman.
   - Expand the "Coinbase Developer Platform Postman Collection".
   - Select any request and click **Send** to test the endpoint.

2. **Check Responses:**
    - Ensure that the responses are as expected.
    - If you encounter any issues, refer to the detailed response messages to understand the problem.

### Important Notes

:::caution Confirm Environment
Make sure the correct environment is selected by checking the check mark to the right of the environment name in Postman.



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-addresses.mdx -->

---
title: "Wallet API: Addresses"
sidebar_label: "Addresses"
slug: "api-addresses"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                    | Method | Endpoint                                                      | Legacy Scope               | CDP API Key Scope |
|:----------------------------------------|:-------|:--------------------------------------------------------------|:---------------------------|:--------------------|
| [Create Address](#create-address)       | POST   | `/v2/accounts/:account_id/addresses`                          | `wallet:addresses:create`  | `transfer`          |
| [List Addresses](#list-addresses)       | GET    | `/v2/accounts/:account_id/addresses`                          | `wallet:addresses:read`    | `view`              |
| [Show Address](#show-address)           | GET    | `/v2/accounts/:account_id/addresses/:address_id`              | `wallet:addresses:read`    | `view`              |
| [List Transactions](#list-transactions) | GET    | `/v2/accounts/:account_id/addresses/:address_id/transactions` | `wallet:transactions:read` | `view`              |


## Overview

The **Address resource** represents an address for any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto). An account can have more than one address, but an address can only be associated with one account.

To be notified when an address receives a new transactions, you can [set up an API notification](./api-notifications.mdx).

| Parameter                                 | Description                                         |
|:------------------------------------------|:----------------------------------------------------|
| `id` _string_                             | Resource ID                                         |
| `address` _string_                        | Address for any [Coinbase supported asset](https://help.coinbase.com/en/coinbase/supported-crypto) |
| `name` _string, optional_                 | User defined label for the address                  |
| `network` _string_                        | Name of blockchain                                  |
| `created_at` _timestamp_                  |                                                     |
| `updated_at` _timestamp_                  |                                                     |
| `resource` _string, constant **address**_ |                                                     |
| `resource_path` _string_                  |                                                     |

#### Example Address Resource

```json
{
  "id": "dd3183eb-af1d-5f5d-a90d-cbff946435ff",
  "address": "mswUGcPHp1YnkLCgF1TtoryqSc5E9Q8xFa",
  "name": "One off payment",
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-03-31T17:25:29-07:00",
  "network": "bitcoin",
  "resource": "address",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff"
}
```


## Create Address

Creates a new address for an account. Addresses can be created for wallet account types.

:::tip
You can create an address with an empty `POST` request as all arguments are optional. This is handy if you need to create new receive addresses for an account on-demand.
:::

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/addresses`

### Scopes

- `wallet:addresses:create`

### Arguments

| Parameter | Type   | Required | Description   |
|:----------|:-------|:---------|:--------------|
| name      | string | Optional | Address label |

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/addresses \
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{"name": "New receive address"}'
}
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

address = client.create_address('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

address = client.create_address('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.createAddress(null, function(err, address) {
    console.log(address);
  });
});
```

</TabItem>
</Tabs>

#### Response (201)

```json
{
  "data": {
    "id": "dd3183eb-af1d-5f5d-a90d-cbff946435ff",
    "address": "mswUGcPHp1YnkLCgF1TtoryqSc5E9Q8xFa",
    "name": "New receive address",
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-03-31T17:25:29-07:00",
    "network": "bitcoin",
    "resource": "address",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff"
  }
}
```


## List Addresses

Lists addresses for an account.

:::caution
An address can only be associated with one account. See [Create Address](#create-address) to create new addresses.
:::

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/addresses`

### Scopes

- `wallet:addresses:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

addresses = client.addresses('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

addresses = client.get_addresses('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.getAddresses(function(err, addresses) {
    console.log(addresses);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "dd3183eb-af1d-5f5d-a90d-cbff946435ff",
      "address": "mswUGcPHp1YnkLCgF1TtoryqSc5E9Q8xFa",
      "name": null,
      "created_at": "2015-01-31T20:49:02Z",
      "updated_at": "2015-03-31T17:25:29-07:00",
      "network": "bitcoin",
      "resource": "address",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff"
    },
    {
      "id": "ac5c5f15-0b1d-54f5-8912-fecbf66c2a64",
      "address": "mgSvu1z1amUFAPkB4cUg8ujaDxKAfZBt5Q",
      "name": null,
      "created_at": "2015-03-31T17:23:52-07:00",
      "updated_at": "2015-01-31T20:49:02Z",
      "network": "bitcoin",
      "resource": "address",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/ac5c5f15-0b1d-54f5-8912-fecbf66c2a64"
    }
  ]
}
```


## Show Address

Get an single address for an account. A regular cryptocurrency address can be used in place of `address_id` but the address must be associated with the correct account.

:::caution
An address can only be associated with one account. See [Create Address](#create-address) to create new addresses.
:::

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/addresses/:address_id`

### Scopes

- `wallet:addresses:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

address = client.address('2bbf394c-193b-5b2a-9155-3b4732659ede', 'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

address = client.get_address('2bbf394c-193b-5b2a-9155-3b4732659ede', 'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.getAddress('dd3183eb-af1d-5f5d-a90d-cbff946435ff', function(err, address) {
    console.log(address);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "dd3183eb-af1d-5f5d-a90d-cbff946435ff",
    "address": "mswUGcPHp1YnkLCgF1TtoryqSc5E9Q8xFa",
    "name": null,
    "callback_url": null,
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-03-31T17:25:29-07:00",
    "network": "bitcoin",
    "resource": "address",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff/"
  }
}
```


## List Transactions

List transactions that have been sent to a specific address. A regular cryptocurrency address can be used in place of `address_id` but the address must be associated with the correct account.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/addresses/:address_id/transactions`

### Scopes

- `wallet:transactions:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/addresses/dd3183eb-af1d-5f5d-a90d-cbff946435ff/transactions \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

txs = client.address_transactions('2bbf394c-193b-5b2a-9155-3b4732659ede', 'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_address_transactions('2bbf394c-193b-5b2a-9155-3b4732659ede', 'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('82de7fcd-db72-5085-8ceb-bee19303080b', function(err, account) {
  account.getAddress('dd3183eb-af1d-5f5d-a90d-cbff946435ff', function(err, address) {
    console.log(address);
    address.getTransactions({}, function(err, txs) {
      console.log(txs);
    });
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
      "type": "send",
      "status": "completed",
      "amount": {
        "amount": "0.00100000",
        "currency": "BTC"
      },
      "native_amount": {
        "amount": "0.01",
        "currency": "USD"
      },
      "description": null,
      "created_at": "2015-03-11T13:13:35-07:00",
      "updated_at": "2015-03-26T15:55:43-07:00",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/57ffb4ae-0c59-5430-bcd3-3f98f797a66c",
      "network": {
        "status": "off_blockchain",
        "name": "bitcoin"
      },
      "from": {
        "id": "a6b4c2df-a62c-5d68-822a-dd4e2102e703",
        "resource": "user"
      }
    }
  ]
}
```



<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-key-authentication.mdx -->

---
title: "Coinbase App API Key Authentication"
sidebar_label: "API Key Authentication"
slug: "api-key-authentication"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

{/* Import reusable content snippets */}
import CDPAuthCreatingKeys     from '../../../projects/advanced-trade/docs/_snippet-cdp-auth-creating-keys.mdx';

**API Key authentication should only be used to access your own account.**  To securely access the accounts of other Coinbase users, use [Coinbase App (OAuth2)](./coinbase-app-overview.md)

:::info
Coinbase App APIs can be accessed using API Keys created on the Coinbase Development Platform (CDP). See [CDP API keys](#cdp-api-keys).
:::


## CDP API keys

Keys created on the Coinbase Development Platform (CDP) may not yet be supported by all third-party applications.

### Creating API Keys

<CDPAuthCreatingKeys />

### Making Requests

CDP API keys are used to generate a JSON Web Token (JWT) for an API. Once you've generated a JWT, set it as a Authorization Bearer header to make an authenticated request.

```
# Example request to get account
curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/v2/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9/addresses'
```

#### Generating a JWT

Regardless of which [code snippet](#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
2. Replace the request method and the path you want to test. If the URI has a UUID in the path you should include that UUID here, e.g., `/v2/accounts/f603f97c-37d7-4e58-b264-c27e9e393dd9/addresses`.
3. Run the generation script that prints the command `export JWT=...`.
4. Run the generated command to save your JWT.

:::caution
Your JWT expires after 2 minutes, after which all requests are unauthenticated.
:::

:::caution
You must generate a different JWT for each unique API request.
:::

#### Code Samples

The easiest way to generate a JWT is to use the built-in functions in our [Python SDK](/advanced-trade/docs/sdk-overview) as described below.

Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.

<Tabs>
<TabItem value="python_sdk" label="Python SDK">

1. Install the SDK.

    ```
    pip3 install coinbase-advanced-py
    ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```python
from coinbase import jwt_generator

api_key = "organizations/{org_id}/apiKeys/{key_id}"
api_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

request_method = "GET"
request_path = "/api/v3/brokerage/accounts"

def main():
    jwt_uri = jwt_generator.format_jwt_uri(request_method, request_path)
    jwt_token = jwt_generator.build_rest_jwt(jwt_uri, api_key, api_secret)
    print(jwt_token)

if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="python" label="Python">

1. Install dependencies `PyJWT` and `cryptography`.

    ```
    pip install PyJWT==2.8.0
    pip install cryptography==42.0.5
    ```

2. In the console, run: `python main.py` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(python main.py)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```python
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name       = "organizations/{org_id}/apiKeys/{key_id}"
key_secret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
request_method = "GET"
request_host   = "api.coinbase.com"
request_path   = "/api/v3/brokerage/accounts"
def build_jwt(uri):
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)
    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
        'uri': uri,
    }
    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )
    return jwt_token
def main():
    uri = f"{request_method} {request_host}{request_path}"
    jwt_token = build_jwt(uri)
    print(jwt_token)
if __name__ == "__main__":
    main()
```

</TabItem>
<TabItem value="go" label="Go">

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` to manage your dependencies.
4. In the console, run `go run main.go`. This outputs the command, `export JWT=`.
5. Set your JWT with the generated output, or export the JWT to the environment with `export JWT=$(go run main.go)`.
6. Make your request, for example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```go
package main

import (
	"crypto/rand"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"math"
	"math/big"
	"time"

	log "github.com/sirupsen/logrus"
	"gopkg.in/go-jose/go-jose.v2"
	"gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
	keyName       = "organizations/{org_id}/apiKeys/{key_id}"
	keySecret     = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
	requestMethod = "GET"
	requestHost   = "api.coinbase.com"
	requestPath   = "/api/v3/brokerage/accounts"
)

type APIKeyClaims struct {
	*jwt.Claims
	URI string `json:"uri"`
}

func buildJWT(uri string) (string, error) {
	block, _ := pem.Decode([]byte(keySecret))
	if block == nil {
		return "", fmt.Errorf("jwt: Could not decode private key")
	}

	key, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	sig, err := jose.NewSigner(
		jose.SigningKey{Algorithm: jose.ES256, Key: key},
		(&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
	)
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}

	cl := &APIKeyClaims{
		Claims: &jwt.Claims{
			Subject:   keyName,
			Issuer:    "cdp",
			NotBefore: jwt.NewNumericDate(time.Now()),
			Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
		},
		URI: uri,
	}
	jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
	if err != nil {
		return "", fmt.Errorf("jwt: %w", err)
	}
	return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
	r, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}
	return r.String(), nil
}

func main() {
	uri := fmt.Sprintf("%s %s%s", requestMethod, requestHost, requestPath)

	jwt, err := buildJWT(uri)

	if err != nil {
		log.Errorf("error building jwt: %v", err)
	}
	fmt.Println(jwt)
}
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

1. Install JSON Web Token:

    ```
    npm install jsonwebtoken
    ```
2. In the console, run: `node main.js` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(node main.js)`.
4. Make your request, example `curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'`

```javascript
const { sign } = require('jsonwebtoken');
const crypto = require('crypto');

const key_name       = 'organizations/{org_id}/apiKeys/{key_id}';
const key_secret = '-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n';
const request_method = 'GET';
const url = 'api.coinbase.com';
const request_path = '/api/v3/brokerage/accounts';

const algorithm = 'ES256';
const uri = request_method + ' ' + url + request_path;

const token = sign(
		{
			iss: 'cdp',
			nbf: Math.floor(Date.now() / 1000),
			exp: Math.floor(Date.now() / 1000) + 120,
			sub: key_name,
			uri,
		},
		key_secret,
		{
			algorithm,
			header: {
				kid: key_name,
                nonce: crypto.randomBytes(16).toString('hex'),
			},
		}
);
return token
```

</TabItem>
<TabItem value="php" label="PHP">

1. Add PHP dependencies with Composer (for JWT and environment variable management):

    ```
    composer require firebase/php-jwt
    composer require vlucas/phpdotenv
    ```

2. Run `generate_jwt.php` (or a filename of your choice).

3. Output the JWT to the command line and use a shell script to export it:

    ```
    #!/bin/bash
    export JWT=$(php generate_jwt.php)
    ```

4. Make your request, for example: 

    ```
    curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
    ```

<br />

> Code Snippet

```php
<?php
require 'vendor/autoload.php';
use Firebase\JWT\JWT;
use \Dotenv\Dotenv;

// Load environment variables
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

function buildJwt() {
    $keyName = $_ENV['NAME'];
    $keySecret = str_replace('\\n', "\n", $_ENV['PRIVATE_KEY']);
    $request_method = 'GET';
    $url = 'api.coinbase.com';
    $request_path = '/api/v3/brokerage/accounts';

    $uri = $request_method . ' ' . $url . $request_path;
    $privateKeyResource = openssl_pkey_get_private($keySecret);
    if (!$privateKeyResource) {
        throw new Exception('Private key is not valid');
    }
    $time = time();
    $nonce = bin2hex(random_bytes(16));  // Generate a 32-character hexadecimal nonce
    $jwtPayload = [
        'sub' => $keyName,
        'iss' => 'cdp',
        'nbf' => $time,
        'exp' => $time + 120,  // Token valid for 120 seconds from now
        'uri' => $uri,
    ];
    $headers = [
        'typ' => 'JWT',
        'alg' => 'ES256',
        'kid' => $keyName,  // Key ID header for JWT
        'nonce' => $nonce  // Nonce included in headers for added security
    ];
    $jwtToken = JWT::encode($jwtPayload, $privateKeyResource, 'ES256', $keyName, $headers);
    return $jwtToken;
}
```

</TabItem>
<TabItem value="java" label="Java">

1. Add Java dependencies to your project's Maven or Gradle configuration:

    ```
    nimbus-jose-jwt (version 9.39), bcpkix-jdk18on (version 1.78), and java-dotenv (version 5.2.2)
    ``` 

2. Compile your Java application to generates a JWT, for example:

    ```
    mvn compile
    ```

3. Capture and export the JWT output from your Java application to an environment variable:

    ```
    export JWT=$(mvn exec:java -Dexec.mainClass=Main)
    ```

4. Make an API Request, for example: 

    ```
    curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
    ```

<br />

> Code Snippet

```java
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;
import java.security.interfaces.ECPrivateKey;
import java.util.Map;
import java.util.HashMap;
import java.time.Instant;
import java.util.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.io.StringReader;
import java.security.PrivateKey;
import java.security.Security;
import io.github.cdimascio.dotenv.Dotenv;

public class Main {
    public static void main(String[] args) throws Exception {
        // Register BouncyCastle as a security providerx
        Security.addProvider(new BouncyCastleProvider());
        
        // Load environment variables
        Dotenv dotenv = Dotenv.load();
        String privateKeyPEM = dotenv.get("PRIVATE_KEY").replace("\\n", "\n");
        String name = dotenv.get("NAME");

        // create header object
        Map<String, Object> header = new HashMap<>();
        header.put("alg", "ES256");
        header.put("typ", "JWT");
        header.put("kid", name);
        header.put("nonce", String.valueOf(Instant.now().getEpochSecond()));

        // create uri string for current request
        String requestMethod = "GET";
        String url = "api.coinbase.com/api/v3/brokerage/accounts";
        String uri = requestMethod + " " + url;

        // create data object
        Map<String, Object> data = new HashMap<>();
        data.put("iss", "cdp");
        data.put("nbf", Instant.now().getEpochSecond());
        data.put("exp", Instant.now().getEpochSecond() + 120);
        data.put("sub", name);
        data.put("uri", uri);

        // Load private key
        PEMParser pemParser = new PEMParser(new StringReader(privateKeyPEM));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        Object object = pemParser.readObject();
        PrivateKey privateKey;

        if (object instanceof PrivateKey) {
            privateKey = (PrivateKey) object;
        } else if (object instanceof org.bouncycastle.openssl.PEMKeyPair) {
            privateKey = converter.getPrivateKey(((org.bouncycastle.openssl.PEMKeyPair) object).getPrivateKeyInfo());
        } else {
            throw new Exception("Unexpected private key format");
        }
        pemParser.close();

        // Convert to ECPrivateKey
        KeyFactory keyFactory = KeyFactory.getInstance("EC");
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());
        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);

        // create JWT
        JWTClaimsSet.Builder claimsSetBuilder = new JWTClaimsSet.Builder();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            claimsSetBuilder.claim(entry.getKey(), entry.getValue());
        }
        JWTClaimsSet claimsSet = claimsSetBuilder.build();

        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.ES256).customParams(header).build();
        SignedJWT signedJWT = new SignedJWT(jwsHeader, claimsSet);

        JWSSigner signer = new ECDSASigner(ecPrivateKey);
        signedJWT.sign(signer);

        String sJWT = signedJWT.serialize();
        System.out.println(sJWT);
    }
}
```

</TabItem>
<TabItem value="cpp" label="C++">

1. Install C++ project dependencies like so:

    ```
    apt-get update
    apt-get install libcurlpp-dev libssl-dev
    git clone https://github.com/Thalhammer/jwt-cpp
    cd jwt-cpp
    mkdir build && cd build
    cmake ..
    make
    make install
    ```

2. After you've saved your code to a file name, for example main.cpp, compile the program:

    ```
    g++ main.cpp -o myapp -lcurlpp -lcurl -lssl -lcrypto -I/usr/local/include -L/usr/local/lib -ljwt -std=c++17
    ```

3. Capture and export the JWT output from your C++ application to an environment variable:

    ```
    export JWT=$(./myapp)
    ``` 
4. Make an API Request, for example: 

    ```
    curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
    ```

<br />

> Code Snippet

```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <jwt-cpp/jwt.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/pem.h>
#include <openssl/rand.h>

std::string create_jwt() {
    // Set request parameters
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";
    std::string request_method = "GET";
    std::string url = "api.coinbase.com";
    std::string request_path = "/api/v3/brokerage/accounts";
    std::string uri = request_method + " " + url + request_path;

    // Generate a random nonce
    unsigned char nonce_raw[16];
    RAND_bytes(nonce_raw, sizeof(nonce_raw));
    std::string nonce(reinterpret_cast<char*>(nonce_raw), sizeof(nonce_raw));

    // Create JWT token
    auto token = jwt::create()
        .set_subject(key_name)
        .set_issuer("cdp")
        .set_not_before(std::chrono::system_clock::now())
        .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{120})
        .set_payload_claim("uri", jwt::claim(uri))
        .set_header_claim("kid", jwt::claim(key_name))
        .set_header_claim("nonce", jwt::claim(nonce))
        .sign(jwt::algorithm::es256(key_name, key_secret));

    return token;
};

int main() {
    try {
        std::string token = create_jwt();
        std::cout << "Generated JWT Token: " << token << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
};
```

</TabItem>
<TabItem value="dotnet" label="C#">

1. Create a new console project by running the following command:

    ```
    dotnet new console
    ```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.


3.  Install C# project dependencies like so:

        ```
        dotnet add package Microsoft.IdentityModel.Tokens
        dotnet add package System.IdentityModel.Tokens.Jwt
        dotnet add package Jose-JWT
        ```

4.  Build the project by running the following command:

    ```
    dotnet build
    ```

5.  Run the project by running the following command:

    ```
    dotnet run
    ```

<br />

> Code Snippet

```dotnet
// Environment is .NET 6.0 C#

using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using Jose;

namespace JwtTest {
    internal class Program {

        static Random random = new Random();

        static void Main(string[] args) {

            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string key = parseKey(cbPrivateKey);
            string endpoint = "api.coinbase.com/api/v3/brokerage/accounts";
            string token = generateToken(name, key, $"GET {endpoint}");

            Console.WriteLine($"Token is valid? {isTokenValid(token, name, key)}");
            Console.WriteLine("Call API...");
            Console.WriteLine(CallApiGET($"https://{endpoint}", token));

        }


        static string generateToken(string name, string secret, string uri) {
             var privateKeyBytes = Convert.FromBase64String(secret); // Assuming PEM is base64 encoded
             using var key = ECDsa.Create();
             key.ImportECPrivateKey(privateKeyBytes, out _);

             var payload = new Dictionary<string, object>
             {
                 { "sub", name },
                 { "iss", "coinbase-cloud" },
                 { "nbf", Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "exp", Convert.ToInt64((DateTime.UtcNow.AddMinutes(1) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "uri", uri }
             };

             var extraHeaders = new Dictionary<string, object>
             {
                 { "kid", name },
                 // add nonce to prevent replay attacks with a random 10 digit number
                 { "nonce", randomHex(10) },
                 { "typ", "JWT"}
             };

             var encodedToken = JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

            // print token
            Console.WriteLine(encodedToken);
            return encodedToken;
        }

        static bool isTokenValid(string token, string tokenId, string secret) {
            if (token == null)
                return false;

            var key = ECDsa.Create();
            key?.ImportECPrivateKey(Convert.FromBase64String(secret), out _);

            var securityKey = new ECDsaSecurityKey(key) { KeyId = tokenId };

            try {
                var tokenHandler = new JwtSecurityTokenHandler();
                tokenHandler.ValidateToken(token, new TokenValidationParameters {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = securityKey,
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ClockSkew = TimeSpan.Zero
                }, out var validatedToken);

                return true;
            } catch {
                return false;
            }
        }

        static string parseKey(string key) {
            List<string> keyLines = new List<string>();
            keyLines.AddRange(key.Split('\n', StringSplitOptions.RemoveEmptyEntries));

            keyLines.RemoveAt(0);
            keyLines.RemoveAt(keyLines.Count - 1);

            return String.Join("", keyLines);
        }


        static string randomHex(int digits) {
            byte[] buffer = new byte[digits / 2];
            random.NextBytes(buffer);
            string result = String.Concat(buffer.Select(x => x.ToString("X2")).ToArray());
            if (digits % 2 == 0)
                return result;
            return result + random.Next(16).ToString("X");
        }

        static string CallApiGET(string url, string bearerToken = "") {
           using (var client = new HttpClient()) {

                using (var request = new  HttpRequestMessage(HttpMethod.Get, url)) {
                    if (bearerToken != "")
                        request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", bearerToken);
                    var response = client.Send(request);

                    if (response != null)
                        return response.Content.ReadAsStringAsync().Result;
                    else
                        return "";

                }
           }
        }
    }
}
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

1. Install `ts-node` and TypeScript:

    ```bash
    npm install -g ts-node typescript
    npm install jsonwebtoken
    npm install @types/jsonwebtoken
    ```

2. Add the code to a TypeScript file named `main.ts`.

3. Run the TypeScript file directly using `ts-node`:

    ```bash
    ts-node main.ts
    ```

4. Capture and export the JWT output from your TypeScript application to an environment variable:

    ```bash
    export JWT=$(ts-node main.ts)
    ```

5. Make an API request, for example:

    ```bash
    curl -H "Authorization: Bearer $JWT" 'https://api.coinbase.com/api/v3/brokerage/accounts'
    ```

> Code Snippet
```typescript
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----`;
const requestMethod = 'GET';
const requestHost = 'api.coinbase.com';
const requestPath = '/api/v3/brokerage/accounts';
const algorithm = 'ES256';

const uri = `${requestMethod} ${requestHost}${requestPath}`;

const generateJWT = (): string => {
  const payload = {
    iss: 'cdp',
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: keyName,
    uri,
  };

  const header = {
    alg: algorithm,
    kid: keyName,
    nonce: crypto.randomBytes(16).toString('hex'),
  };

  return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
  const token = generateJWT();
  console.log(token);
};

main();
```

</TabItem>
</Tabs>


## Security Best Practices

### Storing Credentials Securely

Store your credentials securely. If someone obtains your `api_secret` with the `transfer` permission, they will be able to send all the digital currency out of your account.

Avoid storing API keys in your code base (which gets added to version control). The recommended best practice is to store them in environment variables. Learn more about environment variables [here](https://12factor.net/config). Separating credentials from your code base and database is always good practice.

API Key access is turned off by default on all accounts. To implement an API Key integration, you therefore must first enable it,and then take necessary precautions to store the API Key securely. You can always regenerate your API Key (or disable it) if you feel it has been compromised.

### Validating SSL Certificates

It is also very important that your application validates our SSL certificate when it connects over `https`. This helps prevent a [man in the middle attack](http://en.wikipedia.org/wiki/Man-in-the-middle_attack). If you are using a client library, this may be turned on by default, but you should confirm this. Whenever you see 'verify SSL' you should always ensure it is set to true.

### Additional Security for API Keys

For enhanced API Key security, we recommend that you **allowlist IP addresses** that are permitted to make requests with a particular API Key.

You can specify IP addresses to allowlist when [creating a new API Key or editing an existing one](https://portal.cdp.coinbase.com).

<figcaption><i>Click to enlarge</i></figcaption> <img src={require('../assets/images/edit-api-key.png').default} width="800" alt="Image of Coinbase Developer Platform" />




<!-- File: /Users/tinahe/docs/projects/coinbase-app/docs/api-withdrawals.mdx -->

---
title: "Wallet API: Withdrawals"
sidebar_label: "Withdrawals"
slug: "api-withdrawals"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Table of Endpoints

| Name                                        | Method | Endpoint                                                     | Legacy Scope                | CDP API Key Scope        |
|:--------------------------------------------|:-------|:-------------------------------------------------------------|:----------------------------|:---------------------------|
| [Withdraw Funds](#withdraw-funds)           | POST   | `/v2/accounts/:account_id/withdrawals`                       | `wallet:withdrawals:create` |`transfer`                  |
| [Commit Withdrawal](#commit-withdrawal)     | POST   | `/v2/accounts/:account_id/withdrawals/:withdrawal_id/commit` | `wallet:withdrawals:create` |`transfer`                  |
| [List Withdrawals](#list-withdrawals)       | GET    | `/v2/accounts/:account_id/withdrawals`                       | `wallet:withdrawals:read`   |`view`                      |
| [Show Withdrawal](#show-withdrawal)         | GET    | `/v2/accounts/:account_id/withdrawals/:withdrawal_id`        | `wallet:withdrawals:read`   |`view`                      |


## Overview

The **Withdrawal resource** represents a withdrawal of funds using a payment method (e.g., a bank). Each committed withdrawal also has an associated transaction.

:::tip
You can [start a withdrawal](#withdraw-funds) with the flag, `commit: false`, which is useful if you want to display a withdrawal before executing. Withdrawals made with `commit` set to `false` will not complete nor receive an associated transaction until a separate [commit](#commit-a-withdrawal) request is made.
:::

| Parameter                                    | Description                                                                |
|:---------------------------------------------|:---------------------------------------------------------------------------|
| `id` _string_                                | Resource ID                                                                |
| `status` _string, enumerable_                | Status of the withdrawal. Valid values: `created`, `completed`, `canceled` |
| `payment_method` _hash_                      | Associated payment method (e.g., a bank)                                   |
| `transaction` _hash_                         | Associated transaction (e.g., a bank, fiat account)                        |
| `amount` _money hash_                        | Amount                                                                     |
| `subtotal` _money hash_                      | Amount without fees                                                        |
| `fee` _money hash_                           | Fee associated to this withdrawal                                          |
| `created_at` _timestamp_                     |                                                                            |
| `updated_at` _timestamp_                     |                                                                            |
| `resource` _string, constant **withdrawal**_ |                                                                            |
| `resource_path` _string_                     |                                                                            |
| `committed` _boolean_                        | Has this withdrawal been committed?                                        |
| `payout_at` _timestamp, optional_            | When a withdrawal isn't executed instantly, it receives a payout date for the time it will be executed |

#### Example Withdrawal Resource

```json
{
  "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
  "status": "completed",
  "payment_method": {
    "id": "83562370-3e5c-51db-87da-752af5ab9559",
    "resource": "payment_method",
    "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
  },
  "transaction": {
    "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
    "resource": "transaction",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
  },
  "amount": {
    "amount": "10.00",
    "currency": "USD"
  },
  "subtotal": {
    "amount": "10.00",
    "currency": "USD"
  },
  "created_at": "2015-01-31T20:49:02Z",
  "updated_at": "2015-02-11T16:54:02-08:00",
  "resource": "withdrawal",
  "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df",
  "committed": true,
  "fee": {
    "amount": "0.00",
    "currency": "USD"
  },
  "payout_at": "2015-02-18T16:54:00-08:00"
}
```


## Withdraw Funds

Withdraws a user-defined amount of funds from a fiat account.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/withdrawals`

### Scopes

- `wallet:withdrawals:create`

### Arguments

| Parameter        | Type   | Required   | Description                                   |
|:-----------------|:-------|:-----------|:----------------------------------------------|
| `amount`         | string | Required   | Withdrawal amount                             |
| `currency`       | string | Required   | Currency for the `amount`                     |
| `payment_method` | string | Required   | ID of payment method used for the withdrawal. List Payment Methods: `GET /payment-methods` |
| `commit`         | boolean | Optional  | If `false`, this withdrawal is not immediately completed. Use the `commit` call to complete it. Default value: `true` |

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/withdrawals /
  -X POST \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c' \
  -d '{
    "amount": "10",
    "currency": "USD",
    "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"
  }'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

withdrawal = client.withdraw('2bbf394c-193b-5b2a-9155-3b4732659ede',
                             {"amount" => "10",
                              "currency" => "USD",
                              "payment_method" => "83562370-3e5c-51db-87da-752af5ab9559"})
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

withdraw = client.withdraw('2bbf394c-193b-5b2a-9155-3b4732659ede',
                           amount="10",
                           currency="USD",
                           payment_method="83562370-3e5c-51db-87da-752af5ab9559")
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.withdraw({"amount": "10",
                    "currency": "USD",
                    "payment_method": "83562370-3e5c-51db-87da-752af5ab9559"}, function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>

#### Response (201)

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "withdrawal",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```


## Commit Withdrawal

Completes a [withdrawal](#withdraw-funds) that is created in `commit: false` state.

### HTTP Request

`POST https://api.coinbase.com/v2/accounts/:account_id/withdrawals/:withdrawal_id/commit`

### Scopes

- `wallet:withdrawals:create`

### Arguments

_None_

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/82de7fcd-db72-5085-8ceb-bee19303080b/withdrawals/a333743d-184a-5b5b-abe8-11612fc44ab5/commit /
  -X POST /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

withdrawal = client.commit_withdrawal('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                      'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

withdrawal = client.commit_withdrawal('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                      'a333743d-184a-5b5b-abe8-11612fc44ab5')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getWithdrawal('a333743d-184a-5b5b-abe8-11612fc44ab5', function(err, tx) {
    tx.commit(function(err, resp) {
      console.log(resp);
    });
  });
});
```

</TabItem>
</Tabs>

> Response (200)

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "created",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "withdrawal",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```


## List Withdrawals

Lists withdrawals for an account.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/withdrawals`

### Scopes

- `wallet:withdrawals:read`

### Examples 

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

withdrawals = client.list_withdrawals('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

txs = client.get_withdrawals('2bbf394c-193b-5b2a-9155-3b4732659ede')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getWithdrawals(function(err, txs) {
    console.log(txs);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "pagination": {
    "ending_before": null,
    "starting_after": null,
    "limit": 25,
    "order": "desc",
    "previous_uri": null,
    "next_uri": null
  },
  "data": [
    {
      "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
      "status": "completed",
      "payment_method": {
        "id": "83562370-3e5c-51db-87da-752af5ab9559",
        "resource": "payment_method",
        "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
      },
      "transaction": {
        "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
        "resource": "transaction",
        "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
      },
      "amount": {
        "amount": "10.00",
        "currency": "USD"
      },
      "subtotal": {
        "amount": "10.00",
        "currency": "USD"
      },
      "created_at": "2015-01-31T20:49:02Z",
      "updated_at": "2015-02-11T16:54:02-08:00",
      "resource": "withdrawal",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df",
      "committed": true,
      "fee": {
        "amount": "0.00",
        "currency": "USD"
      },
      "payout_at": "2015-02-18T16:54:00-08:00"
    }
  ]
}
```

## Show Withdrawal

Get a single withdrawal.

### HTTP Request

`GET https://api.coinbase.com/v2/accounts/:account_id/withdrawals/:withdrawal_id`

### Scopes

- `wallet:withdrawals:read`

### Examples

#### Request

<Tabs>
<TabItem value="shell" label="Shell">

```shell
curl https://api.coinbase.com/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df /
  -H 'Authorization: Bearer abd90df5f27a7b170cd775abf89d632b350b7c1c9d53e08b340cd9832ce52c2c'
```

</TabItem>
<TabItem value="ruby" label="Ruby">

```ruby
require 'coinbase/wallet'
client = Coinbase::Wallet::Client.new(api_key: <api key>, api_secret: <api secret>)

withdrawal = client.list_withdrawal('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                    'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="python" label="Python">

```python
from coinbase.wallet.client import Client
client = Client(<api_key>, <api_secret>)

withdrawal = client.get_withdrawal('2bbf394c-193b-5b2a-9155-3b4732659ede',
                                   'dd3183eb-af1d-5f5d-a90d-cbff946435ff')
```

</TabItem>
<TabItem value="javascript" label="JavaScript">

```javascript
var Client = require('coinbase').Client;

var client = new Client({'apiKey': 'API KEY',
                         'apiSecret': 'API SECRET'});

client.getAccount('2bbf394c-193b-5b2a-9155-3b4732659ede', function(err, account) {
  account.getWithdrawal('dd3183eb-af1d-5f5d-a90d-cbff946435ff', function(err, tx) {
    console.log(tx);
  });
});
```

</TabItem>
</Tabs>

#### Response

```json
{
  "data": {
    "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
    "status": "completed",
    "payment_method": {
      "id": "83562370-3e5c-51db-87da-752af5ab9559",
      "resource": "payment_method",
      "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
    },
    "transaction": {
      "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
      "resource": "transaction",
      "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
    },
    "amount": {
      "amount": "10.00",
      "currency": "USD"
    },
    "subtotal": {
      "amount": "10.00",
      "currency": "USD"
    },
    "created_at": "2015-01-31T20:49:02Z",
    "updated_at": "2015-02-11T16:54:02-08:00",
    "resource": "withdrawal",
    "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/withdrawals/67e0eaec-07d7-54c4-a72c-2e92826897df",
    "committed": true,
    "fee": {
      "amount": "0.00",
      "currency": "USD"
    },
    "payout_at": "2015-02-18T16:54:00-08:00"
  }
}
```


<!-- File: /Users/tinahe/docs/projects/product-apis/docs/welcome.mdx -->

---
title: "Product APIs"
hide_title: true
sidebar_label: "Introduction"
slug: "welcome"
---

import ProductHeader from "@site/src/components/ProductHeader";
import CategoryProducts from "@site/src/components/CategoryProducts";
import { Divider } from "@cbhq/cds-web/layout/Divider";
import { PRODUCT_APIS_QUICKSTARTS, PRODUCT_APIS_PRODUCTS } from "@site/src/constants";
import QuickstartCarousel from "@components/QuickstartCarousel";

<ProductHeader
  title="Product APIs"
  subtitle="Get programmatic access to Coinbase products."
/>

<Divider spacingVertical={5} />

<QuickstartCarousel quickstarts={PRODUCT_APIS_QUICKSTARTS} />

<Divider spacingVertical={5} />

<CategoryProducts products={PRODUCT_APIS_PRODUCTS} title="Explore all Product APIs" />



<!-- File: /Users/tinahe/docs/projects/delegation/docs/polkadot-ledger-live-stake.mdx -->

---
title: "2: Stake DOT to Coinbase with Ledger Live"
slug: "polkadot-ledger-live-stake"
---

Nomination Pools are not currently supported on Ledger Live. You can use this guide to nominate directly to Coinbase validators or follow our guide to joining a pool through the Polkadot UI.

##### 1. Bond your DOT

1. Select _Accounts_ within [Ledger Live](https://www.ledger.com/ledger-live) and open your Polkadot account.

2. Select _Earn Rewards_ under _Nominations_ on the Polkadot account dashboard.

3. Select _Continue_.

    <img src={require('../assets/images/polkadot-04-bond-assets.png').default} width="60%" align="left" alt="" /><br clear="all" />

4. Select your _Rewards Destination_: 

   - Select _Bonded Balance_ to compound your rewards on your Stash account (most common), or
   - Select _Available Balance_ to leave your rewards un-bonded and spendable in your Polkadot account.

5. Under _Amount to bond_ enter the amount you would like to stake with Coinbase.

:::caution
Leave enough DOT unbonded in your account to pay for future transaction fees, such as sending and withdrawing your staked DOT.
:::

6. Select _Continue_ and follow the on-screen prompts to confirm the transaction on your Ledger device.

7. Wait for the transaction to complete for your DOT to be bonded and ready for delegation.

    <img src={require('../assets/images/polkadot-05-assets-bonded.png').default} width="60%" align="left" alt="" /><br clear="all" />


## 2. Stake your DOT with Coinbase

1. Once your transaction has completed to bond your DOT, select _Nominate_.

2. In the search field, search for _Coinbase_.

:::info COINBASE VALIDATOR INFORMATION
Nomination Pool name: Coinbase <br />
Nomination Pool address: 13UVJyLnbVp8c4FQeiGGKD7WwtbFCPFeNovxcHTq6aKnuAMY <br />
Nomination Pool ID: 58 <br /> <br />

Validator name: Coinbase  <br />
Validator addresses:  <br />
__01:__ `1VrKDfXunzstY5uxPpjArUbZekirGXcpMDYvCBJmjV1KdEm` <br />
__02:__ `16Dgcx1qJzp8kme1CWsySDf3JWd1oKtbChYVm2yAYqM44woY` <br />
__03:__ `12Yz9HPcF66pAGpwEW5cyFZ59TFeXFGVnkuxTphC3Lrap29z` <br />
__04:__ `12e1tkDgfF3GYdiTkRq1vunXrvvhpKq3BQZYbJ1haXHApQTn` <br />
__05:__ `12eKZbGJKVyHfTPkUs9MrJeGkbFrZRqzhKBBeRJ3G3YoWPun` <br />
__06:__ `12q76RYkETZ6UACiiznBicXgcXZ8EMFAuPv8QtfSrc6KSLYo` <br />
__07:__ `1A2ATy1FEu5yQ9ZzghPLsRckPQ7XLmq5MJQYcTvGnxGvCho` <br />
__08:__ `15V6NjwmKkZihe644Tyr8GVLxjEzBAHktf6ZcJCTx7RPCoYS` <br />
__09:__ `124YFXA3XoRs9Epcx3aRUSk3EKYaznocqMWfrMKtGjx8TJ2W` <br />
__10:__ `12ECDEb18Wiy4MoLn3NTM5zhJfDfpS4mLNvjHpcEr8ogGrMZ` <br />
__11:__ `12HFymxpDmi4XXPHaEMp74CNpRhkqwG5qxnrgikkhon1XMrj` <br />
__12:__ `12WmM98h4Ar6y7ZyyMKPXwSyuP5GSZvXTbEkDXm1tirbZFW4` <br />
__13:__ `13BN4WksoyexwDWhGsMMUbU5okehD19GzdyqL4DMPR2KkQpP` <br />
__14:__ `14XefeqDxiaVQEo7Xv7WBs3Wz8GZPes7DBjQxsNuxu683B9o` <br />
__15:__ `1486kNkPxvF7Pmgfr4MskGnn4p4KXCigMejv5Q7szMowioKK` <br />
__16:__ `14wFkAiTSxhUUdpkN37QMhZv6dYcURJVgSGwqDRd4TK2qhrL`

Enter each of the Coinbase validator addresses from the list above when staking. 

Selecting any or all validators from this list indicates your willingness to support those selected. The protocol automatically allocates your stake to a subset of the validators from your nominated list to participate and earn rewards each era. Selecting any or all validators increases your opportunities to earn rewards. See the [Polkadot FAQ](/delegation/docs/polkadot-faq) to learn more.
:::

3. Select _Continue_.

4. Confirm that the validator addresses are correct on your Ledger hardware device’s screen.

5. Select _Accept_ to confirm.

A verification page shows that your delegation is complete.

:::tip Congratulations! You are now staking with Coinbase.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/polkadot-ledger-live-fund.mdx -->

---
title: "1: Set Up and Fund Ledger Live with DOT"
slug: "polkadot-ledger-live-fund"
---

## 1. Install Polkadot App and Create Account

Ensure your Ledger hardware device is connected to your computer and unlocked, and that you are operating the latest version of Ledger Live.

1. In Ledger Live, select _Manager_.

2. Search for the Polkadot App in the catalog and follow the on-screen prompts to install the app on your hardware device.

3. Select _Accounts_ within Ledger Live and click _Add account_.

    <img src={require('../assets/images/polkadot-01-add-accounts.png').default} width="70%" align="left" alt="" /><br clear="all" />

4. Select _Continue_.

5. Follow the on-screen prompts to authorize the account with your Ledger hardware device.

6. Select _Add Account_.

## 2. Transfer DOT

This section assumes that the Polkadot App is installed.

1. In Ledger Live, select _Receive_.

    <img src={require('../assets/images/polkadot-02-receive.png').default} width="70%" align="left" alt="" /><br clear="all" /><br />

2. Under _Account to credit_ select the Polkadot account you just created.

3. Follow the on-screen prompts to authorize the transaction on your Ledger hardware device.

4. Copy the public hash code (address) of your Ledger Polkadot account that appears on the screen of Ledger Live.

5. Verify that the public hash for your account matches the address showing on the screen of your Ledger hardware device.

6. Select _Accept_ on your Ledger hardware device.

7. Select _Done_ on the confirmation screen.

8. Transfer your DOT from the exchange/wallet in which it is held by sending it to the Ledger Polkadot account public hash code (address) that you copied above.

Your DOT balance should now show in your Ledger Live Polkadot account. It may take up to 10 minutes to show the balance.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/bnb-native-wallet-bridge.mdx -->

---
title: "Bridge with Binance Wallet"
slug: "bnb-native-wallet-bridge"
---

This page explains how to use your Binance Wallet to bridge BNB from the BNB Smart Chain to the BNB Beacon Chain. 

:::info
The staking module for BNB Smart Chain (in the BNB Chain ecosystem) lives on the BNB Beacon Chain. 
:::

If you hold BNB on the BNB Smart Chain (and your address starts with `0x`), you need to bridge your BNB to the BNB Beacon Chain (where addresses start with `bnb`) before you can stake.

1. Open your Binance Wallet and click _Send_.

   <img src={require('../assets/images/bnb-bridge-binance-01-send.png').default} width="50%" alt="BNB." /><br clear="all" />

2. Click into the text input box right under _Address_ then click _My Accounts_ and select your BNB Beacon Chain Network address. You should see a message says that this transaction is a "Cross Chain Transfer to BNB Beacon Chain." 

   <img src={require('../assets/images/bnb-bridge-binance-02-address.png').default} width="50%" alt="BNB" /><br clear="all" />

3. Input the amount you want to transfer (don’t forget to leave at least 0.05BNB in your wallet for transaction fees!), click _Send_ and confirm the transaction.

   <img src={require('../assets/images/bnb-bridge-binance-03-amount.png').default} width="50%" alt="BNB" /><br clear="all" />

4. Navigate to [Stake with Binance Wallet](/delegation/docs/bnb-native-wallet-stake) to finish delegating BNB to the Coinbase validator!




<!-- File: /Users/tinahe/docs/projects/delegation/docs/polkadot-ui-fund.mdx -->

---
title: "1: Import Stash and Fund Polkadot UI with DOT"
slug: "polkadot-ui-fund"
---

## To import stash using a controller ...

### 1. Import your Stash

:::info
The current version of the Polkadot.js extension requires that you create an account before importing your own stash account. You can delete this account after importing your stash.
:::

##### Create Account

1. Install the [Polkadot.js extension](https://chrome.google.com/webstore/detail/polkadot%7Bjs%7D-extension/mopnmbcafieddcagagdcbnhejhlodfdd?hl=en).

2. Click the extension icon in your browser.

3. Click __+__ to add an account.

4. Copy the provided mnemonic seed phrase.

    <img src={require('../assets/images/polkadot-06-extension.png').default} width="60%" align="left" alt="Add Moonbeam." /><br clear="all" />

:::caution
Ensure that you store your mnemonic seed phrase somewhere safe where it cannot be lost or compromised. Your mnemonic seed phrase is the master key to your wallet; loss or compromise of your mnemonic seed phrase may result in permanent loss of your DOT.
:::

5. Enter a name and password for your account.

6. Click _Add the account with the generated seed_ to create the account. 

##### Import Stash Account

1. Click the plus sign (__+__) in the top right corner.

2. Click _Import account from pre-existing seed_.

3. Enter the mnemonic seed for your Stash account.

4. Enter a name and password for your account.

5. Click _Add the account with the supplied seed_.

### 2. Import or Create your Controller 

:::info
You can use your Stash as your Controller, but for security reasons, the Polkadot team recommends you create a separate Controller address. 

If you are importing an existing controller account, repeat [Import Stash Account](#import-stash-account) above, but with your Controller account information.
:::

1. Open the Polkadot.js extension.

2. Click the plus sign (__+__).

3. Click _Create New Account_.

4. Enter the password for your Stash account.

5. Click _Create derived account_.

6. Name the Controller account.

7. Create a password and verify it.

8. Click _Create derived account_.

9. Save your mnemonic seed phrase in a safe place .

:::caution
Ensure that you store your mnemonic seed phrase somewhere safe where it cannot be lost or compromised. Your mnemonic seed phrase is the master key to your Controller account; loss or compromise of your mnemonic seed phrase may result in permanent loss of your DOT.
:::

### 3. Transfer DOT to your Controller to pay for transaction fees

:::info
If your Controller account already has at least 5-10 DOTs in it, skip to [2: Stake DOT to Coinbase with Polkadot UI](./polkadot-ui-stake).
:::

1. Go to the [Polkadot UI](https://polkadot.js.org/apps/).

2. Click _TRANSFER_ under _ACCOUNTS_ in the top navigation.

3. Select your Stash as the _Send from_ account.

4. Select your Controller as the _Send to_ address.

5. Enter the amount of DOTs you want to transfer to your Controller.

:::caution
You need 1 DOT for your “existential deposit” (the minimum balance the network requires to keep your account open), and 5-10 DOTs to cover transaction fees.
:::

6. Click _Make Transfer_.

7. Click _Sign and Submit_.

8. Enter your Stash password in the pop-up.

9. Click _Sign the transaction_.


## To import stash using a Ledger hardware device ...

__Prerequisites__

- The Polkadot app is installed on your Ledger S or X hardware device.
- You are using Google Chrome or an equivalent browser.

### 1. Import your Stash

1. Plug your Ledger hardware wallet device into your computer, unlock the Ledger, and navigate to the Polkadot app.

2. Navigate to the Settings tab of the [Polkadot-JS app](https://polkadot.js.org/apps/#/settings) .

    <img src={require('../assets/images/polkadot-07-polkadot-js.png').default} width="100%" align="left" alt="Add Moonbeam." /><br clear="all" />

3. Select _Attach Ledger via WebUSB_ and select _Save_.

4. Navigate to the _Accounts_ tab of the [Polkadot-JS app](https://polkadot.js.org/apps/#/accounts).

5. Select _Add via Ledger_.

6. Assign an arbitrary name to your account.

7. Leave the standard settings so that the `Account Type = 0` and the `Address Index = 0`. For more, see [Using the Polkadot Ledger Application](https://wiki.polkadot.network/docs/learn-ledger)).

8. Select _Save_.

9. Ensure your Ledger is unlocked and that the Polkadot app is open on it.

10. Select your Ledger from the connection list and select _Connect_.

11. Select _Show address on hardware device_ from the 3-dot hamburger menu on your Ledger address. Your account address displays on your Ledger. 

12. Click on any of the block explorers to the right of the 3-dot menu. This opens an explorer view of your address. 

13. Confirm the address that the explorer opens with the address on your Ledger.

14. If they match, like the right button one time on your Ledger device to approve the address.

15. To send your DOTs to your new Ledger account, select the name of your account from your account list in the Polkadot UI.

16. In the pop-up sidebar, click the multicolored icon above your account name to copy your account address.

17. Send your DOTs from where they are stored to this address. Your DOT balance should now show in the Polkadot UI.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonbeam-native-app-stake.mdx -->

---
title: "2: Stake GLMR to with the Moonbeam app"
slug: "moonbeam-native-app-stake"
---

##### 1. Stake your GLMR with Coinbase

1. Select _Manage delegations_ on the Moonbeam app dashboard.

<img src={require('../assets/images/moonbean-02-manage-delegations.png').default} width="50%" alt="Add Moonbeam." /><br clear="all" />


2. If prompted, review any changes to the staking parameters and select *Close* on the pop-up window that appears.
3. On the staking dashboard, click _Select a collator_.

<img src={require('../assets/images/moonbean-03-select-collator.png').default} width="50%" alt="Add Moonbeam." /><br clear="all" />


4. In the _Search for a Collator_ field of the pop-up that appears, search for the Coinbase validator and click on it to select it.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/cardano-adalite-fund.mdx -->

---
title: "1: Set Up and Fund AdaLite Wallet"
slug: "cardano-adalite-fund"
---

<img src={require('../assets/images/cardano-adalite-fund-01.png').default} width="60%" alt="ADA" />

## To create a new Cardano wallet...

1. On the acccess homepage select _Mnemonic_.

2. On the Menmonic tab, select _Create New Wallet_.

3. Copy your mnemonic key phrase as it appears in the pop‐up window and close the pop-up window.

:::danger Remember your seed phrase
Ensure that you store your seed phrase somewhere safe where it cannot be lost or compromised. Your seed phrase is the master key to your wallet; loss or compromise of your seed phrase may result in permanent loss of your ADA.
:::

4. Back on the Mnemonic tab, enter your key phrase in the text box and select _Unlock_.

5. Select _Receive_ on the wallet homepage and copy the first address that appears under _My Addresses_.

6. Visit the exchange or wallet where your ADA was purchased/stored, and send your ADA from where it was purchased to the wallet address copied above.

   Following the network processing time, your ADA balance will show on the wallet homepage.


## To link an existing hardware wallet...

1. On the access homepage select _Hardware Wallet_.

2. Ensure your device is connected and unlocked, and select the _Unlock with_ option corresponding to your hardware device.

3. Follow the on‐screen prompts to connect your device to AdaLite, including approving the connection on your hardware wallet.

   Following the network processing time, your ADA balance will show on the wallet homepage.


## To link to an existing Cardano wallet...

1. On the access homepage select _Mnemonic_.

2. Enter the 12, 15, 24, or 27 word mnemonic seed phrase for your existing Cardano wallet, then select _Unlock_.

   Following the network processing time, your ADA balance will show on the wallet homepage.


## To link to an existing Cardano wallet with a Key file...

1. On the access homepage select _Key file_.

2. upload the encrypted JSON recovery file for your existing Cardano wallet, then choose _Select a key file_ to upload the JSON recovery file.

3. Select _Unlock_.
   
   Following the network processing time, your ADA balance will show on the wallet homepage.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/oasis-delegation.mdx -->

---
title: "Oasis Delegation Guide"
slug: "oasis-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

The [Oasis Protocol](https://oasisprotocol.org/) leverages secure computing technologies for safe data handling and analysis.

| Protocol Parameter      | Value          |
|:------------------------|:---------------|
| Minimum tokens to stake | 100 ROSE       |
| Warmup period           | None           |
| Unbonding period        | 14 days        |
| Service fee             | 10% of rewards |


:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Staking address: `oasis1qz86vltcdhjurzuvzfhkku4yaf7vf2umdvpwmtlv` <br />
Validator ID: `XkCriyrNwS3G4rzAXtG5B1nnvb5Ka1JtCku93VqeKAr`
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/crypto-delegation.mdx -->

---
title: "Crypto.org Chain Delegation Guide"
slug: "crypto-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[Crypto.org Chain](https://crypto.org/) is a Tendermint-based, public, open-source, and permissionless protocol intended to drive mass adoption of blockchain technology via easy-to-navigate financial tools.

You can learn more about Crypto.org Chain in our [protocol overview](https://www.coinbase.com/cloud/discover/protocol-guides/crypto-org-chain-guide).


| Protocol Parameter      | Value                                       |
|:------------------------|:--------------------------------------------|
| Minimum tokens to stake | No minimum                                  |
| Warmup period           | None                                        |
| Unbonding period        | 28 days, no rewards earned during this time |
| Service fee             | 6% of rewards                               |

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address : `crocncl1v2l4sq3lx998d43rt68nxthkzg56mmmke0u0gc`
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/eigenlayer-staking.mdx -->

---
title: "Delegating Restaked ETH with EigenLayer"
sidebar_label: "Delegating with EigenLayer"
slug: "eigenlayer-staking"
---


<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="stake, coinbase, eigenlayer" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="Delegating Restaked ETH with EigenLayer" />
    <meta property="og:image" content="https://placehold.co/600x400" />
</head>


## Step 1. Restaking on EigenLayer

:::tip Prerequisites 
You have a web3 wallet (e.g. Coinbase Wallet) and have previously [Native restaked Ether](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-user-guide/native-restaking/) (ETH) or have Liquid Staking Tokens (LST) that are restaked. Deposits for LSTs to be restaked are [currently paused](https://app.eigenlayer.xyz/status) as of date of posting (Apr 9, 2024).
:::

1. Navigate to the [EigenLayer App](https://app.eigenlayer.xyz) and click on the **Restake** tab.

    <img src={require('../assets/images/eigenlayer-restake.png').default} width="700" alt=""  />

2. Click on your relevant asset (i.e. ETH)

3. Select the **Amount** and click **deposit**. If all looks correct, confirm the transaction through your wallet

    <img src={require('../assets/images/eigenlayer-restake-deposit.png').default} width="700" alt=""  />

4. When navigating back to the **Restake** tab you should now see the total amount that was restaked. Over time, you will see EigenLayer Points earned from this restaking activity


## Step 2. Delegate to the Coinbase Operator

1. Navigate to the [EigenLayer Operator Tab](https://app.eigenlayer.xyz/operator)

    <img src={require('../assets/images/eigenlayer-operator.png').default} width="700" alt=""  />

2. Search for the Coinbase Operator by searching the name, then click on its Node Operator tile 


3. Click on **Delegate** to initiate the transaction 

    <img src={require('../assets/images/eigenlayer-operator-deposit.png').default} width="700" alt=""  />


4. Confirm the transaction on your wallet


:::tip Congratulations! 
You are now delegating to the Coinbase EigenLayer Operator.
Visit [Coinbase](https://www.coinbase.com/cloud) to learn more about our services.
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonriver-native-app-stake.mdx -->

---
title: "2: Stake MOVR to with the Moonriver app"
slug: "moonriver-native-app-stake"
---

##### 1. Stake your MOVR with Coinbase

1. Select _Manage delegations_ on the Moonriver app dashboard.

<img src={require('../assets/images/moonriver-02-manage-delegations.png').default} width="50%" alt="MOVR" /><br clear="all" />

2. If prompted, review any changes to the staking parameters and select _Close_ on the pop-up window that appears.

3. On the staking dashboard, click _Select a collator_.

<img src={require('../assets/images/moonriver-03-select-collator.png').default} width="50%" alt="MOVR" /><br clear="all" />

4. In the _Search for a Collator_ field of the pop-up that appears, search for the Coinbase validator and click on it to select it.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/sui-stake-sui-wallet.mdx -->

---
title: "Staking with Sui Wallet"
slug: "sui-stake-sui-wallet"
---

## Step 1: Setup and Fund Sui Wallet

1. Download [Sui Wallet browser extension](https://chrome.google.com/webstore/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil) and navigate to the extension.

    <img src={require('../assets/images/sui-browser-extension.png').default} width="50%" alt="SUI" /><br clear="all" />

2. Create a new wallet.

3. Create a password and write down your recovery phrase.

4. Fund your newly created address with desired SUI. 

:::tip
You can buy SUI directly from [Coinbase](https://www.coinbase.com/how-to-buy/sui).
:::

## Step 2: Delegate to Coinbase Validator

1. After creating and opening your Sui Wallet, click on **Stake & Earn SUI**.

    <img src={require('../assets/images/sui-sui-wallet-01-stake-n-earn.png').default} width="50%" alt="SUI" /><br clear="all" />

2. Navigate to [Coinbase validator](https://suiexplorer.com/validator/0x0350925241ae8d4083fe4b1104e14dd28d2ffeced9d7575551c50c41b99995fb) by scrolling down. (Sorting by name in descending order can help.)

    <img src={require('../assets/images/sui-sui-wallet-02-find-validator.png').default} width="50%" alt="SUI" /><br clear="all" />

3. Enter in your desired amount, and press **Stake Now**.

    <figcaption><i>APY in product may vary.</i></figcaption> <img src={require('../assets/images/sui-sui-wallet-03-enter-amount.png').default} width="50%" alt="SUI" /><br clear="all" />

4. Confirm the transaction. Once completed your funds should be delegated.

:::tip Congratulations! You are now staked to a Coinbase validator.
To learn more about Coinbase’s services, visit our [site](https://www.coinbase.com/cloud).
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/flow-flowport-stake.mdx -->

---
title: "2: Stake to Coinbase with Flow Port"
slug: "flow-flowport-stake"
---

## Delegate to Coinbase validators

1. Click on _Stake & Delegate_ in the left-hand navigation.

2. Click _Start Delegating_ in the Delegate modal on the right.

    <img src={require('../assets/images/flow-01-delegate.png').default} width="50%" alt="FLOW" /><br clear="all" />

3. Enter the Node Operator ID for the node you wish to delegate to. All have the same reward rate.

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Collection node ID: `48ba5aabeaf1a7c1bc6a96b20c8e9f6cbe7f6b3c77faec3b77fa66a630abf8c7` <br />
Consensus node ID: `a65461e68eae80c9bd9d8edc81857c7d2cd83ba9992433c468e9ef6515d32006` <br />
Verification node ID: `b17280bf57adad0de648d827a7ccbe81c74cf6a9cc44af4778587b133747a2f9`
:::

4. Enter the amount of FLOW you would like to stake in the _Stake Amount_ field.

:::caution
Please leave 5-10 FLOW unstaked in your account to cover transaction fees
:::

5. Click _Continue_.

6. Review the transaction details and approve the transaction.

7. Click _Submit_.

8. Verify the transaction in your wallet.

9. Wait for the transaction to complete.

10. In the _Stake and Delegate_ page you will now see your transaction in progress. Your delegation will be live at the next epoch. 



<!-- File: /Users/tinahe/docs/projects/delegation/docs/axelar-keplr-fund.mdx -->

---
title: "Fund your Keplr Wallet"
slug: "axelar-keplr-fund"
---

:::info
The instructions on this page are demonstrated on a Keplr wallet but apply to all supported IBC-compatible wallets (Keplr or Cosmostation).
:::

## Send native AXL purchased from an exchange to your wallet

This flow explains how to send native AXL tokens purchased on an exchange with a Keplr wallet.

:::caution
Read the exchange information carefully, as some exchanges list the native token, while others list ERC-20 representations. For more about the distinction, read [What Is wAXL?](https://axelar.network/blog/what-is-waxl-identifying-the-wrapped-erc-20-axl-token-by-ticker).
:::

1. Open the Keplr wallet browser extension and select Deposit.

2. Select the Axelar chain from the dropdown at top. 

3. Copy the wallet address under the wallet name (or click __Deposit__ to scan the QR code).

    <img src={require('../assets/images/axelar-keplr-wallet-axelar-chain.png').default} width="60%" alt="AXL" /><br clear="all" />

4. Navigate to the exchange from which you purchased your AXL, and send your tokens to the wallet address you just copied. 

    __Result:__ Your assets should appear in your Keplr wallet once the transaction is complete.


## Convert ERC-20 AXL to native AXL via satellite.money

This flow explains how to convert ERC-20 representations of the AXL token to the native AXL token via Axelar’s satellite. For more details, see [How to Convert ERC-20 AXL to Native AXL](https://axelar.network/blog/how-to-convert-erc-20-axl-to-native-axl?utm_source=notion-page&utm_campaign=token-holder-guide).

## Prerequisites

_An IBC-compatible wallet (Keplr or Cosmostation) and an Ethereum-based wallet funded with ERC-20 AXL (wAXL)._

1. Go to [satellite.money](http://satellite.money).

2. In the __From__ field, select your preferred EVM-compatible chain. In the __To__ field, select Axelar.

3. Click __Autofill__ to pre-fill your Axelar wallet address from Keplr wallet. 

    You must authorize the connection between Keplr wallet and satellite.money for this step. Follow the on-screen prompts.

4. Authorize the connection to your Ethereum wallet address when the pop-up appears.

5. Enter the amount you want to transfer and select __Generate Deposit Address__.

6. Confirm your transaction details.

7. Click __Send__ from `[`your Ethereum wallet`]`.

    __Result:__ Once the transaction is complete, you should receive native AXL in your Keplr wallet.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/axelar-flow.mdx -->

---
title: "Axelar Delegation Flow"
slug: "axelar-flow"
---

1. Go to your Keplr Wallet and log into your account. 

2. Under __Chains__, select __Axelar__. (On the dashboard, this appears on the left-hand side. In the browser extension, this appears at top.)

    <img src={require('../assets/images/axelar-keplr-chains.png').default} width="80%" alt="Select Axelar from the Chains dropdown in your Keplr wallet." /><br clear="all" />

3. Ensure your wallet has the number of Axelar tokens you wish to delegate, plus additional AXL to cover transaction fees. 

4. Find the __Coinbase__ validator from the list of validators and select __Manage__ to begin the Delegation process.

    <img src={require('../assets/images/axelar-keplr-coinbase-cloud.png').default} width="80%" alt="Select Axelar from the Chains dropdown in your Keplr wallet." /><br clear="all" />

5. Select __Delegate__ on the pop-up.

    <img src={require('../assets/images/axelar-keplr-delegate.png').default} width="80%" alt="Select Delegate on the pop-up." /><br clear="all" />

6. Enter the amount of AXL tokens you would like to delegate and click __Delegate__.  Note the [unbonding period](./axelar-delegation.md) before your AXL becomes liquid again. 

    <img src={require('../assets/images/axelar-keplr-staking-lock.png').default} width="80%" alt="Warning that staking will lock your funds for X number of days." /><br clear="all" />

7. Select __Approve__ in the confirmation popup (For this step, you need some AXL tokens in your unstaked balance to pay for transaction fees.)

    __Result:__ Once the transaction is confirmed, you should see your staked AXL tokens listed in “My Validators” in the “Staking” section on Keplr.




<!-- File: /Users/tinahe/docs/projects/delegation/docs/dydx-staking-keplr.mdx -->

---
title: "Staking dYdX with Keplr Wallet"
sidebar_label: "Staking with Keplr Wallet"
slug: "dydx-staking-keplr"
---

<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="stake, coinbase, dydx" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="dYdX Keplr Delegation Guide" />
    <meta property="og:image" content="https://images.ctfassets.net/q5ulk4bp65r7/3qSA7Pb6ihBCCGSsgd22R4/765d968fe9965d13c8cd2a679261928f/DYDX_-guide.png" />
</head>

Keplr wallet is an open-source web-based wallet for the Cosmos ecosystem, including all [IBC-enabled](https://tendermint.com/ibc/) Tendermint chains. It is accessible via the [Keplr dashboard](https://wallet.keplr.app/#/dashboard) and as a [Google Chrome browser extension](https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap). 

:::info
This tutorial assumes that you have cosmosDYDX stored on your Keplr wallet. If not, start with [dydx bridging](./dydx-bridging-ui).
:::

1. Navigate to the [Keplr wallet dashboard](https://wallet.keplr.app/#/dashboard) (which is also accessible in the Keplr extension by clicking **Manage Portfolio in Keplr Dashboard**.)

    <img src={require('../assets/images/dydx-keplr-manage-portfolio.png').default} width="350" alt="If you are not logged in to your Keplr wallet, you are prompted to enter the wallet password and click Unlock before being navigated to the dashboard."  />  

2. Click **Stake** on the left menu bar.

    <img src={require('../assets/images/dydx-keplr-dashboard-stake.png').default} width="750" alt="When you click Stake, you are prompted to search for an asset or blockchain."  />  

3. Search for and select the "dYdX" Network, then click **Staking** > **Stake**.

    :::caution
    Nothing happens at this step if you don't have cosmosDYDX in your Keplr wallet.
    :::

    <img src={require('../assets/images/dydx-keplr-select-network.png').default} width="750" alt="If you do not have DYDX in your Keplr wallet, nothing happens when you enter a search term."  />  

4. Copy/paste the Coinbase validator address, select the **Coinbase** validator, and click **Stake**.

    > _Coinbase validator address (hover for the copy icon)_
    ```
    dydxvaloper1v67nld0mc6ll2y66cttls2qpuwnx5704yu43l9
    ```

    <img src={require('../assets/images/dydx-keplr-search-and-select.png').default} width="750" alt="When you select the Coinbase validator, the delegation details display on the right and the Stake button displays underneath."  />  

5. Enter the amount to stake in DYDX or US dollars, and click **Stake** again. 

    <img src={require('../assets/images/dydx-keplr-stake-to-CB.png').default} width="350" alt="You can enter the amount in DYDX or US dollars."  />  

6. Approve the transaction in the Keplr wallet extension window that appears.

  :::tip Congratulations!
  You are now staked to a Coinbase validator.
  :::




<!-- File: /Users/tinahe/docs/projects/delegation/docs/cosmos-ledger-live-stake.mdx -->

---
title: "2: Stake to with Ledger Live"
slug: "cosmos-ledger-live-stake"
---

## 1. Delegate your ATOM 

1. Select Accounts within Ledger Live and open your Cosmos account.

2. Under _Delegation(s)_ on the Cosmos account dashboard select _Earn Rewards_.

3. On the pop-up screen, select _Continue_.

4. On the Validators screen, click in the search box to _Search by name or address..._ 

    <img src={require('../assets/images/cosmos-02-delegate-ledger-live.png').default} width="80%" alt="Cosmos" /><br clear="all" />

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address : `cosmosvaloper1crqm3598z6qmyn2kkcl9dz7uqs4qdqnr6s8jdn`
:::

5. Enter Coinbase's validator address: `cosmosvaloper1crqm3598z6qmyn2kkcl9dz7uqs4qdqnr6s8jdn`.

6. To the right of the estimated yield for the Coinbase validator, enter the amount of ATOM you would like to delegate and click _Continue_.

7. Confirm that the validator address is correct on the screen of your Ledger hardware device, and, if so, select to confirm.

A verification page will show that your delegation is complete.

:::tip Congratulations! You are now staked to a Coinbase validator.
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/dydx-bridging-ui.mdx -->

---
title: "Bridging dYdX with the UI"
sidebar_label: "Bridging with the UI"
slug: "dydx-bridging-ui"
---

<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="bridge, coinbase, dydx" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="dYdX Bridging Guide" />
    <meta property="og:image" content="https://images.ctfassets.net/q5ulk4bp65r7/3qSA7Pb6ihBCCGSsgd22R4/765d968fe9965d13c8cd2a679261928f/DYDX_-guide.png" />
</head>

This page explains how to migrate ethDYDX (e.g., in a Coinbase Wallet) to cosmosDYDX (in a Keplr wallet) by bridging the Ethereum and dYdX blockchains. See the [dYdX docs](https://www.dydx.foundation/how-to-bridge/overview).

## Step 0. Prerequisites

- An Ethereum wallet (e.g., Coinbase Wallet) funded with ETH with which to swap for ethDYDX and pay for transactions.
- A Tendermint wallet (e.g., Keplr Wallet).
- Residency in a jurisdiction that allows access to https://bridge.dydx.trade/.

## Step 1. Fund Wallet with ethDYDX

1. Start with an Ethereum wallet (e.g., Coinbase Wallet), and if needed, swap ETH for dYdX (i.e., ethDYDX).

    <img src={require('../assets/images/dydx-cbwallet-swap.png').default} width="300" alt="This step assumes that you are logged into your Coinbase wallet or a wallet like it. The goal is to hold DYDX, also called ethDYDX, in your Ethereum wallet. If you don't have ethDYDX but have ETH, you can swap ETH for ethDYDX. When you click the Swap button, you are prompted to enter an amount to swap."  />  

2. Swap for the desired amount.

    <img src={require('../assets/images/dydx-cbwallet-buy.png').default} width="300" alt="Enter the amount in US dollars that you want to swap. To enter the amount in DYDX, click the up/down arrow to the right."  /> 


## Step 2. Configure Keplr Wallet

1. Download the Keplr extension and navigate to the extension on your browser. 

2. Click on **Manage Chain Visibility** from the hamburger menu at top left. 

    <img src={require('../assets/images/dydx-keplr-manage-network.png').default} width="300" alt="When you click on Manage Chain Visibility, a new window opens called Select Chains."  />

3. Search for "dydx", check the box, and click **Save**. This adds DYDX (i.e., cosmosDYDX) to your list of available balances.

    <img src={require('../assets/images/dydx-keplr-network-search.png').default} width="300" alt="Before searching, you may see Cosmos Hub selected by default. Search for, select, and save dYdX to your list of chains."  />

4. Copy your cosmosDYDX address (by hovering over the copy icon for DYDX) and save for later.

    <img src={require('../assets/images/dydx-keplr-address.png').default} width="300" alt="When you hover over the copy icon by DYDX, your cosmosDYDX address display. Click to copy."  />


## Step 3. Bridge using UI

1. Navigate to https://bridge.dydx.trade/ 

    :::note IP/Country Block
    U.S. users cannot access this website and will see the following message:

    _Because you appear to be a resident of, or trading from, a jurisdiction that violates our terms of use, or have engaged in activity that violates our terms of use, you have been blocked. You may withdraw your funds from the protocol at any time._
    :::

2. Click **Connect wallet** (at top right) to connect your wallet funded with ethDYDX (e.g., Coinbase Wallet). When prompted, sign two transactions verifying the wallet. This generates a cosmosDYDX address from which to send DYDX. 

    <img src={require('../assets/images/dydx-ui-connect-wallet.png').default} width="750" alt="The goal is to convert ethDYDX in your Coinbase Wallet to cosmosDYDX in your Keplr wallet. To do this, connect your Coinbase Wallet funded with ethDYDX."  />

3. Enter the amount you wish to migrate to your Keplr wallet. Then select **Send to another dYdX Chain Address** and enter enter the Keplr wallet cosmosDYDX address you saved above. 

    :::danger 
    Coinbase does not recommend the first option, "Generated dYdX Chain address via wallet signature," unless absolutely necessary. If your connected wallet does not support cosmosDYDX, you may have trouble finding and using your funds. 
    :::

    <img src={require('../assets/images/dydx-ui-select-address.png').default} width="750" alt="Enter the amount of ethDYDX to migrate."  />

4. Click **Preview migration**, and if everything looks acceptable, click **Approve allowance**. Confirm and approve the transactions. 

    <img src={require('../assets/images/dydx-ui-approve-allowance.png').default} width="750" alt="You are shown the amount of wrapped ethDYDX and cosmosDYDX."  />

5. Read and confirm the final remarks, then select **Confirm Migration**, and approve the final transaction. 

    <img src={require('../assets/images/dydx-ui-approve-migration.png').default} width="750" alt="Check that you understand, first, that it may take 24-48 hours until your tokens are available on the dYdX chain, and second, that your ethDYDX will be permanently locked in the wethDYDX smart contract and irrecoverable. "  />

    :::tip Congratulations! 
    Once your funds are transferred, see [Staking dYdX with Keplr Wallet](./dydx-staking-keplr.mdx).
    :::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/cardano-daedalus-stake.mdx -->

---
title: "2: Stake to with Daedalus"
slug: "cardano-daedalus-stake"
---

##### Stake to our public validator

<img src={require('../assets/images/cardano-daedalus-stake-01.png').default} width="60%" alt="" /><br clear="all" />

1. In Daedalus, select the network icon on the left menu to enter the Delegation center.

<img src={require('../assets/images/cardano-daedalus-stake-02.png').default} width="60%" alt="" /><br clear="all" />

2. Hover over the third epoch listed to the right of your wallet balance and select the _DELEGATE_ button that appears and select _Continue_.

3. Choose the wallet you would like to delegate from (if you have multiple) and select _Continue_.

4. In the _Search stake pools_ field enter the Coinbase Stake Pool Ticker: or Pool ID: `66c1296e3bee372fc37282535eb45710d9c8b96b05248d7ea636352f`.

:::info COINBASE VALIDATOR INFORMATION
Stake pool name: Coinbase <br />
Stake pool ticker: CLOUD<br />
Stake pool ID: `6804118fe78be9bf9213b9e829803952be87814d28b305fa52bf11d9`
:::

5. Click the pool icon that appears and select _Delegate_.

6. Enter your wallet password, and select _Continue_.


:::tip  Congratulations! You are now staked to a Coinbase validator.
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/aptos-petra-connect-ledger.mdx -->

---
title: "Connecting Ledger Live to Your Petra Wallet"
sidebar_label: "Connecting Ledger to Petra"
slug: "aptos-petra-connect-ledger"
hide_table_of_contents: false
---

This page explains how to connect Ledger Live to your Petra Wallet.

Ledger Live is a mobile and desktop application that works in tandem with a Ledger hardware device to manage digital assets held in cold storage. 


## Step 1. Install

This section explains how to install the Aptos app on your Ledger Live. It assumes that you have Ledger Live installed.

1. Open [Ledger Live](https://www.ledger.com/ledger-live).

    <img src={require('../assets/images/aptos-ledger-live.png').default} width="500" alt=""  />  

2. Connect your Ledger to your computer and unlock it with your PIN.

3. Navigate to **My Ledger**, search for Aptos in the App catalog and install it.

**Result**: Ledger Live should display Aptos as installed.


## Step 2. Connect

This section explains how to connect Ledger Live to Petra. It assumes that you have [created and funded](./aptos-petra-stake.mdx) a Petra Aptos Wallet. 

1. Open your Petra Wallet and click the avatar at the top right. 

    <img src={require('../assets/images/aptos-ledger-01-avatar.png').default} width="250" alt=""  />  

2. Click **Add Account**.

    <img src={require('../assets/images/aptos-ledger-02-add-account.png').default} width="250" alt=""  />  

3. Click **Import from Ledger**.

    <img src={require('../assets/images/aptos-ledger-03-import-from-ledger.png').default} width="250" alt=""  />  

4. Click **Pair**. 

    <img src={require('../assets/images/aptos-ledger-04-pair.png').default} width="250" alt=""  />  

5. Select your Ledger device and click **Connect**.

    <img src={require('../assets/images/aptos-ledger-05-connect.png').default} width="500" alt=""  />  

6. Select an account address then click **Add account**.

    <img src={require('../assets/images/aptos-ledger-06-select-address.png').default} width="250" alt=""  />  

7. Click Settings, select your new account, and rename it to something meaningful.

    <img src={require('../assets/images/aptos-ledger-07-rename-account.png').default} width="250" alt=""  />  

8. See [Step 2. Connect and Stake](./aptos-petra-stake.mdx#step-2-connect-and-stake) to stake APT with your Petra Wallet.

{/* <!---
 ## Step 3. Stake

This section explains how to stake to a Coinbase validator. It assumes that you have created and funded a Petra Aptos Wallet.

1. Go to the [Aptos Explorer](https://explorer.aptoslabs.com/?network=mainnet)

2. Click **Connect Wallet** and select **Petra**.

    <img src={require('../assets/images/aptos-petra-2-02-connect.png').default} width="700" alt=""  />  

3. Search for and select the **Coinbase** node.

4. Click **Stake** to stake APT on this validator.


:::tip Congratulations! You are now staked to a Coinbase validator.
::: 
---> */}



<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-faq.mdx -->

---
title: "Provenance FAQ"
slug: "provenance-faq"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

## What are Provenance Blockchain's inflation and reward rates`*`?
The Provenance Blockchain protocol is non-inflationary, meaning that all rewards are based on transaction volume. Transaction fees are collected globally and distributed in proportion to stake, not based on the fees associated with the specific blocks produced by a validator.

| Behavior type      | Criteria                                               | Punishment                      |
|:-------------------|:-------------------------------------------------------|:--------------------------------|
| Excessive downtime | Missing more than 50% of 32000 blocks                  | 1% of all HASH on the validator |
| Double signing     | Proposing more than one block at the same block height | 5% of all HASH on the validator |

`*` Reward rates published by Coinbase are estimates based on publicly available information from third-party sources. Coinbase has not verified and does not guarantee the accuracy of this information. Reward rates on some protocols may vary based on the amount staked and/or other variables, including validator performance, so you should not rely on the accuracy of any reward rate ranges we publish, which are intended to provide an estimate. The actual rate of rewards earned may vary substantially and may change over time and Coinbase does not guarantee that you will receive any staking rewards. Staked assets may be subject to slashing penalties and risk of loss is possible, including up to the full loss of principal.

## What are the risks associated with delegating?
As with other Tendermint chains, Provenance Blockchain enacts slashing for excessive downtime and double signing, up to 5% of your staked tokens. Slashing punishments are applied proportionally to all tokens staked to the validator.

## How does Coinbase's service fee work? 
Coinbase charges a percentage service fee on all rewards earned by tokens delegated to our Provenance Blockchain validator. The service fee is paid to Coinbase automatically by the protocol. You can withdraw your rewards from the protocol directly.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonriver-delegation.mdx -->

---
title: "Moonriver Delegation Guide"
slug: "moonriver-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[Moonriver](https://moonbeam.network/networks/moonriver/), a Kusama parachain, and Moonbeam, its sister parachain on Polkadot, provide Ethereum-compatible environments for smart contract deployment in the Substrate ecosystem.

You can learn more about Moonriver in our [protocol overview](https://www.coinbase.com/cloud/discover/protocol-guides/guide-to-moonbeam-moonriver).

| Protocol Parameter      | Value                             |
|:------------------------|:----------------------------------|
| Minimum tokens to stake | 5 MOVR                            |
| Unbonding period        | 24 rounds (48 hours)              |
| Service fee             | 20% of rewards, fixed by protocol |

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address: `0x41DD82cfaC6F749Cb52d6496Dfe144cc9794778f`
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/osmosis-keplr-fund.mdx -->

---
title: "1: Set Up and Fund Keplr with OSMO"
slug: "osmosis-keplr-fund"
---

## 1. Create a Keplr wallet

1. Navigate to the [Keplr Wallet extension](https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap) in the Google Chrome store and follow the on-screen prompts to add the extension to your web browser.

<img src={require('../assets/images/osmosis-01-keplr-wallet-extn.png').default} width="50%" alt="OSMO" /><br clear="all" />

2. Open the browser extension and select _Create new account_.

<img src={require('../assets/images/osmosis-02-keplr-wallet-balance.png').default} width="50%" alt="OSMO" /><br clear="all" />

:::info
To use a Ledger hardware device to manage your Keplr wallet, first ensure you have the Cosmos app open and unlocked on your Ledger device. 
Select _Import Ledger_ in the Keplr UI and follow the on-screen prompts to connect your Ledger to Keplr.

Skip to Step Two: Fund Keplr Wallet below and skip the funding steps, navigating directly to the Osmosis Lab.
:::

3. Copy your mnemonic seed phrase and store it somewhere safe.

:::caution
Ensure that you store your mnemonic seed phrase somewhere safe where it cannot be lost or compromised. Your mnemonic seed phrase is the master key to your wallet; loss or compromise of your mnemonic seed phrase may result in permanent loss of your OSMO.
:::

4. Establish an account name and password, then select _Next_.

5. Confirm your mnemonic seed phrase and select _Register_.

## 2. Fund Keplr wallet and trade for OSMO

1. Open the Keplr wallet browser extension and select _Deposit_.

2. Copy the wallet address that appears.

3. Navigate to the exchange or wallet where your Comsos ATOMs are stored and send your ATOMs to the Keplr wallet address you just copied. Your assets should now appear in your Keplr wallet. 

:::info
If you prefer to use a supported asset other than ATOMs to procure OSMO, continue these steps but choose to deposit your preferred asset at Step 2.5 below.
:::

4. Navigate to the [Osmosis application](https://osmosis.zone/) and select _Enter The Lab_.

<img src={require('../assets/images/osmosis-03-application.png').default} width="50%" alt="OSMO" /><br clear="all" />

5. Select _Connect Wallet_ below the left menu and follow the on-screen prompts to connect your Keplr wallet to Osmosis.

6. Select _Assets_ in the left menu, and next to _Cosmos Hub - ATOM_ select _Deposit_.

7. Approve the connection to Osmosis in the Keplr wallet extension window that appears.

8. Your assets should appear shortly under _My Osmosis Assets_ on the Assets page.

9. Select _Trade_ in the left Osmosis menu.

10. On the Trade page, enter ATOM as the _From_ asset (or your preferred asset to use), and OSMO as the _To_ asset.

11. Enter the amount of assets you would like to use, select _Swap_, and approve the transaction in the Keplr wallet extension window that appears.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/bnb-delegation.mdx -->

---
title: "BNB Chain Delegation Guide"
slug: "bnb-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

This guide explains how to delegate (or stake) BNB with Binance Wallet on the Coinbase BNB Smart Chain validator within the BNB Chain ecosystem. 

To get started: 

- If you have BNB on the BNB Beacon Chain, you can [Stake with Binance Wallet](/delegation/docs/bnb-native-wallet-stake) to the Coinbase validator using the Binance Wallet Chrome Extension or a Ledger. 

- If you have BNB on the BNB Smart Chain, first [Bridge with Binance Wallet](/delegation/docs/bnb-native-wallet-bridge) to the BNB Beacon Chain and then stake. 

- If your BNB is already delegated to the BNB Smart Chain, but not on the Coinbase validator, you can [Redelegate with Binance Wallet to Coinbase](/delegation/docs/bnb-native-wallet-redelegate).

:::info
If you are a large token holder (> 10,000 BNB) and you would like to discuss more targeted delegation or infrastructure needs for your BNB, please [contact our team](https://www.coinbase.com/cloud/cloud-interest).
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/cardano-daedalus-fund.mdx -->

---
title: "1: Set Up and Fund Daedalus Wallet"
slug: "cardano-daedalus-fund"
---

<img src={require('../assets/images/cardano-daedalus-fund-01.png').default} width="60%" alt="" /><br clear="all" />

## To create a new Cardano wallet...

1. Open the Daedalus desktop application and allow it to sync to the Cardano blockchain.
2. Select _Create_ and follow the on‐screen prompts to create a new account, password, and mnemonic seed phrase.

:::danger Remember your seed phrase
Ensure that you store your seed phrase somewhere safe where it cannot be lost or compromised. Your seed phrase is the master key to your wallet; loss or compromise of your seed phrase may result in permanent loss of your ADA.
:::

<img src={require('../assets/images/cardano-daedalus-fund-02.png').default} width="60%" alt="" /><br clear="all" />

1. Select the _Receive_ tab.
2. Copy any of your wallet addresses.
3. Visit the exchange or wallet where your ADA was purchased/stored, and send your ADA from where it was purchased to the wallet address copied above.
   
   Following the network processing time, your ADA balance will show on the wallet homepage.


## To link an existing hardware wallet...

1. Open the Daedalus desktop application and allow it to sync to the Cardano blockchain.
2. Select _Pair_ and ensure your hardware device is connected and unlocked.
3. Follow the on-screen prompts to connect your device to Daedalus, including approving the connection on your hardware wallet.

   Your ADA balance will now show on the wallet homepage.


## To link to an existing Cardano wallet using a key phrase...

1. Open the Daedalus desktop application and allow it to sync to the Cardano blockchain.
2. Select _Restore_ to enter the 12, 15, 24, or 27 word mnemonic seed phrase for your existing Cardano wallet.
3. Choose your original wallet type and select _Continue_.
4. Follow the on-screen prompts to reconfigure your wallet.

   Your ADA balance will now show on the wallet homepage.


## To link to an existing Cardano wallet using a JSON recovery file...

1. Open the Daedalus desktop application and allow it to sync to the Cardano blockchain.
2. Select _Import_ then _Daedalus 'Secret.key' file_ and upload your JSON recovery file.
3. Enter your JSON recovery file password in the text box below and select _Import wallets_.

   Your ADA balance will now show on the wallet homepage.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/bnb-native-wallet-redelegate.mdx -->

---
title: "Redelegate with Binance Wallet to Coinbase"
slug: "bnb-native-wallet-redelegate"
---

If you are delegated to another validator, this page explains how to redelegate to the Coinbase validator.

:::info
If you are not yet delegated, see [Stake with Binance Wallet](/delegation/docs/bnb-native-wallet-stake) to get started!
:::

1. Go to the [BNB Chain staking dashboard](https://www.bnbchain.org/en/staking) and click _Connect Wallet_ in the top right corner.

2. Select _Binance Chain Wallet_ and click _Connect Wallet_. 

   Check that you’re on the BNB Beacon Chain network in the wallet extension. 

3. Click _My Staking_ in the top right corner of the staking dashboard. You should see a list of your delegations. 

4. Click _Redelegate_ on any one of your delegations and select the **Coinbase validator**. 

5. Input the amount of BNB you’d like to redelegate and click _Redelegate_. 

6. Confirm the transaction details are correct, and click _Confirm_. 

Congratulations! You are now delegated to the Coinbase validator. 

The change will take effect the following day (on average) and you will continue earning rewards without undergoing the 7 day unbonding period.

<img src={require('../assets/images/bnb-redelegate-binance-01.png').default} width="80%" alt="BNB." /><br clear="all" />

<br />

:::tip
Redelegations between a unique delegator, source validator, and destination validator can only happen once every 7 days, so it’s better to redelegate in one go.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/_snippet-remove-protocol.mdx -->

:::announcement Removing Provenance Protocol

On Friday, May 19, 2023, we are sunsetting our public validators for [Provenance](https://twitter.com/provenancefdn?lang=en).

If you are a delegator, we strongly recommend unbonding before this date. Refer to the [Provenance Delegation Guide](/delegation/docs/provenance-delegation) for protocol-specific unbonding periods. This change does not impact any other validator nodes for staking.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-native-wallet-about.mdx -->

---
title: "Staking HASH with Provenance Blockchain Wallet"
slug: "provenance-native-wallet-about"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[The Provenance Blockchain Wallet](https://wallet.provenance.io/) is a web-based wallet application that allows users to store their key pair offline locally. It is designed to be used in tandem with the [Provenance Blcokchain Explorer UI](https://explorer.provenance.io/dashboard) for interacting with the Provenance Blockchain. 

The Provenance Blockchain Wallet must also be used with an active password manager in order to properly store your key pair.
 
If you have not created and funded a Provenance Blockchain wallet, start at ["1: Set up and fund The Provenance Blockchain Wallet](/delegation/docs/provenance-staking-fund).
If you already have already created and funded your Provenance wallet, proceed to [2: Stake to Coinbase with The Provenance Blockchain Wallet](/delegation/docs/provenance-staking-stake).



<!-- File: /Users/tinahe/docs/projects/delegation/docs/solana-solflare-fund.mdx -->

---
title: "1: Set Up and Fund SolFlare Wallet"
slug: "solana-solflare-fund"
---

## 1. Connect Ledger Device to SolFlare

1. Plug in your Ledger, unlock it, and [navigate to the Solana app](https://support.ledger.com/hc/en-us/articles/360016265659-Solana-SOL-?docs=true) within the Ledger manager.

    <img src={require('../assets/images/solana-solflare-fund-01.png').default} width="80%" alt="SOL" /><br clear="all" />

2. Navigate to solflare.com and select _Create a Wallet_.

3. Select _Next_ several times and then _Get Started_ to navigate through the tutorial.

    <img src={require('../assets/images/solana-solflare-fund-02.png').default} width="80%" alt="SOL" /><br clear="all" />

4. Select _Using Ledger Nano S or X_ and click _Access_.

    <img src={require('../assets/images/solana-solflare-fund-03.png').default} width="80%" alt="SOL" /><br clear="all" />

5. Click the _Select derivation path_ dropdown and select the first option, _Solana - 44'/501'/_.

    <img src={require('../assets/images/solana-solflare-fund-04.png').default} width="80%" alt="SOL" /><br clear="all" />


6. Select your Ledger device from the pop-up screen. If the UI gives you any errors, ensure your Ledger is unlocked and has the Solana app open.

    <img src={require('../assets/images/solana-solflare-fund-05.png').default} width="80%" alt="SOL" /><br clear="all" />


## 2. Fund SolFlare Wallet

1. Select your _Root Account_ from the drop-down list of accounts and click _Access_.

2. Review the transaction prompt on your Ledger. It should show your pubkey (public address) on the screen. Confirm your address is correct. 

    <img src={require('../assets/images/solana-solflare-fund-06.png').default} width="80%" alt="SOL" /><br clear="all" />

3. Copy the address that shows under _Your Address_.
   
4. Visit the exchange or wallet where your SOL was purchased/stored, and send your SOL from where it was purchased to the wallet address copied above.

5. After waiting the network processing time, your SOL balance should show at the top of the SolFlare wallet extension when opened.




<!-- File: /Users/tinahe/docs/projects/delegation/docs/solana-phantom-fund.mdx -->

---
title: "1: Set Up and Fund Phantom Wallet"
slug: "solana-phantom-fund"
---

## 1. Install Phantom wallet extension 

1. Navigate to [https://phantom.app/download](https://phantom.app/download).

2. Follow the on-screen prompts to install the extension on your preferred browser.


## 2. Set up your wallet 

3. Open the Phantom wallet extension and select _Create new Wallet_.

4. Copy your secret recovery phrase and save it somewhere safe.

:::caution
Ensure that you store your recovery phrase somewhere safe where it cannot be lost or compromised. Your recovery phrase is the master key to your wallet; loss or compromise of your seed phrase may result in permanent loss of your SOL.
:::

5. Follow the on-screen prompts to create a secure password and view terms of service.


## 3. Deposit SOL

6. Open the Phantom browser extension and select _Receive_.

    <img src={require('../assets/images/solana-01-receive.png').default} width="50%" alt="SOL" /><br clear="all" />

7. Select _Send from wallet/exchange_, or your preferred method, and copy either the wallet address or QR code that appears.

8. Visit the exchange or wallet where your SOL was purchased/stored, and send your SOL from where it was purchased to the wallet address copied above.

9. After waiting the network processing time, your SOL balance should show at the top of the Phantom wallet extension when opened.




<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-native-wallet-stake.mdx -->

---
title: "2: Stake to Coinbase with The Provenance Blockchain Wallet"
slug: "provenance-staking-stake"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

## 1. Stake to our public validator

1. Navigate to the [Provenance Blockchain Explorer Dashboard](https://explorer.provenance.io/dashboard).

2. Connect to _Provenance Wallet_ by click the key icon on the upper right corner of the page.

3. In the pop-up window use your password manager to populate the username (and key) for your Provenance Blockchain wallet.

4. Enter the wallet password.

5. Select _Submit_.

6. Select _Validators_ on the dashboard menu.

7. Search for the Coinbase moniker or validator address and click _Delegate_

    <img src={require('../assets/images/provenance-05-coinbase-cloud-validator.png').default} width="100%" alt="HASH" />

8. Enter the amount you would like to stake with Coinbase in the _Amount to Delegate_ field.

9. Select _Delegate_.

10. In the Provenance Blockchain wallet pop-up window, confirm that the Coinbase validator address is correct (see below).

11. Select _Confirm and Broadcast_.

12. Your delegation will now show under the _My Validators_ section of the Provenance Blockchain Explorer Staking dashboard.

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address: `pbvaloper16w74eff40g3eux8kz92tmwzjjcngckw2672ycs`
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/cosmos-ledger-live-fund.mdx -->

---
title: "1: Set Up and Fund Ledger Live Wallet"
slug: "cosmos-ledger-live-fund"
---

## 1. Install Cosmos app and Create Account 

1. Ensure your Ledger hardware device is connected to your computer and active.

2. Within Ledger Live select _Manager_ and unlock your Ledger hardware device.

3. Search for the Cosmos App in the catalog and follow the on-screen prompts to install.

4. Select _Accounts_ within Ledger Live and click _Add account_.

5. Select Cosmos (ATOM) from the list of crypto assets, and follow the on-screen prompts to authorize the account with your Ledger hardware device.

6. Select _Add Account_.

## 2. Fund Ledger Live Wallet

1. Once the Cosmos App is installed, select _Receive_ within Ledger Live.

    <img src={require('../assets/images/cosmos-01-receive-ledger-live.png').default} width="80%" alt="Cosmos" /><br clear="all" />

2. Under _Account to credit_ select the Cosmos account you just created.

3. Copy the public hash code (address) of your Ledger Cosmos account that shows on the screen of Ledger Live.

4. Follow the on-screen prompts to authorize on your Ledger hardware device.

5. Ensure that the public hash for your account matches the hash displaying on the screen of your Ledger hardware device, and, if so, accept the transaction on your Ledger hardware device.

6. Select _Done_ on the confirmation screen.

7.  Visit the exchange or wallet where your ATOM was purchased/stored, and send your ATOM from where it was purchased to the public has/wallet address copied above.

8. Following the network processing time, your ATOM balance will show in your Ledger Live Cosmos account.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonriver-native-app-fund.mdx -->

---
title: "1: Set up and Fund Moonriver app with MOVR"
slug: "moonriver-native-app-fund"
---

## 1. Link wallet and and create account

1. Navigate to [https://apps.moonbeam.network/moonriver/staking](https://apps.moonbeam.network/moonriver/staking).

2. Select the wallet you would like to use to connect and follow the on-screen prompts to connect the wallet to the application.

3. Select _Approve_ to allow Moonriver to be added to your wallet as a new network, then choose _Switch network_ to activate Moonriver in your wallet.

    <img src={require('../assets/images/moonriver-01-approve-network.png').default} width="50%" alt="MOVR" /><br clear="all" />


4. If the wallet you connected was the same wallet used for a Moonriver Crowdloan, your MOVR balance will now show on the Moonriver dashboard. Proceed to [2: Stake MOVR to Coinbase with the Moonriver app](/delegation/docs/moonriver-native-app-stake).

## 2. Transfer MOVR 

1. Open the wallet you connected to the Moonriver app and copy the wallet address that appears with your Moonriver account.

2. Send your MOVR from the exchange or wallet where it is stored to the address you just copied.

3. Following a few minutes to allow for network processing time, refresh the Moonriver app and re-connect your wallet if prompted.

4. Your MOVR balance should now show on the dashboard of the Moonriver app. It may take up to 10 minutes to show the balance.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/dydx-bridging-smart-contract.mdx -->

---
title: "Bridging dYdX with a Smart Contract"
sidebar_label: "Bridging with a Smart Contract"
slug: "dydx-bridging-smart-contract"
---

Bridging dYdX directly with an Ethereum smart contract can be done via any RPC node, and is only recommended for advanced users. 

This tutorial uses [etherscan.io](https://etherscan.io/) to interact with the smart contract directly. You should know what you are doing throughout all steps of the process. 

:::danger advanced
This tutorial is for advanced users only.  
:::


## Step 1. Approve wethDYDX Contract

1. Navigate to the [ethDYDX token contract](https://etherscan.io/address/0x92d6c1e31e14520e676a687f0a93788b716beff5) and select **Contract** -> **Write Contract**.

    <img src={require('../assets/images/dydx-sc-contract.png').default} width="750" alt=""  />  

2. Connect your wallet with ETH in order to fund the amount of ethDYDX to bridge as well as to pay for transaction fees.

    <img src={require('../assets/images/dydx-sc-write-connect.png').default} width="750" alt=""  />

3. Select tab **2. Approve**: 

   a. Enter the wethDYDX contract as the spender (address).
  
   b. Enter the amount (uint256) as the maximum amount the contract can spend on your behalf. This is usually be the amount you wish to bridge, but if you return to bridge more, you must increase the allowance. 

   c. Click **Write** and approve the transaction.

    <img src={require('../assets/images/dydx-sc-approve-token.png').default} width="750" alt=""  />


## Step 2. Bridge to cosmosDYDX

1. Navigate to the [wrappedEthereumDYDX contract](https://etherscan.io/address/0x46b2deae6eff3011008ea27ea36b7c27255ddfa9) and select **Contract** -> **Write Contract**.

    <img src={require('../assets/images/dydx-sc-wrapped-connect.png').default} width="750" alt=""  />

2. Decode your Bech32 comosDYDX address (the address you wish the ethDYDX to be bridged to, e.g., `dydx27dh129fnklJ09n28f`) and prefix with `0x`. There are numerous Bech32 encoders/decoders online.

    :::danger Did you decode accurately?
    Ensure you correctly decoded the address before proceeding. Consider looking at completed bridge transactions for examples.
    :::

3. Select tab 2. Bridge: 

   a. Enter the amount of ethDYDX to bridge. 
   
   b. Enter your decoded cosmosDYDX address from step #2. Memo (bytes) can be left blank or 0x00 if required. 

    <img src={require('../assets/images/dydx-sc-bridge.png').default} width="750" alt=""  />

4. Select **Write** and approve the transaction. 

   :::tip Congratulations!! You have started the bridging process.
   Once your funds are transferred, see [Staking with Keplr Guide for dYdX](./dydx-staking-keplr.mdx).
   :::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/kusama-delegation.mdx -->

---
title: "Kusama Delegation Guide"
slug: "kusama-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[Kusama](https://kusama.network/) is a canary network for [Polkadot](https://polkadot.network/). It enables developers to build and deploy a parachain or experiment with Polkadot’s governance, staking, nomination and validation functionality in a real environment.

| Protocol Parameter      | Value          |
|:------------------------|:---------------|
| Minimum tokens to stake | 0.1 KSM        |
| Warmup period           | None           |
| Unbonding period        | 7 days         |
| Service fee             | 10% of rewards |

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator addresses:  <br />
Coinbase 1: `EFjHdypk8xLf3ocDEFPaKFWVcfamH8mpvfUeXHvRWpSBk2M` <br />
Coinbase 2: `DXrJrPLLBHuapmYJ6tfuUStKubhykWmpgLckJpgFgjp2JvV` <br />
Coinbase 3: `FsnmRZ5Xk2btFqGXVErvLaYUvxDkQDYr5x98s8QigqP5kEs` <br />
Coinbase 4: `E8HpgWvs61LgtENmJaXhUvCWt21jTz7kvXYwGLopsa2qscf` <br />

Enter each of the Coinbase validator addresses from the list above when staking. 

Selecting any or all validators from this list indicates your willingness to support those selected. The protocol automatically allocates your stake to a subset of the validators from your nominated list to participate and earn rewards each era. Selecting any or all validators increases your opportunities to earn rewards. See the [Kusama FAQ](/delegation/docs/kusama-faq) to learn more.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/crypto-desktop-fund.mdx -->

---
title: "1: Set Up and Fund Beta Desktop Wallet"
slug: "crypto-desktop-fund"
---

## 1. Set up the Desktop Wallet web app

1. Download the Crypto.org Chain Desktop Wallet library from [their GitHub repo](https://github.com/crypto-com/chain-desktop-wallet).

2. Ensure [Yarn](https://classic.yarnpkg.com/en/) is installed on your machine [using these directions](https://classic.yarnpkg.com/en/docs/install#mac-stable).

3. In your CLI terminal, go into the directory for the Desktop Wallet.

4. Enter the command _yarn install_ to install the app dependencies.

5. Enter the command _yarn start_ to launch the web app in your browser, which will deployed at "http://localh" on your machine.

    <img src={require('../assets/images/crypto-01-web-app.png').default} width="80%" alt="Crypto" /><br clear="all" />

6. Select _Get Started_.

7. Follow the on-screen prompts to create a password for the wallet application.


## 2. Create a Crypto.org Wallet

1. Select _Create wallet_.

<img src={require('../assets/images/crypto-02-create-wallet.png').default} width="80%"  alt="Crypto" /><br clear="all" />

2. Name your wallet and ensure Mainnet is selected as the network.

:::info
To set up your wallet using a Ledger hardware device, select _Want to create with hardware wallet?_ and follow the creation steps [per these directions](https://crypto.org/docs/wallets/ledger_desktop_wallet.html#install-the-crypto-com-app-and-create-the-wallet).
:::

3. Select _Create Wallet_.
4. Copy your Backup Recovery Phrase and store it somewhere safe.

:::caution
Ensure that you store your Backup Recovery Phrase somewhere safe where it cannot be lost or compromised. Your recovery phrase is the master key to your wallet; loss or compromise of your recovery phrase may result in permanent loss of your CRO.
:::

5. Confirm that you have written down your recovery phrase and re-enter your app password to continue.

6. Select _Go to Home_.


## 3. Migrate ERC20 to Native and transfer to the desktop wallet

1. Send your CRO ERC-20 Token to the Crypto.com DeFi Wallet mobile app.

:::info
You will need to transfer a minimum of 250 CRO in order to migrate your ERC-20 tokens to the native Crypto.org Chain token format, along with having some ETH available in your Crypto.com DeFi Wallet mobile application to pay gas fees for the migration.
:::

2. Select _Crypto.org Coin_ on the DeFi Wallet mobile application dashboard.

3. Select _CRO Migration Tool_.

4. Follow the on-screen instructions to migrate your ERC-20 CRO to the native token format.

5. In the Desktop Wallet web app, select _Receive_ from the left menu.

6. Copy the address that displays for your wallet.

7. On the Crypto.com DeFi Wallet mobile application dashboard select _Crypto.org Coin_.

8. Select _Send_ and enter the address copied from the Desktop Wallet web app as the Recipient Address.

9. Enter a memo for the transaction, or select _No Memo required for my recipient_.

10. Select _Next_.

11. After confirming your transaction details, select _Confirm_ to send.

12. Following the network processing time, your CRO balance will show under _TOTAL BALANCE_ in the Crypto.org Desktop Wallet web app, following the current network transaction wait time.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-wallet-choices.mdx -->

---
title: "Wallet choices for Provenance"
slug: "provenance-wallet-choices"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

Currently, staking is available in the [Provenance Blockchain Explorer UI](https://explorer.provenance.io/dashboard) using either [The Provenance Blockchain Wallet](https://wallet.provenance.io/) or Figure's hosted wallet solution, a custodial option that supports all Provenance Blockchain transactions and trading functions.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonbeam-native-app-fund.mdx -->

---
title: "1: Set up and Fund Moonbeam app with GLMR"
slug: "moonbeam-native-app-fund"
---

## 1. Link wallet and and create account

1. Navigate to [https://apps.moonbeam.network/moonbeam](https://apps.moonbeam.network/moonbeam).

2. Select the wallet you would like to use to connect and follow the on-screen prompts to connect the wallet to the application.

3. Select _Approve_ to allow Moonbeam to be added to your wallet as a new network, then choose _Switch network_ to activate Moonbeam in your wallet.

    <img src={require('../assets/images/moonbean-01-approve-network.png').default} width="50%" alt="Add Moonbeam." /><br clear="all" />

4. If the wallet you connected was the same wallet used for a Moonbeam Crowdloan, your GLMR balance will now show on the Moonbeam dashboard. Proceed to [2: Stake GLMR to with the Moonbeam app](/delegation/docs/moonbeam-native-app-stake).

## 2. Transfer GLMR 

1. Open the wallet you connected to the Moonbeam app and copy the wallet address that appears with your Moonbeam account.

2. Send your GLMR from the exchange or wallet where it is stored to the address you just copied.

3. Following a few minutes to allow for network processing time, refresh the Moonbeam app and re-connect your wallet if prompted.

4. Your GLMR balance should now show on the dashboard of the Moonbeam app. It may take up to 10 minutes to show the balance.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-delegation.mdx -->

---
title: "Provenance Delegation Guide"
slug: "provenance-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[Provenance Blockchain](https://provenance.io/) is a public, permissionless proof of stake network built to support the traditional financial industry.

| Protocol Parameter | Value          |
|:-------------------|:---------------|
| Minimum delegation | No minimum     |
| Warmup period      | None           |
| Unbonding period   | 21 days        |
| Service fee        | 10% of rewards |

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address: `pbvaloper16w74eff40g3eux8kz92tmwzjjcngckw2672ycs`
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/sui-stake-suiet.mdx -->

---
title: "Staking with Suiet Wallet"
slug: "sui-stake-suiet"
---


## Step 1. Setup and Fund Suiet Wallet

1. Download [Suiet Wallet browser extension](https://chrome.google.com/webstore/detail/suiet-sui-wallet/khpkpbbcccdmmclmpigdgddabeilkdpd) and navigate to the extension.

2. Create a new wallet.

3. Create a password and write down your recovery phrase.

4. Fund your newly created address with desired SUI.

## Step 2. Delegate to Coinbase Validator

1. Navigate to the [Coinbase validator](https://suiexplorer.com/validator/0x0350925241ae8d4083fe4b1104e14dd28d2ffeced9d7575551c50c41b99995fb) on the [SUI explorer](https://suiexplorer.com/) and click **Stake SUI**.

    <figcaption><i>APY in product may vary. Click image to enlarge. </i></figcaption> <img src={require('../assets/images/sui-explorer.png').default} width="60%" alt="SUI" /><br clear="all" />

2. Connect by clicking on the Suiet icon and approving the connection.

     <img src={require('../assets/images/sui-suiet-wallet.png').default} width="60%" alt="SUI" /><br clear="all" />

3. Enter in desired amount, and press **Stake Now**.

4. Confirm the transaction. Once completed your funds should be delegated.

:::tip Congratulations! You are now staked to a Coinbase validator.
To learn more about Coinbase’s services, visit our [site](https://www.coinbase.com/cloud).
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/bnb-native-wallet-stake.mdx -->

---
title: "Stake with Binance Wallet"
slug: "bnb-native-wallet-stake"
---

To stake BNB on the BNB Beacon Chain, you must install the [Binance Wallet Chrome Extension](https://chrome.google.com/webstore/detail/binance-wallet/fhbohimaelbohpjbbldcngcnapndodjp) and have at least 1 BNB in your address on the BNB Beacon Chain Network. 

You are on the right network if the address that holds your BNB starts with `bnb`. If your address starts with `0x`, see [Bridge with Binance Wallet](./bnb-native-wallet-bridge) .

:::caution
Ledger users must connect their Binance Wallet extension to their Ledger and use it to sign the transactions. The delegation steps are otherwise identical.
:::

1. Go to the [BNB Chain staking dashboard](https://www.bnbchain.org/en/staking) and click _Connect Wallet_ in the top right corner.

   <img src={require('../assets/images/bnb-stake-binance-01-connect-wallet.png').default} width="80%" alt="BNB." /><br clear="all" />


2. Select _Binance Chain Wallet_ and click _Connect Wallet_.

   <img src={require('../assets/images/bnb-bridge-binance-02-address.png').default} width="50%" alt="BNB." /><br clear="all" />

3. Click _Connect_ to authorize the staking dashboard to connect to your wallet.

   <img src={require('../assets/images/bnb-stake-binance-03-connect-request.png').default} width="50%" alt="BNB." /><br clear="all" />

4. Find the **Coinbase validator** in the list and click _Delegate_.

   <figcaption><i>Click to enlarge image</i></figcaption><img src={require('../assets/images/bnb-stake-binance-04-coinbase-cloud.png').default} width="80%" alt="BNB." /><br clear="all" />

5. Enter the amount you want to delegate (plus at least 0.05BNB for transaction fees) and click _Delegate_.

   <img src={require('../assets/images/bnb-stake-binance-05-delegate.png').default} width="80%" alt="BNB." /><br clear="all" />

6. Check the transaction to ensure you input the right values and then click _Confirm_.

   <img src={require('../assets/images/bnb-stake-binance-06-confirm.png').default} width="80%" alt="BNB." /><br clear="all" />

7. Click _My Staking_ in the top right corner of the staking dashboard to see your staking activity and rewards.

   Congratulations! You are now delegated to the Coinbase BNB Smart Chain validator.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/provenance-native-wallet-fund.mdx -->

---
title: "1: Set up and Fund The Provenance Blockchain Wallet"
slug: "provenance-staking-fund"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

## 1. Set up your Provenance Blockchain wallet

1. Ensure you are using an updated web browser with a password manager enabled

:::caution
The Provenance Blockchain requires that you store your encrypted private key in a __browser__ password manager, so you must have this enabled when [creating a Provenance wallet](https://provenance.io/set-up-provenance-wallet).
:::

2. Navigate to https://wallet.provenance.io/ and select _Connect_.

3. At the bottom of the pop-up window, select _Create new wallet_.

4. Select _Generate seed phrase_ and click _Continue_.

5. A new window will show your 24 word seed phrase. Write down your seed phrase and save it somewhere safe. You will need to verify a portion of your seed phrase to finalize the creation of your wallet.

:::caution
Ensure that you store your mnemonic seed phrase somewhere safe where it cannot be lost or compromised. Your mnemonic seed phrase is the master key to your wallet; loss or compromise of your mnemonic seed phrase may result in permanent loss of your HASH.
:::

6. Once you have copied your seed phrase, select _Continue_ at the bottom of the window.

7. Follow the on-screen prompts to verify a portion of your seed phrase in order to continue.

8. In the _Wallet name_ field enter the name you want to use to identify your encrypted private key within your password manager.

9. Create a secure password, which will be used to encrypt your private key before it is stored within your password manager.

10. Select _Continue_.

11. On the _SAVE TO KEYCHAIN_ page that appears, select the _Copy_ icon to the right above to your encrypted private key.

12. Paste your encrypted private key in the _Password_ field.

13. Select _Continue_.

:::caution
You should be prompted by the browser to save your credentials. Accept the prompt and select _Save_. If a prompt does not appear, click the Key icon on the top right of your browser window and follow the password manager's prompts to save the field as a password.
:::

<img src={require('../assets/images/provenance-01-wallet-save.png').default} width="50%" alt="HASH" />

:::info
Future staking actions require using the information saved in the password manager to access your wallet via a Provenance login window. 

If you encounter errors related to your password manager not functioning as expected, you can go back to the beginning of these steps and select _Create new wallet_ on the login page, followed by _Create from existing seed phrase_, which will allow you to use your 24 word seed phrase to access your wallet again and set a new password.
:::


## 2. Fund your Provenance wallet

1. Navigate to [Figure's website](https://www.figure.com/login/register) to create an account.

2. Enter the personal or business information to be associated with your account and select _Sign up_.

3. Select _Create Wallet_.

4. Select _Continue_ if a pop-up message appears.

5. A window will appear to configure your default Figure Wallet.

6. Change the wallet name if you would like to do so and select _Submit_.

7. Review Figure's terms of service as prompted.

    <img src={require('../assets/images/provenance-02-figure-passport.png').default} width="80%" alt="HASH" />

8. On the _Create Figure Passport_ page, select _Set up Figure Passport_ and follow the on-screen prompts to configure ACH funding.

9. Once funding is approved, navigate back to the Figure Wallet dashboard.

    <img src={require('../assets/images/provenance-03-figure-wallet-dashboard.png').default} width="50%" alt="HASH" />

10. On the right of the Figure wallet dashboard, click _Menu_ and then select _Link Provenance Wallet_ from the drop-down.

11. A pop-up window will open, prompting you to use your password manager to enter the key credentials for your Provenance wallet generated in Step 1 above.

12. After entering, select _Submit_.

13. Your Provenance Wallet should now show as the primary wallet on your Figure Wallet dashboard.

    <img src={require('../assets/images/provenance-04-figure-wallet-trade.png').default} width="80%" alt="HASH" />

14. Select _Trade_ in the HASH row of the dashboard.

15. Follow the on-screen prompts to use your funds to purchase HASH.

16. Return to the Provenance Wallet dashboard.

17. The HASH you secured in the previous steps should now show in the _Holdings_ section of the Provenance dashboard.


<!-- File: /Users/tinahe/docs/projects/delegation/docs/zetachain-staking-keplr.mdx -->

---
title: "Staking ZETA with Keplr Wallet"
sidebar_label: "Staking with Keplr Wallet"
slug: "zetachain-staking-keplr"
---

<!--- Redirect from zetachzin-keplr-stake to zetachahin-staking-keplr --->

<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="stake, coinbase, zetachain" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="Staking ZETACHAIN with Keplr Wallet" />
    <meta property="og:image" content="https://www.zetachain.com/img/logos/og-banner.png" />
</head>

:::caution Please Note:
On Coinbase, ZETACHAIN refers to the version of the asset that is deployed on ZetaChain mainnet, while ZETA refers to the version of the asset that is deployed on Ethereum mainnet. On Keplr, ZETA refers to the asset that is deployed on ZetaChain mainnet
:::

## Step 1. Create Wallet and Fund

1. Download the [Keplr Wallet](https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap) extension and navigate to the extension on your browser.

2. Click **Create new wallet** or **Import an existing wallet**.

3. Securely store your recovery phrase and create a password.

4. Fund the newly created address with ZETACHAIN (Cosmos).


## Step 2. Delegate to Coinbase Validator

1. Navigate to the [Keplr Dashboard](https://wallet.keplr.app/) by clicking **Manage Portfolio in Keplr Dashboard** from the Keplr extension.

    <img src={require('../assets/images/zetachain-keplr-extension.png').default} width="300" alt=""  />

2. Click on the **Staking** tab on the left.

    <img src={require('../assets/images/zetachain-keplr-stake.png').default} width="700" alt=""  />

3. Type in *ZetaChain* and select the **ZetaChain** option.

    <img src={require('../assets/images/zetachain-keplr-stake-zetachain.png').default} width="700" alt=""  />

4. Search for the *Coinbase* validator and select it.

    <img src={require('../assets/images/zetachain-keplr-search-validator.png').default} width="700" alt=""  />

    :::tip
    You can search by entering in the Validator Address `zetavaloper1plemdt5yuvqz70kqnyyha2tfs94jc40cqls89x` or by searching `Coinbase`.
    :::

5. Enter in your desired amount of ZETA to stake, and click **Stake**.

    <img src={require('../assets/images/zetachain-keplr-stake-to-coinbase-cloud.png').default} width="300" alt=""  />

6. Validate information and approve the transaction. Once completed your funds will be delegated.

    <img src={require('../assets/images/zetachain-keplr-stake-approve.png').default} width="300" alt=""  />

    :::caution
    The APY may vary from the screenshots in this tutorial.
    :::

    :::tip
    Congratulations! You are now staked to a Coinbase validator.
    :::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/moonbeam-delegation.mdx -->

---
title: "Moonbeam Delegation Guide"
slug: "moonbeam-delegation"
---

import RemovalCallout from './_snippet-remove-protocol.mdx';

<RemovalCallout />

[Moonbeam](https://moonbeam.network/), a Polkadot parachain, and Moonriver, its sister parachain on Kusama, provide Ethereum-compatible environments for smart contract deployment in the Substrate ecosystem.

You can learn more about Moonbeam in our [protocol overview](https://www.coinbase.com/cloud/discover/protocol-guides/guide-to-moonbeam-moonriver).

| Protocol Parameter      | Value                             |
|:------------------------|:----------------------------------|
| Minimum tokens to stake | 50 GLMR                           |
| Unbonding period        | 28 rounds (168 hours)             |
| Service fee             | 20% of rewards, fixed by protocol |


:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address: `0x293d1253b07c8bEB88A3a0758f8E9CCE299841B8`
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/cardano-adalite-stake.mdx -->

---
title: "2: Stake to Coinbase with AdaLite"
slug: "cardano-adalite-stake"
---

##### 1. Stake to our public validator

1. On the wallet homepage select the _Staking_ tab.

    <img src={require('../assets/images/cardano-adalite-stake-01.png').default} width="60%" alt="ADA" /><br clear="all" />

   The _Delegate Stake_ module on the right side of the page will show a randomly selected validator

2. Clear the populated _Stake Pool ID_ field and enter the Coinbase Stake Pool ID: `66c1296e3bee372fc37282535eb45710d9c8b96b05248d7ea636352f`.

:::info COINBASE VALIDATOR INFORMATION
Stake pool name: Coinbase <br />
Stake pool ticker: CLOUD<br />
Stake pool ID: `6804118fe78be9bf9213b9e829803952be87814d28b305fa52bf11d9`
:::

3. Use your keyboard return/enter key to populate the staking information for the Coinbase Stake Pool.

    <img src={require('../assets/images/cardano-adalite-stake-02.png').default} width="60%" alt="ADA" /><br clear="all" />

4. Select _Delegate_ and enter the amount of ADA you would like to delegate.

5. Ensure your delegation information looks correct and select _Confirm Transaction_. If using AdaLite connected to a hardware device, your device will need to be connected and unlocked.

6. Follow the on-screen prompts, or the prompts on your connected hardware device if using, to confirm your stake key address registration and confirm your delegation.

    <img src={require('../assets/images/cardano-adalite-stake-03.png').default} width="60%" alt="ADA" /><br clear="all" />

:::tip Congratulations! You are now staked to a Coinbase validator.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/solana-solflare-stake.mdx -->

---
title: "2: Stake to Coinbase with SolFlare"
slug: "solana-solflare-stake"
---

## 1. Stake to our public validator

1. Open the SolFlare UI, and under _Create a staking account_ select _Get Started_.

    <img src={require('../assets/images/solana-solflare-stake-01.png').default} width="80%" alt="SOL" /><br clear="all" />

2. Enter the amount of SOL you would like to delegate. Please leave at least 1 SOL in your account to pay for future transaction fees. Click _Next_. If you receive an error message, ensure your Ledger is unlocked and has the Solana app open. 

3. Confirm the creation of a new stake account for the correct amount of SOL.

    <img src={require('../assets/images/solana-solflare-stake-02.png').default} width="80%" alt="SOL" /><br clear="all" />

4. On the main SolFlare page, select _Delegate Now_.

    <img src={require('../assets/images/solana-solflare-stake-03.png').default} width="80%" alt="SOL" /><br clear="all" />

5. Select the Coinbase validator from the dropdown menu and click *Next*

6. Review the delegation transaction prompt on your Ledger. Confirm that the *Vote Account* matches the Coinbase/Coinbase vote account address (see below).

7. Approve the transaction. 

    <img src={require('../assets/images/solana-solflare-stake-04.png').default} width="80%" alt="SOL" /><br clear="all" />


:::info COINBASE VALIDATOR INFORMATION
Validator name: [Coinbase](https://stakewiz.com/validator/beefKGBWeSpHzYBHZXwp5So7wdQGX6mu4ZHCsH3uTar) <br />
Validator ID: `XkCriyrNwS3G4rzAXtG5B1nnvb5Ka1JtCku93VqeKAr` <br />
Validator vote account address: `beefKGBWeSpHzYBHZXwp5So7wdQGX6mu4ZHCsH3uTar`

Validator name: [Coinbase 02](https://stakewiz.com/validator/6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9)<br />
Validator ID: `CW9C7HBwAMgqNdXkNgFg9Ujr3edR2Ab9ymEuQnVacd1A` <br />
Validator vote account address: `6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9`
:::

:::tip Congratulations! You are now staked to the Coinbase validator.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/avalanche-native-wallet-fund.mdx -->

---
title: "1. Setup and Fund Avalanche Wallet"
slug: "avalanche-native-wallet-fund"
---

## 1. Create an Avalanche wallet

1. Navigate to [Avalanche Wallet](https://wallet.avax.network/).

2. Select __Create New Wallet__. 

3. Select __Generate Key Phrase__. 

4. Copy your Key Phrase (mnemonic seed phrase) and store it somewhere safe.

   :::caution
   Ensure that you store your Key Phrase somewhere safe where it cannot be lost or compromised. Your Key Phrase is the master key to your wallet; loss or compromise of your Key Phrase may result in permanent loss of your AVAX.
   :::

5. Confirm you have secured your Key Phrase and select __Access Wallet__.

6. Verify your Key Phrase (Mnemonic phrase) by filling in the blanks with the correct words, and select __Verify__.

7. Select __Access Wallet__.


## 2. Locate Platform Wallet Address

1. Navigate to the [Avalanche Wallet](https://wallet.avax.network/) dashboard.

    <img src={require('../assets/images/avalanche-dashboard.png').default} width="80%" alt="Avalanche wallet dashboard." /><br clear="all" />

2. Verify which platform wallet address to use by navigating to the exchange or wallet where your AVAX is stored, then view your Avalanche wallet address, by selecting a “Receive Avalanche” option.

3. Determine the Avalanche chain for this wallet based on the address’ prefix: 

    - X-Chain wallet addresses begin with “X-avax…” 
    - C-Chain wallet addresses begin with “0x…”. 
    - P-Chain wallet addresses begin with “P-avax…”. 

:::caution
You can toggle between 3 options for your wallet address in the upper right corner of the Avalanche Wallet: X, P, or C, which indicate your unique wallet addresses for the Avalanche X-Chain, C-Chain, and P-Chain.
  
- X-Chain is the Exchange Chain. Its sole purpose is for sending and receiving funds. 
- C-Chain is the Contract Chain. This is the chain used for smart contracts and defi, and it has an Ethereum-style address. If your AVAX is stored with Coinbase, your balance is on the C-Chain. 
- P-Chain is the Platform Chain. This is the chain for staking AVAX or running a validator. The P-Chain _can_ receive transfers from the X and C chains using the Cross Chain transaction in the Avalanche Wallet. 

Proceed with caution during these steps to ensure you are depositing AVAX to the correct wallet. You can lose your AVAX funds if you send them to the wrong chain’s wallet.
:::

4. Return to the [Avalanche Wallet](https://wallet.avax.network/) dashboard.

5. Under __Derived Wallet Address__, toggle the wallet options so that the same chain is selected (X, C, or P) as your wallet address on the exchange or wallet where your AVAX is stored (the address that appears on the Avalanche Wallet dashboard should have the same prefix as your wallet address on the exchange).

6. Copy the Derived Platform Wallet Address. 


## 3. Fund Avalanche Wallet

1. Navigate to the exchange or wallet where your AVAX is stored and send your AVAX to the appropriate Avalanche Wallet chain address you just copied.

2. Your AVAX balance should now appear on your Avalanche Wallet dashboard.

:::info
If you receive an error message from the exchange or wallet where your AVAX is stored stating that this is not a valid AVAX address, go back to the Avalanche dashboard and instead copy the address of the Avalanche chain that matches the chain on which your AVAX is currently stored. 

For example, if your AVAX is stored with Coinbase on the Avalanche C-Chain, and you receive an error message when trying to send your AVAX out to Avalanche Wallet, go back to Avalanche Wallet and ensure you have copied the C-Chain address to send your AVAX from Coinbase to.
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/polygon-delegation-flow.mdx -->

---
title: "Delegation Flow"
slug: "polygon-delegation-flow"
---

1. Go to [Polygon Wallet](https://wallet-dev.polygon.technology/staking/).

2. Connect Polygon Wallet to your self-custody wallet:

   a. Click __Connect to a Wallet__ (top right).

   b. Select your self-custody wallet from the list (Coinbase Wallet, MetaMask, etc) and click __Connect__.
   
   c. When prompted, sign again and confirm the connection.

    <img src={require('../assets/images/polygon-01-select-wallet.png').default} width="80%" alt="" /><br clear="all" />

3. Select [Polygon Staking](https://wallet.polygon.technology/).	

    <img src={require('../assets/images/polygon-02-select-staking.png').default} width="80%" alt="" /><br clear="all" />

4. Click __All Validators__ (top left) to see a list of validators you can delegate to. Search for the “Coinbase” validator. 

    <img src={require('../assets/images/polygon-03-all-validators.png').default} width="80%" alt="" /><br clear="all" />

5. Select the Coinbase validator, and click __Delegate__.

6. Enter the amount of MATIC you wish to delegate and click __Continue__. This step approves the delegation.

    <img src={require('../assets/images/polygon-04-enter-matic-amount.png').default} width="80%" alt="" /><br clear="all" />

7. Sign a second transaction to actually delegate your MATIC to Coinbase validator or your chosen validator.

    <img src={require('../assets/images/polygon-05-sign-second-transaction.png').default} width="80%" alt="" /><br clear="all" />






<!-- File: /Users/tinahe/docs/projects/delegation/docs/celestia-staking-leap.mdx -->

---
title: "Staking TIA with Leap Wallet"
sidebar_label: "Staking with Leap Wallet"
slug: "celestia-staking-leap"
---

<!--- Redirect from celestia-leap-stake to celestia-staking-leap --->

<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="stake, coinbase, celestia" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="Staking TIA with Leap Wallet" />
    <meta property="og:image" content="https://images.ctfassets.net/q5ulk4bp65r7/3FknETyHaomq0n0PrTGbd4/19c7b9f1b9b960f3b1b565051d2a3e4f/Celestia.png" />
</head>


## Step 1. Create and Fund

1. Download the [Leap Wallet](https://chrome.google.com/webstore/detail/leap-cosmos-wallet/fcfcfllfndlomdhbehjjcoimbgofdncg) extension and navigate to the extension on your browser.

    <img src={require('../assets/images/celestia-leap-extension.png').default} width="600" alt=""  />

2. Click **Create new wallet** or **Import an existing wallet**.

3. Securely store your recovery phrase and create a password.

4. Fund the newly created address with TIA.


## Step 2. Connect to Celestia network

1. Connect to Celestia by clicking on the chain dropdown in the top right corner.

    <img src={require('../assets/images/celestia-leap-connect.png').default} width="300" alt=""  />

2. Search for and click on Celestia.

    <img src={require('../assets/images/celestia-leap-select-chain.png').default} width="300" alt=""  />


## Step 3. Delegate to Coinbase Validator

1. Click on **Stake** tab on the bottom of the extension.

    <img src={require('../assets/images/celestia-leap-stake-tab.png').default} width="300" alt=""  />

2. Then click the **Stake** button.

    <img src={require('../assets/images/celestia-leap-stake.png').default} width="300" alt=""  />

3. Search for the Coinbase validator and click on it.

    <img src={require('../assets/images/celestia-leap-choose-validator.png').default} width="300" alt=""  />

    :::tip
    You can search by entering in the Validator Address `celestiavaloper1geuw5f6u3n5l4ne2d2nze3fehxf023f7s8h08t` or by searching `Coinbase`.
    :::

4. Enter in your desired amount of TIA to stake, click **Review**.

    <img src={require('../assets/images/celestia-leap-stake-tia.png').default} width="300" alt=""  />

5. If all looks correct, complete and confirm the transaction. Once completed your funds will be delegated.

   :::note
   Please note that the APY may vary from the provided screenshots.
   :::

   :::tip Congratulations! You are now staked to a Coinbase validator.
   :::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/celestia-staking-keplr.mdx -->

---
title: "Staking TIA with Keplr Wallet"
sidebar_label: "Staking with Keplr Wallet"
slug: "celestia-staking-keplr"
---

<!--- Redirect from celestia-keplr-stake to celestia-staking-keplr --->

<!--- DO NOT REMOVE --->
<head>
    <meta name="keywords" content="stake, coinbase, celestia" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="Staking TIA with Keplr Wallet" />
    <meta property="og:image" content="https://images.ctfassets.net/q5ulk4bp65r7/3FknETyHaomq0n0PrTGbd4/19c7b9f1b9b960f3b1b565051d2a3e4f/Celestia.png" />
</head>


## Step 1. Create Wallet and Fund

1. Download the [Keplr Wallet](https://chrome.google.com/webstore/detail/keplr/dmkamcknogkgcdfhhbddcghachkejeap) extension and navigate to the extension on your browser.

2. Click **Create new wallet** or **Import an existing wallet**.

3. Securely store your recovery phrase and create a password.

4. Fund the newly created address with TIA.


## Step 2. Delegate to Coinbase Validator

1. Navigate to the [Keplr Dashboard](https://wallet.keplr.app/) by clicking **Manage Portfolio in Keplr Dashboard** from the Keplr extension.

    <img src={require('../assets/images/celestia-keplr-extension.png').default} width="300" alt=""  />

2. Click on the **Staking** tab. If you have TIA, you will see the *Celestia Staking* option. Click on the **Stake** button.

    <img src={require('../assets/images/celestia-keplr-stake.png').default} width="700" alt=""  />

3. On the Celestia page, click the **Stake** button.

    <img src={require('../assets/images/celestia-keplr-stake-celestia.png').default} width="700" alt=""  />

3. Search for the Coinbase validator and select it.

    <img src={require('../assets/images/celestia-keplr-search-validator.png').default} width="700" alt=""  />

    :::tip
    You can search by entering in the Validator Address `celestiavaloper1geuw5f6u3n5l4ne2d2nze3fehxf023f7s8h08t` or by searching `Coinbase`.
    :::

4. Enter in your desired amount of TIA to stake, and click **Stake**.

    <img src={require('../assets/images/celestia-keplr-stake-to-coinbase-cloud.png').default} width="300" alt=""  />

5. If all looks correct, complete and confirm the transaction. Once completed your funds will be delegated.

    <img src={require('../assets/images/celestia-keplr-stake-approve.png').default} width="300" alt=""  />

    :::caution
    The APY may vary from the screenshots in this tutorial.
    :::

    :::tip Congratulations! You are now staked to a Coinbase validator.
    :::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/oasis-web-fund.mdx -->

---
title: "1: Set Up and Fund Oasis Web Wallet"
slug: "oasis-web-fund"
---

## To set up Oasis web wallet with a Ledger hardware device...

### 1. Link Oasis web wallet to Ledger live

1. Currently, you will have to ensure that your Ledger is set up to accept testnet-level apps by enabling Developer Mode in Ledger Live's Manager.
2. Within [Ledger Live](https://www.ledger.com/ledger-live), navigate to __Settings > Experimental features__ and toggle the Developer Mode setting to `On`.

<img src={require('../assets/images/oasis-01-settings.png').default} width="50%" alt="" /><br clear="all" />

3. Install the Oasis App within your Ledger Device by adding the app in Ledger Live’s Manager
4. Navigate to https://oasis-wallet.rockx.com/ and select _Log In_ in the upper right corner.
5. Follow the on-screen prompts to allow the Oasis Web Wallet to connect to your Ledger Wallet; you will need to unlock your Ledger device and open the Oasis app on it.
6. If your ROSE is already stored on your hardware device, you balance will now show in the Oasis web wallet.
7. If your ROSE is stored in an exchange or elsewhere, copy the wallet address that appears in the web UI under _Receive_ and send the ROSE from your exchange to that address.


## To set up Oasis web wallet on its own... 

### 1. Create Oasis web wallet address

1. Navigate to https://oasisprotocol.org/wallets and select _Create Your Oasis Wallet_.
2. Select _Create wallet_ and copy your mnemonic seed phrase.

:::caution
Ensure that you store your mnemonic seed phrase somewhere safe where it cannot be lost or compromised. Your mnemonic seed phrase is the master key to your wallet; loss or compromise of your mnemonic seed phrase may result in permanent loss of your ROSE.
:::

3. Select _Open my wallet_.
4. Copy the wallet address that appears in the web UI under _Receive_ and send the ROSE from the exchange or wallet where it is stored to that address.



<!-- File: /Users/tinahe/docs/projects/delegation/docs/sui-stake-ethos-wallet.mdx -->

---
title: "Staking with Ethos Sui Wallet"
slug: "sui-stake-ethos"
---

## Step 1. Setup and Fund Ethos Sui Wallet

1. Download [Ethos Sui Wallet browser extension](https://chrome.google.com/webstore/detail/ethos-sui-wallet/mcbigmjiafegjnnogedioegffbooigli) and navigate to the extension.

2. Create a new wallet.

3. Create a password and write down and confirm your recovery phrase.

4. Fund your newly created address with desired SUI.


## Step 2. Delegate to Coinbase Validator

1. In your Ethos Sui Wallet, click on **Staking** and then **Get Started**.

    <img src={require('../assets/images/sui-ethos-wallet.png').default} width="40%" alt="SUI" /><br clear="all" />

    <img src={require('../assets/images/sui-ethos-wallet-get-started.png').default} width="40%" alt="SUI" /><br clear="all" />

2. Select the [Coinbase validator](https://suiexplorer.com/validator/0x0350925241ae8d4083fe4b1104e14dd28d2ffeced9d7575551c50c41b99995fb) and click **Next**. 

    <figcaption><i>APY in product may vary.</i></figcaption> <img src={require('../assets/images/sui-ethos-wallet-cc-validator.png').default} width="40%" alt="SUI" /><br clear="all" />

3. Enter in desired amount, and press **Review**.

:::tip Congratulations! You are now staked to a Coinbase validator.
:::



<!-- File: /Users/tinahe/docs/projects/delegation/docs/aptos-petra-stake.mdx -->

---
title: "Staking APT with Petra Wallet"
sidebar_label: "Staking with Petra Wallet"
slug: "aptos-petra-stake"
hide_table_of_contents: false
---

## Step 1. Create and Fund

This section explains how to setup and fund a Petra Aptos Wallet. Click images to enlarge.

1. Download the [Petra Aptos Wallet Chrome extension](https://petra.app/).

    {/* <!-- <img src={require('../assets/images/aptos-petra-1-01-download.png').default} width="350" alt=""  />   --> */}

2. Click **Create New Wallet**.

    <img src={require('../assets/images/aptos-petra-1-02-create-new-wallet.png').default} width="500" alt=""  />  

3. Create a password and securely store your recovery phrase.

    {/* <!-- <img src={require('../assets/images/aptos-petra-1-03-secure-credentials.png').default} width="350" alt=""  />   --> */}

4. Pin the Petra Aptos Wallet extension to your taskbar.

    {/* <!-- <img src={require('../assets/images/aptos-petra-1-04-pin-wallet.png').default} width="350" alt=""  />   --> */}

5. Open Petra (by clicking the <img src={require('../assets/images/aptos-petra-wallet-icon.png').default} width="16" alt="P icon"  /> icon) and fund the newly created wallet/address with APT. 

   You can buy from within the wallet, or copy the address and send from an exchange like [Coinbase.com](https://www.coinbase.com/price/aptos).

    <img src={require('../assets/images/aptos-petra-1-05-fund-wallet-receive.png').default} width="350" alt=""  />  

:::info
See [Connecting Ledger Live to Your Petra Wallet](./aptos-petra-connect-ledger.mdx).
:::


## Step 2. Connect and Stake

This section explains how to stake to a Coinbase validator. It assumes that you have created and funded a Petra Aptos Wallet.

1. Go to the [Coinbase Validator](https://explorer.aptoslabs.com/validator/0x9c721c79ee082aafcdd99b1a71a833accdc48dba1a9a1bc5b5f8cc47ff7d49c0?network=mainnet), directly or search for it on the [Aptos Explorer](https://explorer.aptoslabs.com/?network=mainnet).

2. Click **Connect Wallet**, select **Petra**, and **Approve** the connection request.

    <img src={require('../assets/images/aptos-petra-2-02-connect.png').default} width="700" alt=""  />  

3. Search for and select the **Coinbase** node.

4. Click **Stake** to stake APT on this validator.


:::tip Congratulations! You are now staked to a Coinbase validator.
Visit [Coinbase](https://www.coinbase.com/cloud) to learn more about our services.
:::


<!-- File: /Users/tinahe/docs/projects/delegation/docs/crypto-desktop-stake.mdx -->

---
title: "2: Stake to with Beta Desktop Wallet"
slug: "crypto-desktop-stake"
---

## 1. Stake to our public validator

1. Select _Staking_ from the left menu of the Crypto.org Desktop Wallet web app.

    <img src={require('../assets/images/crypto-03-stake.png').default} width="80%" alt="Crypto" /><br clear="all" />

2. Select _Delegate Funds_ at the top of the page.

3. Enter the Coinbase validator address in the _Validator address_ field: `crocncl1v2l4sq3lx998d43rt68nxthkzg56mmmke0u0gc`

:::info COINBASE VALIDATOR INFORMATION
Validator name: Coinbase <br />
Validator address : `crocncl1v2l4sq3lx998d43rt68nxthkzg56mmmke0u0gc`
:::

4. Enter the amount of CRO you would like to stake in the _Delegation Amount_ field.

:::caution
Please leave at least 1 CRO in your account un-delegated to use for the fee to claim delegation rewards
:::

5. Select _Review_.

6. Enter your Crypto.org Desktop Wallet web app password and select _Decrypt Wallet_.

7. Select _Continue_.

8. Confirm the details of your delegation and select _Confirm_ to continue.


:::tip Congratulations! You are now staked to the Coinbase validator.
:::


<!-- File: /Users/tinahe/docs/projects/paymaster/docs/paymaster-bundler-api.mdx -->

---
title: Paymaster API Reference
sidebar_label: API Reference
slug: paymaster-bundler-api
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

### Example repository

See [paymaster-bundler-examples](https://github.com/coinbase/paymaster-bundler-examples) on Github for help integrating our Paymaster with popular SDKs.

### Need Help?

Join the [CDP Discord](https://discord.com/invite/cdp ) and let us know in `#paymaster` if you need assistance.

## Bundler methods

### eth_supportedEntryPoints

This endpoint retrieves an array of supported entry points. Currently, the only supported entrypoint is V0.6 `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789`.

#### Request/Response

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_supportedEntryPoints"
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": ["0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"]
}
```

</TabItem>
</Tabs>

### eth_getUserOperationByHash

This endpoint returns a `UserOperation` based on the hash returned from [eth_sendUserOperation](#eth_senduseroperation).

#### Parameters

| Name | Type  | Req | Description                                |
| :--- | :---- | :-: | :----------------------------------------- |
| hash | array |  Y  | The hash of the UserOperation to retrieve |

#### Returns

| Type                 | Description                                                                                    |
| :------------------- | :--------------------------------------------------------------------------------------------- |
| sender               | Account initiating the UserOperation                                                        |
| nonce                | Nonce                                                                                          |
| initCode             | initCode (needed if the account needs to be created)                                           |
| preVerificationGas   | Amount of gas to pay for to compensate the bundler for pre-verification execution and calldata |
| maxFeePerGas         | Maximum fee per gas to pay for the execution of this operation                                 |
| maxPriorityFeePerGas | Maximum priority fee per gas                                                                   |
| signature            | Signature from the account                                                                     |
| verificationGasLimit | Amount of gas to allocate for the verification step                                            |
| callGasLimit         | Amount of gas to allocate the main execution call                                              |
| paymasterAndData     | Hex string signed by the paymaster for a sponsored transaction                                 |
| blockNumber          | Block number in which UserOperation is included                                                |
| blockHash            | Block hash in which UserOperation is included                                                  |
| transactionHash      | Transaction hash of the UserOperation                                                          |

#### Request/Response

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_getUserOperationByHash",
  "params": [
    "0x77c0b560eb0b042902abc5613f768d2a6b2d67481247e9663bf4d68dec0ca122"
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
   "id": 1,
  "result": {
            sender, // string
            nonce, // string
            initCode, // string
            callData, // string
            callGasLimit, // string
            verificationGasLimit, // string
            preVerificationGas, // string
            maxFeePerGas, // string
            maxPriorityFeePerGas, // string
       signature, // string
     paymasterAndData, // string
      blockNumber, // integer
      blockHash, // string
      transactionHash, // string
    }
}
```

</TabItem>
</Tabs>

### eth_getUserOperationReceipt

This endpoint returns a receipt based on the hash returned from [eth_sendUserOperation](#eth_senduseroperation).

#### Parameters

| Name | Type  | Req | Description                                |
| :--- | :---- | :-: | :----------------------------------------- |
| hash | array |  Y  | The hash of the UserOperation to retrieve |

#### Returns

| Type          | Description                                                                                          |
| :------------ | :--------------------------------------------------------------------------------------------------- |
| userOpHash    | Hash of the UserOperation                                                                           |
| entryPoint    | Entrypoint that the UserOperation was sent to                                                       |
| sender        | Account initiating the UserOperation                                                               |
| nonce         | Nonce                                                                                                |
| paymaster     | Paymaster used in the UserOperation                                                               |
| actualGasCost | Actual gas consumed by this UserOperation                                                            |
| actualGasUsed | Total gas used by this UserOperation                                                                 |
| success       | Whether the execution completed successfully                                                         |
| reason        | If reverted, the reason the execution failed                                                         |
| logs          | Logs generated by this UserOperation (not including logs of other UserOperations in the same bundle) |
| receipt       | TransactionReceipt object for the entire bundle                                                      |

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "method": "eth_getUserOperationReceipt",
  "params": [
    "0x77c0b560eb0b042902abc5613f768d2a6b2d67481247e9663bf4d68dec0ca122"
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "userOpHash": "0x13574b2256b73bdc33fb121052f64b3803161e5ec602a6dc9e56177ba387e700",
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "sender": "0x023fEF87894773DF227587d9B29af8D17b4dBB5A",
    "nonce": "0x1",
    "paymaster": null,
    "actualGasCost": "0x6f75ef8d",
    "actualGasUsed": "0x329af",
    "success": true,
    "reason": "",
    "logs": [
      {
        "address": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
        "topics": [
          "0xbb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972"
        ],
        "data": "0x",
        "blockNumber": "0x27fb22e",
        "transactionHash": "0x0f9b0e5868beaf345d8d55895c8037ae85adb91c422c00badcdcae8a0bf247a1",
        "transactionIndex": "0x4",
        "blockHash": "0x965e08190b1093c078bde81f67362203834784e34cf499d516f1a7b9c7a7b29e",
        "logIndex": "0x13",
        "removed": false
      }
    ],
    "receipt": {
      "blockHash": "0x965e08190b1093c078bde81f67362203834784e34cf499d516f1a7b9c7a7b29e",
      "blockNumber": "0x27fb22e",
      "from": "0x425d190ef5F561aFc8728593cA13EAf2FD9E3380",
      "to": "0x25aD59adbe00C2d80c86d01e2E05e1294DA84823",
      "cumulativeGasUsed": "0xe13e1",
      "gasUsed": "0x329af",
      "contractAddress": null,
      "logs": [null],
      "logsBloom": "0x000000010000000000000000800000000000000000000008000000000200000000080000020000020002080100010000001080000000000000100210000000000000000000000008000000000000808010000000000000000001000000000000000000000e000000000000000000080000002200000000408880000000000040000020000000000001000000080000002040000000040000000000000008000020000000000100000040000000000000000000000000000000000220000000400000000000000000000100000010000044000000800020000a100000010020000000000040000081000000000000000000000000000000400000000000100000",
      "status": 1,
      "type": "0x2",
      "transactionHash": "0x0f9b0e5868beaf345d8d55895c8037ae85adb91c422c00badcdcae8a0bf247a1",
      "transactionIndex": "0x4",
      "effectiveGasPrice": "0x6f75ef8d"
    }
  }
}
```

</TabItem>
</Tabs>

### eth_sendUserOperation

This endpoint sends a `UserOperation` for inclusion in the Bundler’s private mempool. The signature must be a valid signature from the smart account.

#### Parameters

| Name          | Type                                                                               | Req | Description                                                                                |
| :------------ | :--------------------------------------------------------------------------------- | :-: | :----------------------------------------------------------------------------------------- |
| UserOperation | [UserOperation](https://www.erc4337.io/docs/understanding-ERC-4337/user-operation) |  Y  | The UserOperation. You may add a `paymasterAndData` field if the transaction is sponsored. |
| entryPoint    | string                                                                             |  Y  | EntryPoint address that the UserOperation is intended for.                                 |

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "jsonrpc": "2.0",
   "id": 1,
  "method": "eth_sendUserOperation",
  "params": [
            {
            sender, // address
            nonce, // uint256
            initCode, // string
            callData, // string
            callGasLimit, // string
            verificationGasLimit, // string
            preVerificationGas, // string
            maxFeePerGas, // string
            maxPriorityFeePerGas, // string
       signature, // string
     paymasterAndData, // string
        }, "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0x1234...5678"
}
```

</TabItem>
<TabItem value="jsonError" label="Error (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "message": "AA21 didn't pay prefund",
    "code": -32500
  }
}
```

</TabItem>
</Tabs>

### eth_estimateUserOperationGas

This endpoint will estimate the gas values for a UserOperation. The signature field is ignored and can be a dummy value, but is recommended to be of the same size as an actual signature for an accurate estimate.

#### Parameters

| Name          | Type                                                                               | Req | Description                                                                                                               |
| :------------ | :--------------------------------------------------------------------------------- | :-: | :------------------------------------------------------------------------------------------------------------------------ |
| UserOperation | [UserOperation](https://www.erc4337.io/docs/understanding-ERC-4337/user-operation) |  Y  | The UserOperation. You can use a dummy signature but the signature must be the correct size for an accurate gas estimate. |
| entryPoint    | string                                                                             |  Y  | EntryPoint address that the UserOperation is intended for.                                                                |

#### Returns

| Type                 | Description                                                                         |
| :------------------- | :---------------------------------------------------------------------------------- |
| preVerificationGas   | Amount of gas to compensate the bundler for pre-verification execution and calldata |
| verificationGasLimit | Amount of gas to allocate for the verification step                                 |
| callGasLimit         | Amount of gas to allocate the main execution call                                   |

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "jsonrpc": "2.0",
   "id": 1,
  "method": "eth_estimateUserOperationGas",
  "params": [
            {
            sender, // address
            nonce, // uint256
            initCode, // string
            callData, // string
            callGasLimit, // string
            verificationGasLimit, // string
            preVerificationGas, // string
            maxFeePerGas, // string
            maxPriorityFeePerGas, // string
       signature, // string
     paymasterAndData, // string
        }, "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789"
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "preVerificationGas": "0x...",
    "verificationGasLimit": "0x...",
    "callGasLimit": "0x..."
  }
}
```

</TabItem>
<TabItem value="jsonError" label="Error (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "error": {
    "message": "Error reason here.",
    "code": -32601
  }
}
```

</TabItem>
</Tabs>


## Paymaster methods

### pm_getPaymasterStubData

:::info
See the [ERC-7677 docs](https://www.erc7677.xyz/reference/paymasters/getPaymasterStubData) for parameters and returns.
:::

#### EntryPoint v0.6

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1, 
  "method": "pm_getPaymasterStubData",
  "params": [
    {
      "sender": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
      "nonce": "0x2a", 
      "initCode": "0x",
      "callData": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",
      "callGasLimit": "0x0",
      "verificationGasLimit": "0x0", 
      "preVerificationGas": "0x0",
      "maxFeePerGas": "0x0",
      "maxPriorityFeePerGas": "0x0"
    },
    "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "0x14A34",
    {
      "policyId": "631528b0-d444-4a9b-a575-40dd3aa4a13a"
    }
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "paymasterAndData": "0xe3dc822D77f23984723871310CAAA32100000000000000000000000000000000000000000000000000000101010101010000000000000000000000000000000000000000000000000000000000000000cd91f19f0f19ce862d7bec7b7d9b95457145afc6f639c28fd0360f488937bfa41e6eedcd3a46054fd95fcd0e3ef6b0bc0a615c4d975eef55c8a3517257904d5b1c",
    "sponsor": {
      "name": "My App",  
      "icon": "https://upload.wikimedia.org/wikipedia/en/c/cc/Wojak_cropped.jpg"
    }
  }
}
```

</TabItem>
</Tabs>

### pm_getPaymasterData

:::info
See the [ERC-7677 docs](https://www.erc7677.xyz/reference/paymasters/getPaymasterData) for parameters and returns.
:::

#### EntryPoint v0.6

<Tabs>
<TabItem value="jsonRequest" label="Request (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "pm_getPaymasterData",
  "params": [
    {
      "sender": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
      "nonce": "0x2a",  
      "initCode": "0x",
      "callData": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675",  
      "callGasLimit": "0x0",
      "verificationGasLimit": "0x0",
      "preVerificationGas": "0x0",
      "maxFeePerGas": "0x0", 
      "maxPriorityFeePerGas": "0x0"
    },
    "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "0x14A34",
    {
      "policyId": "631528b0-d444-4a9b-a575-40dd3aa4a13a"
    }
  ]
}
```

</TabItem>
<TabItem value="jsonResponse" label="Response (JSON)">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "paymasterAndData": "0xe3dc822D77f23984723871310CAAA32100000000000000000000000000000000000000000000000000000101010101010000000000000000000000000000000000000000000000000000000000000000cd91f19f0f19ce862d7bec7b7d9b95457145afc6f639c28fd0360f488937bfa41e6eedcd3a46054fd95fcd0e3ef6b0bc0a615c4d975eef55c8a3517257904d5b1c"
  }
}
```

</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/paymaster/docs/paymaster-bundler-qs-headless.mdx -->

---
title: "Quickstart: Submit your first sponsored smart account transaction"
sidebar_label: Quickstart (Headless)
slug: paymaster-bundler-qs-headless
---

This Paymaster quickstart tutorial explains how to submit your first smart account transaction on Base Sepolia using [Viem](https://viem.sh/), with gas sponsorship from [Coinbase Developer Platform](https://portal.cdp.coinbase.com/products/bundler-and-paymaster). The example below sponsors an NFT mint, but can be updated to call your smart contract instead.

## Prerequisites

```
node >= 14.0.0
npm >= 6.0.0
```

## Getting an endpoint on Base Sepolia

> **How to Get a Paymaster & Bundler endpoint on Base testnet (Sepolia) from CDP**


1. [Create](https://coinbase.com/developer-platform) a new CDP account or [sign in](https://portal.cdp.coinbase.com) to your exsiting account.
2. Navigate to [Paymaster](https://portal.cdp.coinbase.com/products/bundler-and-paymaster).
3. The address of the NFT contract we are calling is `0x66519FCAee1Ed65bc9e0aCc25cCD900668D3eD49`, add that to the contract allowlist and save the policy.
4. Switch to Base testnet (Sepolia) in the top right of the configuration.
5. Copy your endpoint to use later.

<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>

<figcaption>
  <i>Paymaster - Gas Policy</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-config-highlight.png").default} width="700" alt="" /> <br />
<br />

</div>
</details>

## Sending a transaction

**How to call the mint function of a Base Sepolia NFT contract (or contract of choice)**

### 1. Initialize your project

In your terminal, create a directory called `paymaster-tutorial` and initialize a project using [npm](https://www.npmjs.com/).

```js
mkdir paymaster-tutorial
cd paymaster-tutorial
npm init es6
```

### 2. Download dependencies

2. Install `viem`.

```js
npm install viem
```

### 3. Create smart account using a private key

The example below uses Coinbase smart wallet, but any smart account will work.
  a. Create a new private key with [Foundry](https://book.getfoundry.sh/reference/cast/cast-wallet-new).
  b. Install Foundry: `curl -L https://foundry.paradigm.xyz | bash`
  c. Generate a new key pair: `cast wallet new`.
  d. Update your `config.js` file with the private key and create the account.

```js
//config.js
import { createPublicClient, http } from 'viem'
import { toCoinbaseSmartAccount } from 'viem/account-abstraction'
import { baseSepolia } from 'viem/chains'
import { privateKeyToAccount } from 'viem/accounts'

// Your RPC url. Make sure you're using the right network (base vs base-sepolia)
export const RPC_URL = "https://api.developer.coinbase.com/rpc/v1/base-sepolia/<your-rpc-token>"

export const client = createPublicClient({
  chain: baseSepolia,
  transport: http(RPC_URL),
})

// Creates a Coinbase smart wallet using an EOA signer
const owner = privateKeyToAccount('<your-private-key>')
export const account = await toCoinbaseSmartAccount({
  client,
  owners: [owner]
}) 
```

### 4. Add your smart contract's ABI

Create a file called `example-app-abi.js` to store our NFT contract's abi and address. You will have to update this to your smart contract's ABI.

```js
//example-app-abi.js
export const abi = [
  {
    inputs: [
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint16", name: "item", type: "uint16" },
    ],
    name: "mintTo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "payable",
    type: "function",
  },
];
```

### 5. Create the Bundler and Paymaster clients, submit transaction

Create a new file called `index.js`

```ts
//index.js
import { http } from "viem";
import { baseSepolia } from "viem/chains";
import { createBundlerClient } from "viem/account-abstraction";
import { account, client, RPC_URL } from "./config.js";
import { abi } from "./example-app-abi.js";

// Logs your deterministic public address generated by your private key
console.log(`Minting nft to ${account.address}`)

// The bundler is a special node that gets your UserOperation on chain
const bundlerClient = createBundlerClient({
  account,
  client,
  transport: http(RPC_URL),
  chain: baseSepolia,
});

// The call for your app. You will have change this depending on your dapp's abi
const nftContractAddress = "0x66519FCAee1Ed65bc9e0aCc25cCD900668D3eD49"
const mintTo = {
  abi: abi,
  functionName: "mintTo",
  to: nftContractAddress,
  args: [account.address, 1],
};
const calls = [mintTo]

// Pads the preVerificationGas (or any other gas limits you might want) to ensure your UserOperation lands onchain
account.userOperation = {
  estimateGas: async (userOperation) => {
    const estimate = await bundlerClient.estimateUserOperationGas(userOperation);
    // adjust preVerification upward 
    estimate.preVerificationGas = estimate.preVerificationGas * 2n;
    return estimate;
  },
};

// Sign and send the UserOperation
try {
  const userOpHash = await bundlerClient.sendUserOperation({
    account,
    calls,
    paymaster: true
  });

  const receipt = await bundlerClient.waitForUserOperationReceipt({
    hash: userOpHash,
  });

  console.log("✅ Transaction successfully sponsored!");
  console.log(`⛽ View sponsored UserOperation on blockscout: https://base-sepolia.blockscout.com/op/${receipt.userOpHash}`);
  console.log(`🔍 View NFT mint on basescan: https://sepolia.basescan.org/address/${account.address}`);
  process.exit()
} catch (error) {
  console.log("Error sending transaction: ", error);
  process.exit(1)
}
```

In your terminal you can run this script using the below command from the correct directory
```js
node index.js
```

## Next steps
Modify your allowlist and gas policy to ensure you only sponsor what you want! 

## Other examples
Coinbase Smart wallet examples can be found on our other quickstart guide or on [smartwallet.dev](https://smartwallet.dev/).

Examples for integrations with other common SDKs can be found here [paymaster-bundler-examples](https://github.com/coinbase/paymaster-bundler-examples/tree/master/examples).

## Troubleshooting
If you run into any errors with this tutorial, please check out our [troubleshooting guide](https://docs.cdp.coinbase.com/paymaster/docs/paymaster-bundler-troubleshooting).



<!-- File: /Users/tinahe/docs/projects/paymaster/docs/welcome.mdx -->

---
title: Welcome to Paymaster
sidebar_label: Welcome
slug: welcome
---
The Coinbase Paymaster API provides [ERC-4337](https://www.erc4337.io/) Account Abstraction endpoints to send transactions from smart wallets and sponsor gas for users.
  

Paymaster is [ERC-7677](https://www.erc7677.xyz/introduction) compliant and supports both [pm_getPaymasterStubData](https://www.erc7677.xyz/reference/paymasters/getPaymasterStubData) and [pm_getPaymasterData](https://www.erc7677.xyz/reference/paymasters/getPaymasterData).


The endpoint also provides access to our Bundler.

## Get started

1. [Create](https://coinbase.com/developer-platform) a new CDP account or [sign in](https://portal.cdp.coinbase.com) to your existing account.
2. Create a new project.
3. Navigate to the Paymaster product where you'll see $100 in credits (and can get $500 more for adding a payment method).
4. Use the Playground to make a request and see the response.
5. Set your gas policy configurations. Allowlist at least one contract to protect against unintended sponsorship (disregard if allowlisting through a paymaster proxy).
6. Start sending UserOperations and creating gasless experiences for your users.
7. [Apply for additional gas credits](https://docs.google.com/forms/d/1yPnBFW0bVUNLUN_w3ctCqYM9sjdIQO3Typ53KXlsS5g/viewform?edit_requested=true&pli=1) as you scale.

<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>

<figcaption>
  <i>Paymaster - Smart Wallet Sponsored Transaction</i>
</figcaption> <img src={require("../assets/images/pb-sponsorship-scw.png").default} width="700" alt="" /> <br />
<br />

</div>
</details>


<!-- File: /Users/tinahe/docs/projects/paymaster/docs/paymaster-bundler-qs-ui.mdx -->

---
title: "Quickstart: Set up your Paymaster on your application"
sidebar_label: Quickstart
slug: paymaster-bundler-qs-ui
---

This Paymaster quickstart tutorial explains how to set up a basic app and sponsor transactions using [OnchainKit](https://onchainkit.xyz/) and Coinbase Smart Wallet.

## Getting an endpoint on Base Sepolia

> **How to Get a Paymaster & Bundler endpoint on Base testnet (Sepolia) from CDP**

1. [Create](https://coinbase.com/developer-platform) a new CDP account or [sign in](https://portal.cdp.coinbase.com) to your exsiting account.
2. Navigate to [Paymaster](https://portal.cdp.coinbase.com/products/bundler-and-paymaster).
3. Add the following address to the allowlist under **Configuration**&mdash;this is the address of the contract we are calling:

    ```
    0x67c97D1FB8184F038592b2109F854dfb09C77C75
    ```
4. Switch to Base testnet (Sepolia) in the top right of the configuration.
5. Copy your endpoint to use later.

<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>

<figcaption>
  <i>Paymaster - Gas Policy</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-config.png").default} width="700" alt="" /> <br />
<br />

</div>
</details>

## Setting up an app template

Clone the repo
```js
git clone https://github.com/coinbase/onchain-app-template.git
cd onchain-app-template
```

You can find the API key on the Coinbase Developer Portal's [OnchainKit page](https://portal.cdp.coinbase.com/products/onchainkit). If you don't have an account, you will need to create one.
You can find your Wallet Connector project ID at Wallet Connect.
Add the following to your `.env` file
```js
NEXT_PUBLIC_PAYMASTER_AND_BUNDLER_ENDPOINT=ADD_YOUR_PAYMASTER_URL_HERE
NEXT_PUBLIC_CDP_API_KEY=ADD_YOUR_ONCHAINKIT_KEY_HERE
NEXT_PUBLIC_WC_PROJECT_ID=ADD_YOUR_PROJECT_ID_HERE
```

Install dependencies - run these in your terminal in the root of the project
```js
# Install bun in case you don't have it
bun curl -fsSL <https://bun.sh/install> | bash

# Install packages
bun i
```

### Add your paymaster to the transact button 
Navigate to ```/src/components/TransactionWrapper.tsx``` and modify the Transaction component to include the paymaster service.
```js
      <Transaction
        address={address}
        contracts={contracts}
        className="w-[450px]"
        chainId={BASE_SEPOLIA_CHAIN_ID}
        onError={handleError}
        onSuccess={handleSuccess}
        // Paymaster capabilities added below 
        capabilities={{
          paymasterService: {
            url: process.env.NEXT_PUBLIC_PAYMASTER_AND_BUNDLER_ENDPOINT!,
          },
        }}
      >
        <TransactionButton
          className="mt-0 mr-auto ml-auto w-[450px] max-w-full text-[white]"
          text="Collect"
        />
        <TransactionStatus>
          <TransactionStatusLabel />
          <TransactionStatusAction />
        </TransactionStatus>
      </Transaction>
```

### Start the app locally
```js
bun run dev
```

### Open the app in your browser and sign in with a smart wallet
Navigate to [http://localhost:3000](http://localhost:3000)

Click connect and sign in with your smart wallet or create a new one.


### Initiate the transaction
Click the "Collect" button and your paymaster will sponsor. Note only Smart Wallets can have sponsored transactions so EOA accounts will not get sponsorship.

Thats it! You've successfully set up your paymaster on your application.

## Other Examples
Additional documentation and information on Coinbase Smart Wallet is at [smartwallet.dev](https://smartwallet.dev/).

Check out how to build onchain applications with ease using [OnchainKit](https://onchainkit.xyz/)!


<!-- File: /Users/tinahe/docs/projects/paymaster/docs/paymaster-bundler-troubleshooting.mdx -->

---
title: "Paymaster & Bundler Troubleshooting"
sidebar_label: Troubleshooting
slug: paymaster-bundler-troubleshooting
---

This tutorial explains how to debug common issues you may face when sending UserOperations.

## Execution reverted
The UserOperation was able to make it onchain, but an error occured in one of the smart contracts it interacted with, and thus the entire operation had to be reverted. This can be due to
* Not enough gas to pay for execution
  * Try increasing the `preVerificationGas` or `callGasLimit` padding
* An issue with the `callData` of your UserOperations
  * This is an issue with your dapp's smart contract, which you will need to debug.

You can use a tool like [Tenderly](https://dashboard.tenderly.co/) to help simulate and debug the UserOperation. 

### Issue regarding gas estimation
If you think the issue may be related to gas, simulate using the Entrypoint contract, `0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789`, and pasting in your UserOperation into the `tuple` field.

For example, your UserOperation may look something like
```
{
  "callData": "0xb61d27f600000000000000000000000066519fcaee1ed65bc9e0acc25ccd900668d3ed490000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000443f84ac0e0000000000000000000000001e3143e0ed8c0ea51f1551b6c355e02f3e0baae0000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000",
  "paymasterAndData": "0xc484bcd10ab8ad132843872deb1a0adc1473189c000066cd03db0000000000000098973f00000a968163f0a57b400000018633de6cf5e53752c5eac49e8f8ffb4ecd16b2afe7b4074086d6693536a9ab1f117bae0b427f83f94246c34d25add97b05e8a73859c2dceef6ee730ab2842bf31b",
  "sender": "0x1e3143E0ED8C0Ea51F1551B6c355e02f3e0bAae0",
  "initCode": "0x",
  "maxFeePerGas": "3000000000",
  "maxPriorityFeePerGas": "1000000000",
  "nonce": "31815307923431762811356398485504",
  "signature": "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000041ca7a742cff01aa9d5e377c5a146b5d8f03a4e44bd1817b1899bf7e0ff6885ed63294c69f017fe47f385c046055cc687e503bba08513ff52fbf21dcd8019c1f1d1b00000000000000000000000000000000000000000000000000000000000000",
  "callGasLimit": "257565",
  "preVerificationGas": "96024",
  "verificationGasLimit": "87888"
}
```

You can use the `simulateHandleOp` function and pass that UserOperation in the `op` field (don't forget to add array brackets around it, because technically it handles a "bundle" of UserOperations).
<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>
<figcaption>
  <i>Tenderly - Entrypoint</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-tenderly-entrypoint.png").default} width="700" alt="" /> <br />
<br />
</div>
</details>

### Execution reverted with data
Error may look something like this
```
cause: {
  "code": -32004,
  "message": " - execution reverted with data",
  "data": "0xed6c3dec00000000000000000000000036e53f56454e1206f775dafe2b33c1b737c43632"
}
```

You can use a tool like https://bia.is/tools/abi-decoder/ to upload your ABI, enter the data in, and decode the error message. Try using the ABI of every smart contract your dapp could be interacting with.

### Execution reverted for an unknown reason
Similar to above, except your contract is reverting without any error codes. Try reviewing your smart contract's code, your `callData`, and using [Tenderly](https://dashboard.tenderly.co/) to debug. It may help to have your [contract verified.](https://book.getfoundry.sh/reference/forge/forge-verify-contract)

The example below shows you how to debug your own smart contract.
* `Insert any address` - Enter your smart contract's address here
* `Enter raw input data` - Enter the `callData` of your contract's function (right after `callData = encodeFunctionData()`)
<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>
<figcaption>
  <i>Tenderly - Contract Debug</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-tenderly-dev-debug.png").default} width="700" alt="" /> <br />
<br />
</div>
</details>


## Invalid chain id
You might be using the mainnet RPC url instead of the testnet RPC url (or vis versa). Make sure you select the right network in the CDP portal
<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>
<figcaption>
  <i>Paymaster chain</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-chainid.png").default} width="700" alt="" /> <br />
<br />
</div>
</details>

## Invalid UserOperation signature or paymaster signature

```
UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).
```

This likely means that you updated the UserOperation after getting a signature from our Paymaster service. Our Paymster signs the UserOperation with the UserOperation itself, so make sure you're not making any changes to the UserOperation after it's already been signed by our Paymaster `paymasterClient.getPaymasterData()`. If you need to adjust things like `callData`, `preVerificationGas`, or `callGasLimit`, you will need to receive a new signature from our Paymaster. Also if you're handling multiple UserOperation, make sure the paymaster signature matches the right UserOperation.



<!-- File: /Users/tinahe/docs/projects/paymaster/docs/paymaster-bundler-erc20.mdx -->

---
title: "Paymaster (ERC20): Set up your Paymaster to require ERC20 tokens"
sidebar_label: ERC20 Paymaster 
slug: paymaster-bundler-erc20
---

### Background
Coinbase Developer Platform’s (CDP) Paymaster now supports gas payments with ERC-20 tokens on Base — enabling your app’s users to pay for gas with tokens beyond ETH, like USDC or custom tokens, streamlining the user experience and making it easier to come onchain.

This feature is currently Early Access only. Request access [here](https://app.deform.cc/form/9b59499b-e82e-4879-8100-40c603084747/?page_number=0)

The form will ask you for your token `Contract Address` and a `Receiving Address` on your policy. 
* Contract Address - the address of the ERC20 token you want to enable as gas for your users
* Receiving Address - an address of your choosing where the users' ERC20 tokens will be sent to as they pay for gas (this is orchestrated by the paymaster and happens automatically at the time of the transaction)

If approved for Early Access you'll see these addresses displayed in the Paymaster dashboard under the ERC20 tab (see below)

<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>

<figcaption>
  <i>Paymaster - ERC20 Policy</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-policy-erc20.png").default} width="700" alt="" /> <br />
<br />

</div>
</details>


### Billing
Because you’re receiving the ERC20 tokens back, CDP will meter all the token transfers, and bill you at the end of the month similar to the regular sponsored gas flow (based on the USD value of the ERC20 at the time your wallet receives). This gives you the flexibility to decide what to do with the tokens. The Paymaster's regular 7% service fee applies to this volume and is factored into the ERC20 quote your users receive and accept.

Note: existing Paymaster specific CDP credits continue to apply for regular sponsored Paymaster volume but not ERC20 Paymaster volume.

### Configuring your policy
__To allows your users to pay their gas in an ERC20 token, your policy needs to be configured to reject regular sponsorship.__

This allows you to configure customizations such as
* Fully sponsor 3 UserOperations per user per day - any additional UserOperations will require users to pay using ERC20 token
* Fully sponsor UserOperations up to $1 per week - any additional UserOperations will require users to pay using ERC20 token
* Never fully sponsor any UserOperations - all UserOperations will require users to pay using an ERC20 token

__If you only want the third option (always require users to pay using erc20 token) we recommend setting your `Per User Adress Max` to `.01`.__

We also recommend creating a separate project to test your ERC20 custom flows so it doesn’t affect any existing regular sponsorship flows that you have.

<details>
<summary><b>Expand for images and click to enlarge</b></summary>
<div>

<figcaption>
  <i>Paymaster - ERC20 Policy Flow</i>
</figcaption> <img src={require("../assets/images/pb-paymaster-policy-erc20-flow.png").default} width="700" alt="" /> <br />
<br />

</div>
</details>


### Integration guide & code examples
The ERC20 Paymaster fits seamlessly into any existing regular sponsored Paymaster integration. The only difference is that you need to configure your smart wallet to `approve` our Paymaster contract to spend your user’s ERC20 tokens.
* Paymaster Contract Address (Sepolia): `0x709a4bae3db73a8e717aefca13e88512f738b27f`
* Paymaster Contract Address (Mainnet): `0x2FAEB0760D4230Ef2aC21496Bb4F0b47D634FD4c`

For example, the code below is almost identical to the `index.js` in the [Paymaster quickstart guide](https://docs.cdp.coinbase.com/paymaster/docs/paymaster-bundler-qs-headless). The only difference is that we added an `approve` function call to the `calls` field.

```
//index.js
import { http, encodeFunctionData, parseAbi } from "viem";
import { baseSepolia } from "viem/chains";
import { createBundlerClient } from "viem/account-abstraction";
import { account, client, RPC_URL } from "./config.js";
import { abi } from "./example-app-abi.js";

// Logs your deterministic public address generated by your private key
console.log(`Minting nft to ${account.address}`)

// The bundler is a special node that gets your UserOperation on chain
const bundlerClient = createBundlerClient({
  account,
  client,
  transport: http(RPC_URL),
  chain: baseSepolia,
});

// Approves our paymaster to spend your users erc20 tokens. The example below uses USDC
const tokenAddress = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
const tokenAmount = 1000000 // 1 USDC
const paymasterAddress = "0x709a4bae3db73a8e717aefca13e88512f738b27f"
const approve = {
  to: tokenAddress,
  data: encodeFunctionData({
      abi: parseAbi(["function approve(address,uint)"]),
      functionName: "approve",
      args: [paymasterAddress, tokenAmount],
  })
}

// The call for your app. You will have change this depending on your dapp's abi
const nftContractAddress = "0x66519FCAee1Ed65bc9e0aCc25cCD900668D3eD49"
const mintTo = {
  abi: abi,
  functionName: "mintTo",
  to: nftContractAddress,
  args: [account.address, 1],
};
const calls = [approve, mintTo]

// Pads the preVerificationGas (or any other gas limits you might want) to ensure your UserOperation lands onchain
account.userOperation = {
  estimateGas: async (userOperation) => {
    const estimate = await bundlerClient.estimateUserOperationGas(userOperation);
    // adjust preVerification upward 
    estimate.preVerificationGas = estimate.preVerificationGas * 2n;
    return estimate;
  },
};

// Sign and send the UserOperation
try {
  const userOpHash = await bundlerClient.sendUserOperation({
    account,
    calls,
    paymaster: true
  });

  const receipt = await bundlerClient.waitForUserOperationReceipt({
    hash: userOpHash,
  });

  console.log("✅ Transaction successfully sponsored!");
  console.log(`⛽ View sponsored UserOperation on blockscout: https://base-sepolia.blockscout.com/op/${receipt.userOpHash}`);
  console.log(`🔍 View NFT mint on basescan: https://sepolia.basescan.org/address/${account.address}`);
  process.exit()
} catch (error) {
  console.log("Error sending transaction: ", error);
  process.exit(1)
}
```

Please consider checking for your user's ERC20 `allowance` before adding the additional ERC20 `approve` function call. This will save on gas costs for your users as our Paymaster is already allowed to spend their funds.

```
// Checks for allowance
const allowance = await client.readContract({
  abi: parseAbi(["function allowance(address owner, address spender) returns (uint256)"]),
  address: tokenAddress,
  functionName: "allowance",
  args: [account.address, paymasterAddress],
})

const calls = [mintTo]
if (allowance < tokenAmount) {
   calls.unshift(approve)
}
```

### Specification

The CDP ERC20 Paymaster uses both `pm_getPaymasterStubData` and `pm_getPaymasterData` JSON-RPC requests specified by ERC-7677 and an additional API `pm_getAcceptedPaymentTokens`. We step through each request and response below. 

#### pm_getPaymasterStubData and pm_getPaymasterData

1. The paymaster will use the specified ERC20 for payment if specified in the 7677 context field under `erc20`.
2. Upon rejection / failure the paymaster should return a `data` field in the JSONRPC response which could be used to approve the paymaster and includes:
- `acceptedTokens` array which is a struct including the token address 
- `paymasterAddress` field which is the paymaster address which will perform the token transfers. 
3. Upon success the paymaster will return a `tokenPayment` field in the result. This includes: 
- `tokenAddress` address of the token used for payment
- `maxFee` the maximum fee to show in the UI
- `decimals` decimals to use in the UI 
- `name` name of the token

Smart wallet will simulate the transaction to ensure success and accurate information.

##### Request 

This is a standard V0.6 Entrypoint request example with the additional context for the specified token to be used. 

```json 
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "pm_getPaymasterData",
  "params": [
    {
      "sender": "0xe62B4aD6A7c079F47D77a9b939D5DC67A0dcdC2B",
      "nonce": "0x4e",
      "initCode": "0x",
      "callData": "0xb61d27f60000000000000000000000007746371e8df1d7099a84c20ed72e3335fb016b23000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000",
      "callGasLimit": "0x113e10",
      "verificationGasLimit": "0x113e10",
      "preVerificationGas": "0x113e10",
      "maxFeePerGas": "0x113e10",
      "maxPriorityFeePerGas": "0x113e10",
      "paymasterAndData": "0x",
      "signature": "0x5ee079a5dec73fe39c1ce323955fb1158fc1b9a6b2ddbec104cd5cfec740fa5531584f098b0ca95331b6e316bd76091e3ab75a7bc17c12488664d27caf19197e1c"
    },
    "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "0x2105",
    {
      "erc20": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"
    }
  ]
}
```

##### Response 

Successful response:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "paymasterAndData": "0x2faeb0760d4230ef2ac21496bb4f0b47d634fd4c0000670fdc98000000000000494b3b6e1d074fbca920212019837860000100833589fcd6edb6e08f4c7c32d4f71b54bda029137746371e8df1d7099a84c20ed72e3335fb016b23000000000000000000000000000000000000000000000000000000009b75458400000000697841102cd520d4e0171a58dadc3e6086111a49a90826cb0ad25579f25f1652081f68c17d8652387a33bf8880dc44ecf95be4213e786566d755baa6299f477b0bb21c",
    "tokenPayment": {
      "name": "USDC",
      "address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
      "maxFee": "0xa7c8",
      "decimals": 6
    }
  }
}
```

Rejection response:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "error": {
    "code": -32002,
    "message": "request denied - no sponsorship and address can not pay with accepted token",
    "data": {
      "acceptedTokens": [
        {
          "name": "USDC",
          "address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
        }
      ]
    }
  }
}
```

#### pm_getAcceptedPaymentTokens

`pm_getAcceptedPaymentTokens` returns an array of tokens the paymaster will accept for payment. 
The request contains the entrypoint and the chain id with optional context. 

##### Request 
```json
{
  "jsonrpc": "2.0", "id": 1,
  "method": "pm_getAcceptedPaymentTokens",
  "params": [ "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789", "0x2105", {}]
}
```

##### Response 
```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "acceptedTokens": [
      {
        "name": "USDC",
        "address": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913"
      }
    ]
  }
}
```

### Troubleshooting

`“request denied - max address sponsorship value reached 0x4D44afB8D98c9984F381E60Ac855D89C73f40e45 and sender can not pay with an accepted ERC20”`

The first part of the error signifies why the regular fully sponsored transaction was not accepted. This is to be expected. However, if the “sender can not pay with an accepted ERC20”, check to make sure that the user has enough ERC20 tokens in their wallet to pay for the gas and your wallet approved our Paymaster to spend those tokens.



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-aggregating.mdx -->

---
title: "One-click-buy Onramp URL"
sidebar_label: "One-click-buy URL"
slug: "api-oneclickbuy"
---

The One Click Buy API lets developers get a quote for the fees and an exchange rate for a buy. 
Then it initializes Coinbase Onramp with the appropriate parameters to execute that buy.

1. Generate a quote using the [Buy Quote API](./api-generating-quotes.mdx#buy-quote).
1. Initialize Coinbase Onramp with the parameters used to get the quote (see below).

### One-Click-Buy URLs
You can create an Onramp link with all inputs pre-filled that takes users straight to the final order preview screen. 
This is useful when users have already chosen an amount and preferred payment method outside of Coinbase Onramp. 
One-Click-Buy links must have following query parameters set in the URL:
- `quoteId` (from the [Buy Quote API](/onramp/docs/api-generating-quotes/#buy-quote))
- `presetFiatAmount`
- `fiatCurrency`
- `defaultAsset`
- `defaultPaymentMethod`

For example: 

    ```bash
    https://pay.coinbase.com/buy/select-asset?appId=58a3fa2e-617f-4198-81e7-096f5e498c00&destinationWallets=[{"address":"0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C","blockchains":["ethereum"]}]&defaultAsset=ETH&defaultPaymentMethod=CARD&fiatCurrency=USD&presetFiatAmount=10&quoteId=ae77980c-f656-4c69-b380-cb5cf99276a9
    ```

### Query parameters

| Parameter            | Reqd | Type   | Description |
|:---------------------|:-----|:-------|:------------|
| quoteId              | Yes  | String | ID of the quote. _Received from [Buy Quote](./api-generating-quotes.mdx#buy-quote)._ |
| defaultAsset         | Yes  | String | UUID of asset. <br /><br />_Received from [Buy Options](./api-configurations.mdx#buy-options) and sent to [Buy Quote](./api-generating-quotes.mdx#buy-quote)._ |  
| defaultNetwork       | No   | String | Default network that should be selected when multiple networks are present. When not set, default is the asset network. <br /><br />_Received from [Buy Options](./api-configurations.mdx#buy-options) and sent to [Buy Quote](./api-generating-quotes.mdx#buy-quote)._ |
| defaultPaymentMethod | Yes  | String | Default payment method, one of: <ul> <li>`CRYPTO_ACCOUNT`</li> <li>`FIAT_WALLET`</li> <li>`CARD`</li> <li>`ACH_BANK_ACCOUNT`</li> <li>`APPLE_PAY`</li></ul> <i>Received from [Buy Options](./api-configurations.mdx#buy-options) and sent to [Buy Quote](./api-generating-quotes.mdx#buy-quote).</i> |
| fiatCurrency         | Yes  | String | Ticker symbol of the fiat currency. |
| presetFiatAmount     | Yes  | Number | Amount to be spent on the crypto purchase, fees included. | 



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-reporting.mdx -->

---
title: "Transaction Status & History"
sidebar_label: "Transaction Status"
slug: "api-reporting"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Onramp Transaction Status

The Transaction Status API provides developers with a real time list of user Onramp transactions. Developers can poll the real time status of transactions and show users a view of their Coinbase Onramp transactions made within the client app.

To link all transactions created during the session, developers must provide the (optional) field `partnerUserId` as a query parameter when [initializing Coinbase Onramp](./api-initializing.mdx).

Transaction Status returns a paginated list of all transactions from newest to oldest. If the client app doesn’t have a concept of a user, clients can pass a random `partnerUserId` to reference a one-off session.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/buy/user/{partner_user_id}/transactions?page_key={next_page_key}&page_size={page_size}
```

### Request Parameters

The Transaction Status API is an RPC endpoint that accepts an argument as part of its URL path.

| Name              | Type   | Req | Description |
|:------------------|:-------|:----|:------------|
| `partner_user_id` | String | Y   | ID referring to user Onramp transactions in client app. |
| `page_key`        | String | N   | Reference to next page of transactions. Returned in previous page’s response. |
| `page_size`       | Number | N   | Number of transactions to return per page. Default is 1. |

### Response Fields

The Transaction Status API returns a JSON response including the following fields.

| Name            | Description |
|:----------------|:------------|
| `transactions`  | List of `OnrampTransactions` in reverse chronological order. |
| `next_page_key` | A reference to the next page of transactions. |
| `total_count`   | The total number of transactions made by the user. |

#### Onramp Transaction Schema
| Name                | Description | Value |
|:--------------------|:------------|:------| 
| `status`            | Status of the onramp transaction. | `ONRAMP_TRANSACTION_STATUS_IN_PROGRESS`<br/>`ONRAMP_TRANSACTION_STATUS_SUCCESS`<br/>`ONRAMP_TRANSACTION_STATUS_FAILED` |
| `purchase_currency` | Crypto currency being purchased. | String |
| `purchase_network`  | Network used to deliver crypto to the user’s wallet. | String |
| `purchase_amount`   | Amount of crypto currency being purchased. | String |
| `payment_total`     | Total amount of fiat the user will pay. | String |
| `payment_subtotal`  | Amount of fiat the user will pay, exclusive of fees | String |
| `coinbase_fee`      | Amount of fiat charged to cover brokerage fees. | String |
| `network_fee`       | Amount of fiat charged to cover network fees. | String |
| `exchange_rate`     | Unit price of the crypto currency being purchased. | String |
| `country`           | Country the user resides in. | String |
| `user_id`           | Unique identifier representing the user. | String |
| `payment_method`    | Type of payment method the user is paying with. | `CARD`<br/>`ACH_BANK_ACCOUNT`<br/>`APPLE_PAY`<br/>`FIAT_WALLET`<br/>`CRYPTO_WALLET` |
| `tx_hash`           | The block hash of the onchain send. | String |
| `transaction_id`    | Unique identifier for the onramp transaction | String |
| `wallet_address`    | The address of the wallet the transaction was sent to. | String |
| `type`              | The type of transaction. | `ONRAMP_TRANSACTION_TYPE_BUY_AND_SEND`<br/>`ONRAMP_TRANSACTION_TYPE_SEND`<br/> |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/buy/user/{partner_user_id}/transactions?page_key={next_page_key}&page_size={page_size}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
    "transactions": [
        {
            "status":"ONRAMP_TRANSACTION_STATUS_SUCCESS",
            "purchase_currency": "USDC",
            "purchase_network": "base",
            "purchase_amount": {
                "value": "5",
                "currency": "USDC"
            },
            "payment_total": {
                "value": "5.07",
                "currency": "USD"
            },
            "payment_subtotal": {
                "value": "5",
                "currency": "USD"
            },
            "coinbase_fee": {
                "value": "0",
                "currency": "USD"
            },
            "network_fee": {
                "value": "0.07",
                "currency": "USD"
            },
            "exchange_rate": {
                "value": "1",
                "currency": "USDC"
            },
            "tx_hash": "0x31814ba2fef2a400a9816767370be09ca12d9e9753b972198fe330a0ecedcbf6",
            "created_at": "2023-09-26T20:06:07.076Z",
            "country": "US",
            "user_id": "9f86d081884c7d659a2feaa0c55ad01",
            "payment_method": "CARD",
            "transaction_id": "1ee7a7ec-fdd1-6032-ad91-0e2bacb520d3"
    }
],
"next_page_key":"eyJndF9za2lwIjowLCJvdF9za2lwIjoxfQ==",
"total_count":"3"
}
```

</TabItem>
</Tabs>

## Onramp Transactions

The Transactions API provides clients with a historical list of Coinbase Onramp transactions between two dates. 
Transactions returns a paginated list of all transactions from newest to oldest. 
The Transactions API is indented for analytics purposes.

If you need real time information about a specific transaction, use the [Onramp Transaction Status API](#onramp-transaction-status).


### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/buy/transactions?page_key={next_page_key}&page_size={page_size}&start_date={start_date}&end_date={end_date}
```

### Request Parameters

| Name              | Type   | Req | Description |
|:------------------|:-------|:----|:------------|
| `page_key`        | String | N   | Reference to next page of transactions. Returned in previous page’s response. |
| `page_size`       | Number | N   | Number of transactions to return per page. Default is 1000. |
| `start_date`      | String | N   | The start date (inclusive) of the range of transactions to return. YYYY-MM-DD format. Default is one month before `end_date`. |
| `end_date`        | String | N   | The end date (exclusive) of the range of transactions to return. YYYY-MM-DD format. Default is tomorrow. |

### Response Fields

The Transaction API returns a JSON response including the following fields.

| Name            | Description |
|:----------------|:------------|
| `transactions`  | List of `OnrampTransactions` in reverse chronological order. |
| `next_page_key` | A reference to the next page of transactions. |

#### Onramp Transaction Schema
| Name                | Description | Value |
|:--------------------|:------------|:------| 
| `status`            | Status of the buy transaction. | `ONRAMP_TRANSACTION_STATUS_SUCCESS`<br/>`ONRAMP_TRANSACTION_STATUS_FAILED`|
| `purchase_currency` | Crypto currency being purchased. | String |
| `purchase_network`  | Network used to deliver crypto to the user’s wallet. | String |
| `purchase_amount`   | Amount of crypto currency being purchased. | String |
| `payment_total`     | Total amount of fiat the user will pay. | String |
| `payment_subtotal`  | Amount of fiat the user will pay, exclusive of fees | String |
| `coinbase_fee`      | Amount of fiat charged to cover brokerage fees. | String |
| `network_fee`       | Amount of fiat charged to cover network fees. | String |
| `exchange_rate`     | Unit price of the crypto currency being purchased. | String |
| `country`           | Country the user resides in. | String |
| `user_id`           | Unique identifier representing the user. | String |
| `payment_method`    | Type of payment method the user is paying with. | `CARD`<br/>`ACH_BANK_ACCOUNT`<br/>`APPLE_PAY`<br/>`FIAT_WALLET`<br/>`CRYPTO_WALLET` |
| `tx_hash`           | The block hash of the onchain send. | String |
| `transaction_id`    | Unique identifier for the onramp transaction | String |
| `wallet_address`    | The address of the wallet the transaction was sent to. | String |
| `type`              | The type of transaction. | `ONRAMP_TRANSACTION_TYPE_BUY_AND_SEND`<br/>`ONRAMP_TRANSACTION_TYPE_SEND`<br/> |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/buy/transactions?page_key={next_page_key}&page_size={page_size}&start_date={start_date}&end_date={end_date}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
    "transactions": [
        {
            "status":"ONRAMP_TRANSACTION_STATUS_SUCCESS",
            "purchase_currency": "USDC",
            "purchase_network": "base",
            "purchase_amount": {
                "value": "5",
                "currency": "USDC"
            },
            "payment_total": {
                "value": "5.07",
                "currency": "USD"
            },
            "payment_subtotal": {
                "value": "5",
                "currency": "USD"
            },
            "coinbase_fee": {
                "value": "0",
                "currency": "USD"
            },
            "network_fee": {
                "value": "0.07",
                "currency": "USD"
            },
            "exchange_rate": {
                "value": "1",
                "currency": "USDC"
            },
            "tx_hash": "0x31814ba2fef2a400a9816767370be09ca12d9e9753b972198fe330a0ecedcbf6",
            "created_at": "2023-09-26T20:06:07.076Z",
            "country": "US",
            "user_id": "9f86d081884c7d659a2feaa0c55ad01",
            "payment_method": "CARD",
            "transaction_id": "1ee7a7ec-fdd1-6032-ad91-0e2bacb520d3",
            "wallet_address": "0x3d7b51da8AA41270C6e052eE261db4514Ba4D50A"
    }
],
"next_page_key":"eyJndF9za2lwIjowLCJvdF9za2lwIjoxfQ==",
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/sdk-generating-url.mdx -->

---
title: "Generating a URL with the SDK"
sidebar_label: "Generating a URL"
slug: "generating-url"
---

The SDK can generate a URL that is launched by a browser mechanism (for example, a link or button on web, or a webview, or linking on mobile) as an alternative to integrating Coinbase Onramp through [initOnRamp](integrating-onramp#b-call-the-initonramp-method).

## generateOnRampURL Example

```
import { generateOnRampURL } from "@coinbase/cbpay-js";

const onRampURL = generateOnRampURL({
  appId: "1dbd2a0b94",
  addresses: {
    "0x1": ["ethereum"],
    "1a2": ["solana"],
  }
});
```

You can use a generated URL to launch a new tab, webview, etc., with either the provided buttons or text.

```
<a href={onRampURL} target="_blank">Coinbase Onramp</a>
```

## generateOnRampURL Parameters

The following table outlines the parameters supported in the `generateOnRampURL` function:

| Parameter             | Req'd | Type                                                 | Description                               |
| :-------------------- | :---- | :--------------------------------------------------- | :---------------------------------------- |
| addresses             | No    | Record\<String, String[]\>                             | A map of addresses to their lists of supported blockchains e.g. `{ "0x1": ["ethereum"] }` <br /><br /> <b>Required if you are not using the [Onramp Session Token API](./api-initializing.mdx#getting-an-onramp-session-token).</b> |
| assets                | No    | String[]                                             | A list of assets symbols (e.g. "ETH", "BTC"). If this parameter is included <b>only</b> the assets included in it will be availble to the user.
| appId                 | No    | String                                               | Unique short-string ID provided to partners by the Coinbase Onramp team <br /><br /> <b>Required if you are not using the [Onramp Session Token API](./api-initializing.mdx#getting-an-onramp-session-token).</b>  |
| defaultNetwork        | No    | String                                               | Default network that should be selected when multiple networks are present  |
| presetCryptoAmount    | No    | Number                                               | Preset crypto amount value. |
| presetFiatAmount      | No    | Number                                               | Preset fiat amount value (for USD, CAD, GBP, EUR only). Ignored if `presetCryptoAmount` is also set.    |
| defaultExperience     | No    | 'send', 'buy'                                        | Default visual experience: either (1) Transfer funds from Coinbase ('send') or (2) Buy assets ('buy')   |
| handlingRequestedUrls | No    | boolean                                              | Prevents the widget from opening URLs directly & relies on `onRequestedUrl` entirely for opening links  |
| partnerUserId         | No    | String                                               | Unique ID representing the client app user. Must be less than 50 chars. Use with the Transaction Status API to retrieve transactions made during the session. |
| sessionToken          | No    | String                                               | Token generated by the [Onramp Session Token API](./api-initializing.mdx#getting-an-onramp-session-token).             |

:::info
All transactions made during the session are linked to `partnerUserId` which can be used with the Transaction Status API to retrieve these transactions later.
:::

## Subscribing to Widget Events

You can manually process widget events on web & [React Native](https://github.com/coinbase/cbpay-js/blob/main/README.md#react-native-example), as follows:

##### Prerequisites

```
yarn add react-native-url-polyfill
```

###### React-Native Example

```
import React, { useMemo } from 'react'
import { WebView } from 'react-native-webview'
import { generateOnRampURL } from '@coinbase/cbpay-js'
import 'react-native-url-polyfill/auto'

const CoinbaseWebView = ({ currentAmount }) => {
  const coinbaseURL = useMemo(() => {
    const options = {
      appId: 'your_app_id',
      // Specify the addresses and which networks they support
      addresses: { '0x1': ['ethereum','base'], 'bc1': ['bitcoin']},
      // (Optional) Filter the available assets on the above networks to just these ones
      assets: ['ETH','USDC','BTC'],
      handlingRequestedUrls: true,
      presetCryptoAmount: currentAmount,
    }

    return generateOnRampURL(options)
  }, [currentAmount, destinationAddress])

  const onMessage = useCallback((event) => {
    // Check for Success and Error Messages here
    console.log('onMessage', event.nativeEvent.data)
    try {
      const { data } = JSON.parse(event.nativeEvent.data);
      if (data.eventName === 'request_open_url') {
        viewUrlInSecondWebview(data.url);
      }
    } catch (error) {
      console.error(error);
    }
  }, [])

  return (
    <WebView source={{ uri: coinbaseURL }} onMessage={onMessage} />
  )
}

export default CoinbaseWebView
```

<br />

**See Also:**

- [Installing the SDK](./sdk-installing-sdk.mdx)
- [Integrating Onramp with the SDK](./sdk-integrating-onramp.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/intro-use-cases.mdx -->

---
title: "Onramp Use Cases"
sidebar_label: "Use Cases"
slug: "use-cases"
hide_table_of_contents: false
---


Coinbase Onramps delivers a seamless fiat to crypto funding experience for users. Some of the use cases that developers can support with Coinbase Onramp are listed below.


### Add funds from Coinbase to self-custody wallet

Crypto wallets can integrate Coinbase Onramp into their mobile app, browser extension, or web app. 
Wallet users can then trigger Coinbase Onramp and seamlessly add funds to their self-custody wallet by either 
(1) purchasing crypto with a saved payment method in their Coinbase account, or 
(2) transferring a crypto balance from their Coinbase account.

### Add funds to a linked self-custody wallet without leaving the DeFi protocol

DeFi protocols can integrate Coinbase Onramp to let their users seamlessly fund and top-up their linked self-custody wallets. 
For example, users can link their self-custody wallet to a DeFi protocol; 
and if they don't have enough funds, they can use Onramp to add funds to their linked self-custody wallet without leaving the protocol.

### Buy/transfer ETH from Coinbase without leaving the NFT marketplace

NFT marketplaces can integrate Coinbase Onramp to let their users seamlessly fund and top-up their linked self-custody wallets. 
For example, users on NFT marketplaces may not have enough ETH in their linked self-custody wallet to complete an NFT purchase. 
With Onramp, users can purchase or transfer ETH from their Coinbase account and complete the NFT purchase without leaving the NFT marketplace.

### Maximize support by aggregating multiple exchanges

Crypto wallets want to give users the best price to the widest selection of assets across geographies, but not all exchanges offer the same level of coverage. 
A common solution is to integrate with multiple onramp providers, letting users decide which exchange is best for them. 
Coinbase Onramp fully supports aggregators with a suite of APIs to query for coverage for different countries, payment method support, assets, and purchase limits. 
Just call the [Buy Quote API](/onramp/docs/api-generating-quotes#buy-quote) to generate a quote, and in the case Coinbase Onramp is the best option, create an Onramp link to a [One-Click-Buy](/onramp/docs/api-aggregating/#one-click-buy-urls) experience with all inputs set to the parameters of the quote. 

<br />

**See Also:**

- [Generating a URL with the SDK](./sdk-generating-url.mdx)
- [Overview of Onramp APIs](./api-overview.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-initializing.mdx -->

---
title: "Initializing Onramp URL"
sidebar_label: "Initializing Onramp URL"
slug: "api-onramp-initializing"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Generating the Onramp URL 

{/* For reference: api-initializing#generating-the-url */}

If your application does not have a backend, or you do not wish to integrate with Onramp APIs, you can create an Onramp URL directly with your [project ID](./getting-started.mdx#step-3-get-your-project-id). 

:::tip Create Onramp URL with App ID
To create URLs without a session token, disable **Require secure initialization** on the [Onramp page](https://portal.cdp.coinbase.com/products/onramp) in CDP. 
:::

<figcaption></figcaption><img src={require('../assets/images/onramp-sec-init.png').default} width="700" alt="Confirm your payment method." />

### Parameters for generating Onramp URLs

The following table outlines parameters to generate the Onramp URL


| Parameter             | Req'd | Type             | Description       |
|:----------------------|:------|:-----------------|:------------------|
| appId                 | Yes   | String           | The Project ID found on the project Dashboard |
| defaultNetwork        | No    | String           | Default network that should be selected when multiple networks are present |
| defaultAsset          | No    | String           | Default asset that should be selected when multiple assets are present |
| presetCryptoAmount    | No    | Number           | Preset crypto amount value  |
| presetFiatAmount      | No    | Number           | Preset fiat amount value (for USD, CAD, GBP, EUR only). Ignored if `presetCryptoAmount` is also set. |
| defaultExperience     | No    | 'send', 'buy'    | Default visual experience: either (1) Transfer funds from Coinbase ('send') or (2) Buy assets ('buy') |
| defaultPaymentMethod  | No    | String           | Default payment method used to purchase the asset
| fiatCurrency          | No    | String           | e.g: USD, CAD, GBP, etc.
| handlingRequestedUrls | No    | Boolean          | Prevents the widget from opening URLs directly & relies on `onRequestedUrl` entirely for opening links |
| partnerUserId         | No    | String           | Unique ID representing the end-user. Must be less than 50 chars. Use with the Transaction Status API to retrieve transactions made during the session. |
| sessionToken          | Yes   | String           | Token generated by the [Onramp Session Token API](#getting-an-session-token). Only required if [Require secure initialization](#getting-a-session-token) is true. You can skip `appId` and `addresses` parameter if this is set. |
| redirectUrl           | No    | String           | URL to redirect the user to when they successfully complete a transaction. |


<Tabs>

<TabItem value="example-url-session-token" label="Example URL without Session Token ">
```bash
https://pay.coinbase.com/buy/select-asset?appId=appId&partnerUserId=partnerUserId&addresses={"0xEPjx..3531e":["base"]}&assets=["USDC","BTC"]&<other params>
```
</TabItem>
<TabItem value="example-url" label="Example URL with Session Token">

```bash
https://pay.coinbase.com/buy/select-asset?sessionToken=token&<other params>
```
</TabItem>
</Tabs>

## Getting a Session Token

{/* For reference: api-initializing#getting-a-session-token */}

Session tokens are optional. Developers can create and use a session token to securely authenticate users and manage sessions.

Create a [CDP Secret API Key](./getting-started.mdx#create-a-cdp-api-key)  and follow these instructions on [CDP API key authentication](/coinbase-app/docs/api-key-authentication) to make signed requests.

First call the Session Token API to obtain a token, then pass that token as the `sessionToken` query string parameter when generating the Coinbase Onramp or Offramp URL. 

:::caution
The token expires after a short period of time and can only be used once. A new token must be obtained for every new session. 
:::

### Method

```
POST
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/token
```

### Request Parameters

The Session Token API is an RPC endpoint that accepts parameters as JSON in the request body.

| Name                  | Type                | Req | Description |
|:----------------------|:--------------------|:----|:------------|
| `addresses` | [Address[]](#address-parameters) | Y   | List of addresses that the purchased crypto should be sent to. Each entry in this array is an object containing an address and a list of blockchains the address supports. |
| `assets`    | String[]                         | N   | List of assets that will be available for the user to buy/send. Assets can either be symbols e.g. "ETH" or "BTC", or UUIDs retrieved from the [Buy Options API](./api-configurations.mdx#buy-options). This optional parameter acts as a filter on the addresses parameter. If it is included then only the assets in this list that are available on one of the supported blockchains in the Addresses list will be available to the user. See the See the [Buy Options API](./api-configurations.mdx#buy-options) for the full list of assets. |

#### Address Parameters

An Address object accepts the following parameters:

| Parameter         | Req'd | Type     | Description        |
| :---------------- | :---- | :------- | :----------------- |
| address           | Yes   | String   | Destination address where the purchased tokens will be sent. |
| blockchains       | No    | String[] | List of blockchains enabled for the associated address. All tokens available per blockchain are displayed to the user. Available blockchains include: "ethereum", "bitcoin", "base", "avacchain", "optimism", "solana", "polygon", "arbitrum", "stellar" and many more. See the [Buy Options API](./api-configurations.mdx#buy-options) for the full list. |

### Response Fields

The Session Token API returns a JSON response including the following fields.

| Name       | Description |
|:-----------|:------------|
| token      | A unique string that can be passed into the Pay SDK as the `sessionToken` [parameter](./sdk-generating-url.mdx#generateonrampurl-parameters) when manually generating a URL to initialize the onramp widget (the resulting URL will look like `https://pay.coinbase.com/buy/select-asset?sessionToken=<token>&<other params>`). This token is associated with the parameters and App ID header provided in the request. This token can only be used once. |
| channel_id | Not yet functional. Upcoming implementation: A socket.io channel ID that can be used to receive events from the Pay SDK while the customer goes through the transaction flow. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/token' \
  -k /tmp/cdp_api_key.json \
  -d '{"addresses": [{"address": "bc1qrdvlkt8rqsyj229thqzhm0q39edwdj2k7yps6x", "blockchains": ["bitcoin"]}]}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "token": "ZWJlNDgwYmItNjBkMi00ZmFiLWIxYTQtMTM3MGI2YjJiNjFh",
    "channel_id": "",
  }
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-configurations.mdx -->

---
title: "Onramp Configurations"
sidebar_label: "Configurations"
slug: "api-configurations"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Onramp Config

The Onramp Config API returns the list of countries supported by Coinbase Onramp, and the payment methods available in each country. 
Clients can call this API periodically and cache the response so that they know which users to serve Onramp.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/buy/config
```

### Request Parameters

The Onramp Config API has no request parameters.

### Response Fields

The Onramp Config API returns a JSON response including the following fields.

| Name        | Description   |
|:------------|:--------------|
| `countries` | A list of supported countries, represented by their [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two digit country code. Each country contains a list of payment method types available in that country; for the US it also contains a list of supported states. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/buy/config'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "countries": [
      {
        "id": "US",
        "subdivisions": ["CA","NY","WA"],
        "payment_methods": [
          {
            "id": "CARD",
          },
          {
            "id": "ACH_BANK_ACCOUNT",
          },
        ],
      },
      {
        "id": "CA",
        "subdivisions": []
        "payment_methods": [
          {
            "id": "CARD",
          },
        ],
      },
    ],
  }
}
```

</TabItem>
</Tabs>


## Onramp Options

The Onramp Options API provides clients with a way to discover the available options for buying Crypto with Coinbase Onramp. 
It returns the supported fiat currencies and available crypto assets that can be passed into the Onramp Quote API.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/buy/options
```

### Request Parameters

| Name          | Req | Description |
|:--------------|:----|:------------|
| `country`     | Y   | [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two-digit country code string representing the purchasing user’s country of residence, e.g., `US`. |
| `subdivision` | N   | [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) two-digit country subdivision code representing the purchasing user’s subdivision of residence within their country, e.g. `NY`. Required if the `country=“US”` because certain states (e.g., `NY`) have state specific asset restrictions. |

### Response Fields

The Onramp Options API returns a JSON response including the following fields.

| Name                  | Description |
|:----------------------|:------------|
| `payment_currencies`  | List of supported fiat currencies that can be exchanged for crypto on Onramp in the given location. Each currency contains a list of available payment methods, with min and max transaction limits for that currency. |
| `purchase_currencies` | List of available crypto assets that can be bought on Onramp in the given location. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/buy/options?country=US&subdivision=NY'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "payment_currencies": [
      {
        "id": "USD",
        "payment_method_limits": [
          {
            "id": "card",
            "min": "10.00",
            "max": "7500.00",
          },
          {
            "id": "ach_bank_account",
            "min": "10.00",
            "max": "25000.00",
          },
        ],
      },
    ],
    "purchase_currencies": [
      {
        "id": "2b92315d-eab7-5bef-84fa-089a131333f5",
        "name": "USD Coin",
        "symbol": "USDC",
        "networks": [
          {
            "name": "ethereum-mainnet",
            "display_name": "Ethereum",
            "chain_id": "1",
            "contract_address": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            "name": "polygon-mainnet",
            "display_name": "Polygon",
            "chain_id": "137",
            "contract_address": "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ]
      }
    ],
  }
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-offramp-overview.mdx -->

---
title: "Overview of Offramp API"
sidebar_label: "Offramp Overview"
slug: "api-offramp-overview"
---

## Offramp API Endpoints

The Offramp API has the following endpoints:

| Method                                                          | Description |
|:----------------------------------------------------------------|:------------|
| [Session Token](./api-offramp-initializing#generating-the-offramp-url.mdx) | Optional: Provides a secure way for the client to initialize the Onramp and Offramp widget.|
| [Offramp Config](./api-offramp-configurations.mdx#offramp-config) | Returns list of countries supported by Coinbase Offramp, and the payment methods available in each country. |
| [Offramp Options](./api-offramp-configurations.mdx#offramp-options) | Returns supported fiat currencies and available crypto assets that can be passed into the Offramp Quote API. |
| [Offramp Quote](./api-offramp-generating-quotes.mdx#offramp-quote) | Provides a quote based on the asset the user would like to sell, plus the network, the crypto amount, the cashout currency, payment method, and country.|
| [Transaction Status](./api-offramp-reporting.mdx#offramp-transaction-status)    | Real time transaction status updates.|
| [Transactions](./api-offramp-reporting.mdx#offramp-transactions)                | Historical transaction status.|


## Rate Limiting

The **Buy Quote API and Sell Quote API** are rate limited to prevent abuse that would degrade our ability to maintain consistent API performance for all users. 
Throttling is enforced per endpoint by app ID at **VAR::BUY_QUOTE_API_REQS_PER_SEC requests per second**. 

If your requests are being rate limited, HTTP response code 429 is returned with a `rate_limit_exceeded` error. 
Rate limiting is implemented using a sliding window algorithm.


<!-- File: /Users/tinahe/docs/projects/onramp/docs/intro-welcome.mdx -->

---
title: "Welcome to Onramp & Offramp"
sidebar_label: "Welcome"
slug: "welcome"
---

Coinbase's Onramp & Offramp APIs and SDKs enable developers to move money seamlessley between fiat and onchain economies.

**[Onramp API / SDK](./api-overview.mdx)**: Users can fund their onchain apps from their fiat accounts and crypto balances on Coinbase.

  - **Guest Checkout**: Enables US users without a Coinbase account to quickly bring funds onchain with debit cards.

**[Offramp API / SDK](./api-offramp-overview.mdx)**: Users can cash out money onchain into fiat currencies (eg. USD).

## User journey

{/* > Example user experience for onramping funds:

<div vertically-align="bottom" >
<img src={require('../assets/images/onramp-01-signin.png').default} width="250"  alt="Start the process of using the assets and payment methods in your Coinbase account on apps and any self-custody wallet." />
<img src={require('../assets/images/onramp-02-input.png').default} width="250"  alt="Preview an order from the debit card stored in your Coinbase account to your self-hosted wallet." />
<img src={require('../assets/images/onramp-03-order-preview.png').default} width="250"  alt="" />
</div> */}

### Coinbase Onramp Launches​

The flow starts when Coinbase Onramp launches within your app, for example:

<img src={require('../assets/images/onramp-app.png').default} width="700" alt="Coinbase Onramp launching in a app frontend." />

### User Authenticates​

Once Coinbase Onramp launches, the user:

1. Enters their Coinbase credentials.
1. Goes through the 2FA process.
1. Authorizes app to take actions on their behalf.

<figcaption><i>Enter Credentials</i></figcaption> <img src={require('../assets/images/onramp-sign-to-coinbase.png').default} width="700" alt="Begin authentication by entering your credentials (email and password)."  />  

### User Adds Funds​

After being authenticated, the user:

1. Selects the asset to add to the wallet (if not automatically assigned in a previous step).
1. Enters an amount and chooses a payment method.
1. Confirms the payment method in the "Source of funds" window.

<figcaption><i>Fund Wallet</i></figcaption><img src={require('../assets/images/onramp-add-funds.png').default} width="700" alt="" />

:::info
All supported payment methods from fiat on-ramps to crypto balance are in the 'Pay with' section.
:::

### User Confirms the Transaction​

Finally, when the transaction is configured, the user:

1. Reviews the details of the transaction.
1. Is informed that Coinbase is purchasing the funds (for Buy orders).
1. Goes through 2FA to authorize the send to the wallet address.
1. Views a confirmation of the transaction.
1. Views a detailed breakdown of the transaction.

> 

<figcaption><i>Make Transaction</i></figcaption> <img src={require('../assets/images/onramp-make-transaction.png').default} width="700" alt="Review your transaction."  />  


<br />

**See Also:**

- [Getting Started with Onramp](./getting-started.mdx)
- [Onramp Use Cases](./intro-use-cases.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/rest-api-overview.mdx -->

---
title: "Onramp REST API Overview"
sidebar_label: "Overview"
slug: "rest-api-overview"
---

## Versioning

All API calls should be made with a `CBPAY-VERSION` header which guarantees that your call is using the correct API version. Version is passed in as a date (UTC) of the implementation in `YYYY-MM-DD` format. New versions maintain backwards compatibility. The current version is `2023-10-01`.

## Authentication

Authenticated API requests should be made with headers, `CBPAY-APP-ID` and `CBPAY-API-KEY`. If authentication fails, a JSON object with an error message is returned with HTTP status 401.

Your app ID and API key are provided at onboarding.

:::info
If you integrated before API keys were issued during onboarding and want to use this API, contact us and we can provide you with your API key.
:::

## Rate Limiting

The Buy Quote API is rate limited to prevent abuse that would degrade our ability to maintain consistent API performance for all users. Throttling is enforced per endpoint by app ID at 100 requests per second. If your requests are being rate limited, HTTP response code 429 is returned with a `rate_limit_exceeded` error. Rate limiting is implemented using a sliding window algorithm.

:::info
Contact us to request a rate limit increase.
:::

## Supported Methods

The Pay API has the following endpoints:

### Buy APIs

| Method                                                          | Description   |
| :-------------------------------------------------------------- | :------------ |
| [Buy Config](./api-configurations.mdx#buy-config)                     | Returns list of countries supported by Coinbase Pay, and the payment methods available in each country. |
| [Buy Options](./api-configurations.mdx#buy-options)                   | Returns supported fiat currencies and available crypto assets that can be passed into the Buy Quote API. |
| [Buy Quote](./api-generating-quotes.mdx#buy-quote)                       | Provides clients with a quote based on the asset the user would like to purchase, plus the network, the dollar payment, the payment currency, payment method, and country. |
| [Onramp Session Token](./api-initializing.mdx#getting-an-onramp-session-token) | Provides a secure way for the client to initialize the Pay SDK. |
| [Transaction Status](./api-reporting.mdx#transaction-status)     | Provides clients with real time status of a Pay transaction. |
| [Transactions](./api-reporting.mdx#transactions)                 | Provides clients with their transactions for analytics purposes. |



<!-- File: /Users/tinahe/docs/projects/onramp/docs/changelog.mdx -->

---
title: "Onramp Changelog"
sidebar_label: "Changelog"
slug: "changelog"
---

These release notes list changes to Coinbase Onramp.

### 2024-JUN-19

- Removed references to the `destinationWallets` parameter
- Added documentation for the `addresses` and `assets` parameters
- Removed references to embedding the Onramp widget
- Updated sample code

### 2024-MAY-09

Coinbase Pay docs are rebranded as Coinbase Onramp.

### 2024-APR-12

- Added [Transactions](./api-reporting.mdx#transactions) endpoint

### 2024-JAN-25

- Renamed `onrampToken` to `sessionToken` in [Generating a URL with the SDK](./sdk-generating-url.mdx)

### 2024-JAN-11

- Added [Onramp Session Token](./api-initializing.mdx#getting-an-onramp-session-token) endpoint

### 2023-NOV-06

- Added [Transaction Status](./api-reporting.mdx#transaction-status) endpoint
- Added new optional parameter, `partnerUserId`

### 2023-OCT-17

- Added Rest API endpoints
  - [Buy Config](./api-configurations.mdx#buy-config)
  - [Buy Options](./api-configurations.mdx#buy-options)
  - [Buy Quote](./api-generating-quotes.mdx#buy-quote)
- Added [OnRamp Aggregator parameters](./sdk-integrating-aggregator.mdx)

### 2023-AUG-09

- Added [Base Layer 2](./sdk-layer2.mdx#available-assets) solution for ETH.

### 2022-MAY-10

Updated [initOnRamp](sdk-integrating-onramp.mdx#initonramp-parameters):

- Added new optional parameter, `onRequestedUrl`
- Added new required object, [WidgetParameters](./sdk-integrating-onramp.mdx#widgetparameters-parameters)
  - Added new parameter `handlingRequestedUrls` to WidgetParameters
  - Moved some existing parameters to WidgetParameters: `presetCryptoAmount`, `presetFiatAmount`, `defaultNetwork`, `defaultExperience`

### 2022-AUG-01

- Added support for [Layer 2](./sdk-layer2.mdx) networks

### 2022-MAY-12

- Public release of Coinbase Pay SDK



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-generating-quotes.mdx -->

---
title: "Generating Quotes"
sidebar_label: "Generating Quotes"
slug: "api-generating-quotes"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Onramp Quote

The Onramp Quote API provides clients with a quote based on the asset the user would like to purchase, the network they plan to purchase it on, the dollar amount of the payment, the payment currency, the payment method, and country of the user.

:::info Limitations
The quote provided by this API is an estimate only. It does not guarantee that the user will be able to complete their purchase using the returned quote. Depending on fluctuations in network fees and exchange rates, and whether or not the user chooses the logged in or guest checkout experience, the actual fees charged may be different.
:::

### Method

```
POST
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/buy/quote
```

### Request Parameters

The Onramp Quote API is an RPC endpoint that accepts parameters as JSON in the request body.

| Name                | Type   | Req | Description |
|:--------------------|:-------|:----|:------------|
| `purchase_currency` |        | Y   | ID of the crypto asset the user wants to purchase. Retrieved from the options API. |
| `purchase_network`  |        | N   | Name of the network that the purchase currency should be purchased on. Retrieved from the options API. If omitted, the default network for the crypto currency is used. |
| `payment_amount`    | String | Y   | Fiat amount the user wants to spend to purchase the crypto currency, inclusive of fees with two decimals of precision, e.g., `100.00`. |
| `payment_currency`  | String | Y   | Fiat currency of the payment amount, e.g., `USD`. |
| `payment_method`    |        | Y   | ID of payment method used to complete the purchase. Retrieved from the options API. |
| `country`           |        | Y   | [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two-digit country code string representing the purchasing user’s country of residence, e.g., `US`. |
| `subdivision`       |        | N   | [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) two-digit country subdivision code representing the purchasing user’s subdivision of residence within their country, e.g. `NY`. Required if the `country=“US”` because certain states (e.g., `NY`) have state specific asset restrictions. |

### Response Fields

The Onramp Quote API returns a JSON response including the following fields.

| Name               | Description |
|:-------------------|:------------|
| `payment_total`    | Object with amount and currency of the total fiat payment required to complete the purchase, inclusive of any fees. The currency will match the `payment_currency` in the request if it is supported, otherwise it falls back to `USD`.  |
| `payment_subtotal` | Object with amount and currency of the fiat cost of the crypto asset to be purchased, exclusive of any fees. The currency will match the `payment_currency`. |
| `purchase_amount`  | Object with amount and currency of the crypto that to be purchased. The currency will match the `purchase_currency` in the request. The number of decimals will be based on the crypto asset. |
| `coinbase_fee`     | Object with amount and currency of the fee changed by the Coinbase exchange to complete the transaction. The currency will match the `payment_currency`. |
| `network_fee`      | Object with amount and currency of the network fee required to send the purchased crypto to the user’s wallet. The currency will match the `payment_currency`. |
| `quote_id`         | Reference to the quote that should be passed into the initialization parameters when launching the Coinbase Onramp widget via the SDK or URL generator. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/buy/quote' \
  -k /tmp/cdp_api_key.json \
  -d '{"purchase_currency": "BTC", "payment_amount": "100.00", "payment_currency": "USD", "payment_method": "CARD", "country": "US", "subdivision": "NY"}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "payment_total": {
      "amount": "100.00",
      "currency": "USD"
    },
    "payment_subtotal": {
      "amount": "97.00",
      "currency": "USD"
    },
    "purchase_amount": {
      "amount": "10.00000000",
      "currency": "BTC"
    },
    "coinbase_fee": {
      "amount": "1.50",
      "currency": "USD"
    },
    "network_fee": {
      "amount": "1.50",
      "currency": "USD"
    },
    "quote_id": "46da84dc-b6d7-11ed-afa1-0242ac120002"
  }
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/sdk-layer2.mdx -->

---
title: "Onramp Layer 2 Networks"
sidebar_label: "Layer 2 Networks"
slug: "layer2"
---

A Layer 2 (L2) is a blockchain that extends the Ethereum blockchain and inherits the security guarantees of Ethereum. 
See [What is layer 2](https://ethereum.org/en/layer-2/) in the Ethereum documentation. 

To date, <a href="https://www.coinbase.com" target="_blank" rel="noreferrer">coinbase.com</a> has sent assets on each asset's default network; for example, AVAX is sent on Avalanche C Chain, ETH is sent on Ethereum. 
With L2s, the user can control the network on which to send an asset, and may benefit from cheaper gas fees on some networks.


## Available Assets 

The following assets are available for L2 Sends:

| Asset | Networks                                                            |
|:------|:--------------------------------------------------------------------|
| DAI   | Ethereum / Avalanche C-Chain / Optimism / Arbitrum                  |
| ETH   | Ethereum / Base / Polygon / Avalanche C-Chain / Optimism / Arbitrum |
| MATIC | Ethereum / Polygon                                                  |
| USDC  | Ethereum / Base / Polygon / Solana / Optimism / Avalanche C-Chain   |
| wBTC  | Ethereum / Avalanche C-Chain / Optimism / Arbitrum                  |


## Sample Implementations

This section includes multiple examples of L2 assets that are currently available for testing.

### (1) One asset, one network 

##### Sample implementation #1: Enable an asset on a single network

This implementation lets your users buy and send `ETH` on Ethereum network only (even though Coinbase Onramp supports additional networks for `ETH`).  

```js
// Enable an asset on a single network only
addresses: { 
  “0x1”: ["ethereum"]
},
assets: [“ETH”],

```

### (2) One asset, many networks

##### Sample implementation #2: Enable an asset on multiple networks

This implementation lets your users buy and send `USDC` on multiple supported networks -- Ethereum, Polygon and Solana. 
To enable `USDC` on the Solana network, you must pass in a Solana formatted destination address.

```js
addresses: {
  "0x1": [“ethereum”, “polygon”],
  "1a2": ["solana"],
},
assets: ["USDC"],
```

### (3) One asset, many networks (with default)

##### Sample implementation #3: Enable an asset on multiple networks, with default network

This implementation is like #2 except that Coinbase Onramp selects Solana as the default destination address. 
Users have the option to update the destination network to Ethereum or Polygon. 

```js
addresses: {
  "0x1": [“ethereum”, “polygon”],
  "1a2": ["solana"],
},
assets: ["USDC"],
defaultNetwork: “solana”,
```

### (4) Many assets, one network

##### Sample implementation #4: Enable multiple assets on a single network

This implementation let users send funds on the Ethereum network only.
You can select all `ETH` and `ERC20` tokens that Coinbase Onramp supports for Ethereum. 

```js
addresses: { 
  "0x1": [“ethereum”]
},
assets: [“ETH”,“USDC”,“MATIC”],
```

### (5) Many assets, many networks

##### Sample implementation #5: Enable multiple assets on multiple networks

Each asset in the assets parameter will be available on any network included in the addresses parameter that supports that asset.

```js
addresses: {
  "0x1": [“ethereum”, “polygon”],
  "1a2": ["solana"],
},
assets: ["USDC","SOL","AVAX","ETH","MATIC"],
```

### (6) All assets, one network

##### Sample implementation #6: Enable all assets on a single network

This implementation lets you offer all supported assets on Ethereum to your users. 
Because Coinbase is constantly adding support for more assets (including `ERC20` tokens), this implementation lets you make newly supported assets immediately available to your users.

```js
addresses: {
  "0x1": [“ethereum”],
},
```

### (7) All assets, many networks

##### Sample implementation #7: Enable all assets on multiple networks

```js
addresses: {
  "0x1": [“ethereum”,"polygon","avacchain"],
},
```

<br />

**See Also:**  

- [Integrating Coinbase Onramp](./sdk-integrating-onramp.mdx)
- [Generating a URL with the SDK](./sdk-generating-url.mdx)




<!-- File: /Users/tinahe/docs/projects/onramp/docs/getting-started.mdx -->

---
title: "Getting Started with Onramp"
sidebar_label: "Getting Started"
slug: "getting-started"
---

Welcome to Coinbase Onramp. Get up and running in less than 5 minutes.

## Sign up and complete your profile

### Step 1: [Sign up for a CDP account](https://www.coinbase.com/developer-platform)

If you already have a Coinbase account, you can just **Sign in**! 

### Step 2: Verify your email

Enter your email address and verify with a code sent to you immediately after signup. Set up 2-factor authentication (2FA) with your phone number.

## Welcome to your CDP Dashboard!
### Step 3: Get your Project ID

A default project name displays (you can rename this!). Copy your **Project ID** to use later (this is referred to as `appId`).
{/* 
    - Disable "Require secure initialization" for [non-secure sessions] (quickstart#non-secure-sessions).
    - Enable "Require secure initialization" for [secure sessions (quickstart#secure-sessions). */}

## Generate an API Key

### Step 4: Create a Secret API Key

Navigate to the **API Keys** tab. Create and download your API key. Enter an API key nickname (restrictions are optional). 

Secure your private/public key pair in a safe location.

## Install CDP CLI tools

Install [`cdpcurl`](https://github.com/coinbase/cdpcurl) to make test API calls. `cdpcurl` allows you to make authenticated HTTP requests to the Coinbase API with your API key. 

## Integrate Coinbase Onramp and Offramp into your product!

Coinbase's fiat-to-crypto (Onramp) and crypto-to-fiat (Offramp) APIs and SDKs offer a lightweight way for Apps to generate URLs to Coinbase's hosted widgets.

Developers can use either our APIs or SDK. We recommend the API pathway for most developers!

:::tip
Front end developers love using the [`<FundButton />`](https://onchainkit.xyz/fund/fund-button), a customizable React component in OnchainKit which enables users to fund their wallets without leaving their App!
:::

<br />

**See Also:** 

- [Quickstart](./quickstart.mdx)
- [Overview of Onramp APIs](./api-overview.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/rest-api-reference.mdx -->

---
title: "Onramp REST API Reference"
sidebar_label: "API Reference"
slug: "rest-api-reference"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This document describes Coinbase Pay APIs.









<!-- File: /Users/tinahe/docs/projects/onramp/docs/sdk-integrating-onramp.mdx -->

---
title: "Integrating Onramp with the SDK"
sidebar_label: "Integrating Onramp"
slug: "integrating-onramp"
---

This page explains how to trigger the Coinbase Onramp experience using the Onramp SDK. 
When the user presses the Coinbase Onramp button, the Coinbase Onramp widget launches and is configured with the parameters passed.

## A. Create a Coinbase Onramp button
 
Download the <a href="/downloads/onramp/coinbase-onramp-assets.zip" download target="blank">Coinbase Onramp button assets</a> and add these buttons to your app. Here is a web integration example: 

```html
<a id="cbonramp-button-container">
 <img src="./buy-with-coinbase.png" />
</a>
```

Some things to be mindful of:

- The selector must be unique on the DOM, but the name is not important. 
- The element must be accessible using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector" target="_blank" rel="noreferrer">querySelector API</a>.
- The image source should reference one of the Coinbase approved buttons defined in button assets download.


## B. Call the initOnRamp method

When the HTML container is ready and has been mounted to the DOM, call `initOnRamp` from the SDK to attach click listeners to the button.

:::info
Refer to the [initOnRamp parameters](#initonramp-parameters).
:::

### initOnRamp Example

This is an example of how to implement in React with ready state listeners:

```ts
import { CBPayInstanceType, initOnRamp } from "@coinbase/cbpay-js";
import { useEffect, useState } from "react";

export const PayWithCoinbaseButton: React.FC = () => {
  const [onrampInstance, setOnrampInstance] = useState<CBPayInstanceType | null>();

  useEffect(() => {
    initOnRamp({
      appId: '<Your Project ID obtained from Coinbase Developer Platform>',
      widgetParameters: {
        // Specify the addresses and which networks they support
        addresses: { '0x1': ['ethereum','base'], 'bc1': ['bitcoin']},
        // (Optional) Filter the available assets on the above networks to just these ones
        assets: ['ETH','USDC','BTC'],
      },
      onSuccess: () => {
        console.log('success');
      },
      onExit: () => {
        console.log('exit');
      },
      onEvent: (event) => {
        console.log('event', event);
      },
      experienceLoggedIn: 'popup',
      experienceLoggedOut: 'popup',
      closeOnExit: true,
      closeOnSuccess: true,
    }, (_, instance) => {
      setOnrampInstance(instance);
    });

    // When button unmounts destroy the instance
    return () => {
      onrampInstance?.destroy();
    };
  }, []);

  const handleClick = () => {
    onrampInstance?.open();
  };

  return <button onClick={handleClick} disabled={!onrampInstance}>Buy with Coinbase</button>;
};
```

### initOnRamp Parameters

The following table outlines the parameters supported in the `initOnRamp` function:

| Parameter           | Req'd | Type             | Description       |
|:--------------------|:------|:-----------------|:------------------|
| widgetParameters    | Yes   | [WidgetParameters](#widgetparameters-parameters) | A `WidgetParameters` object |
| appId               | Yes   | String   | Unique short-string ID provided to partners by the Coinbase Pay team |
| onSuccess           | No    | Function | Callback that is triggered when the OnRamp purchase/send flow has finished                                                        |
| onExit              | No    | Function | Callback when the OnRamp experience exits |
| onEvent             | No    | Function | Callback that emits events from the experience |
| onRequestedUrl      | No    | Function | Single URL (String) that must be set outside of an iframe. In mobile webview, partners should display a close button for the URL. |
| closeOnExit         | No    | Boolean  | Automatically close the Coinbase Pay window when user exits the flow  |
| closeOnSuccess      | No    | Boolean  | Automatically close the Coinbase Pay window on successful purchase |
| experienceLoggedIn  | No    | Enum     | Open Coinbase Pay in a new tab or open in popup window for logged in users  (`popup`,`new_tab`)  |
| experienceLoggedOut | No    | Enum     | Open Coinbase Pay in a new tab or open in popup window for logged out users (defaults to logged in option) |
| redirectUrl         | No    | String   | URL to redirect the user to when they successfully complete a transaction. |

:::info
When using the `redirectUrl` parememeter, please make sure to include the domain in the configuration named "Domain allowlist" within the Onramp configurations in the Coinbase Developer Platform console.  
:::


### WidgetParameters Parameters

A WidgetParameters object accepts the following parameters:

| Parameter             | Req'd | Type             | Description       |
|:----------------------|:------|:-----------------|:------------------|
| addresses             | No    | Record\<String, String[]\> | A map of addresses to their lists of supported blockchains e.g. `{ "0x1": ["ethereum"] }` |
| assets                | No    | String[]                 | A list of assets symbols (e.g. "ETH", "BTC"). If this parameter is included <b>only</b> the assets included in it will be availble to the user.
| presetCryptoAmount    | No    | Number                   | Preset crypto amount value.  |
| presetFiatAmount      | No    | Number                   | Preset fiat amount value (for USD, CAD, GBP, EUR only). Ignored if `presetCryptoAmount` is also set. |
| defaultNetwork        | No    | String                   | Default network that should be selected when multiple networks are present |
| defaultExperience     | No    | 'send', 'buy'            | Default visual experience: either (1) Transfer funds from Coinbase ('send') or (2) Buy assets ('buy') |
| handlingRequestedUrls | No    | Boolean                  | Prevents the widget from opening URLs directly & relies on `onRequestedUrl` entirely for opening links |
| partnerUserId         | No    | String                   | Unique ID representing the client app user. Must be less than 50 chars. Use with the Transaction Status API to retrieve transactions made during the session. |

:::info
All transactions made during the session are linked to `partnerUserId` which can be used with the Transaction Status API to retrieve these transactions later. 
:::

## C. Test and Verify

After the Coinbase Pay SDK has been configured and inserted into the application, submit test transactions, and then validate that the funds have been delivered to the destination wallet.

If the SDK call to initOnRamp is misconfigured, then either (1) Coinbase Pay does not render or (2) the Coinbase Pay experience redirects to the Coinbase landing page. 

<br />

**See Also:** 

- [Generating a URL with the SDK](./sdk-generating-url.mdx)
- [Onramp FAQ](./guidance-faq.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/quickstart.mdx -->

---
title: "Onramp Quickstart"
sidebar_label: "Quickstart"
slug: "quickstart"
---

## Setup

A Coinbase Onramp session starts with a link. Follow along to get up and running creating URLs for several different types of integrations. 
This quickstart guide assumes that you have completed the [Getting Started](/onramp/docs/getting-started) guide and: 

- Created a Coinbase Developer Platform ([CDP](https://coinbase.com/developer-platform)) account
- Copied the Project ID and opened the Onramp tab at least once to initialize the product settings
- Created a [secret API key](/get-started/docs/cdp-keys/#creating-api-keys) (required for secure sessions).

## Passing the destination wallet addresses
An Onramp link contains all context about an Onramp session, and most importantly, a list of destination wallet addresses to send the funds to. The destination wallet addresses can be passed one of two ways:
- **Query parameter**: the fastest way to get up and running.
- **Session Token API (more secure)**: call an API for a secure session token&mdash;reduces phishing risk but requires backend integration.

## Creating a link

### Passing everything with query parameters

1. Gather the following info to create a URL:
    - Project ID (from the CDP portal)
    - Destination wallet address (e.g. 0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C, for an ETH wallet)
    - Blockchain (e.g., "ethereum" if you are using an ETH wallet).
2. In CDP > Onramp, disable "Require secure initialization" (if not already disabled).
3. Create an https URL as follows:

    ```bash
    https://pay.coinbase.com/buy/select-asset?appId=<PROJECT-ID>&addresses={"<ADDRESS>":["<BLOCKCHAIN>"]}]
    ```

    For example: 

    ```bash
    https://pay.coinbase.com/buy/select-asset?appId=58a3fa2e-617f-4198-81e7-096f5e498c00&addresses={"0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C":["ethereum"]}
    ```

    :::tip
    If you did not select Onramp when [setting up the project](/get-started/docs/cdp-projects/), you may see the following error:<br /> 
    `404: Uncaught error in fetch stack: ApiError: Something went wrong, please try again.`
    :::

### Initializing with the Session Token API

To initialize via the Session Token API:
1. Download a CDP secret API key to your machine.
2. Install [cdpcurl](https://github.com/coinbase/cdpcurl) by running:

    ```bash
    brew tap coinbase/cdpcurl
    brew install cdpcurl
    ```

2. Get your destination wallet addresses and list of blockchains to support. Substitute the values in the payload and call the Session Token API:

    ```
    cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/token' \
    -k /tmp/cdp_api_key.json \
    -d '{"addresses": [{"address":"0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C", "blockchains": ["ethereum"]}]}'
    ```
3. Create an https URL as follows:

    ```bash
    https://pay.coinbase.com/buy/select-asset?sessionToken=<SECURE_TOKEN>
    ```

    For example: 

    ```bash
    https://pay.coinbase.com/buy/select-asset?sessionToken=MWVmMTQ5M2YtZDRiZS02MWRjLWJhNmQtZTYzMTc4MjJhMjlk
    ```

:::tip
The Onramp API should only be called from a backend server. If your app doesn't have a backend, use the non-secure initialization method in the section above to create URLs directly in frontend code. 
:::
    
## Sample app
Experience everything Onramp has to offer by downloading and running a sample app:
1. Clone the [demo repo](https://github.com/coinbase/onramp-demo-app).
2. Make a secret API key and move it into the repo as `api_keys/cdp_api_key.json`.
3. Follow the instructions in the README to run the app.



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-offramp-initializing.mdx -->

---
title: "Initializing Coinbase Offramp"
sidebar_label: "Initializing Offramp URL"
slug: "api-offramp-initializing"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Generating the Offramp URL 

{/* For reference: api-initializing#generating-the-offramp-url */}

If your application does not have a backend, or you do not wish to integrate with Offramp APIs, you can create an Offramp URL directly with your [project ID](./getting-started.mdx#copy-project-id). 

:::tip Create Offramp URL with App ID
To create URLs without a session token, disable **Require secure initialization** on the [Onramp page](https://portal.cdp.coinbase.com/products/onramp) in CDP. 
:::

<figcaption></figcaption><img src={require('../assets/images/onramp-sec-init.png').default} width="700" alt="Confirm your payment method." />

### Parameters for generating Offramp URLs

The following table outlines parameters to generate the Offramp URL


| Parameter                     | Req'd | Type             | Description       |
|:------------------------------|:------|:-----------------|:------------------|
| appId                         | Yes   | String           | The Project ID found on the project Dashboard |
| partnerUserId                 | Yes   | String           | Unique ID representing the end-user. Must be less than 50 chars. Use with the [Offramp Transaction Status API](./api-offramp-reporting.mdx#offramp-transaction-status) to retrieve transactions made during the session. |
| defaultNetwork                | No    | String           | Default network that should be selected when multiple networks are present |
| defaultAsset                  | No    | String           | Default asset that should be selected when multiple assets are present |
| presetCryptoAmount            | No    | Number           | Preset crypto amount value  |
| presetFiatAmount              | No    | Number           | Preset fiat amount value (for USD, CAD, GBP, EUR only). Ignored if `presetCryptoAmount` is also set. |
| defaultCashoutMethod          | No    | String           | Default payment method to cashout fiat ("FIAT_WALLET", "ACH", "CARD", "CRYPTO_WALLET", "PAYPAL") |
| fiatCurrency                  | No    | String           | e.g: USD, CAD, GBP, etc.
| handlingRequestedUrls         | No    | Boolean          | Prevents the widget from opening URLs directly & relies on `onRequestedUrl` entirely for opening links |
| sessionToken                  | Yes   | String           | Token generated by the [Session Token API](#getting-a-session-token). Only required if [Require secure initialization](#getting-an-coinbase-onramp-buysell-session-token) is true. You can skip `appId` and `addresses` parameter if this is set. |
| redirectUrl                   | Yes   | String           | URL to redirect the user to send crypto to the destination when they commit the sell transaction. Use [Sell Transaction Status API](./api-reporting.mdx#sell-transaction-status) to fetch send transactions details. |


<Tabs>
<TabItem value="example-url-session-token" label="Example URL without Session Token ">

```bash
https://pay.coinbase.com/v3/sell/input?appId=appId&partnerUserId=partnerUserId&addresses={"0x1":["ethereum","base"]}&assets=["ETH","BTC"]&redirectUrl=youdomain.com&<other params>

```

</TabItem>
<TabItem value="example-url" label="Example URL with Session Token">

```bash
https://pay.coinbase.com/v3/sell/input?sessionToken=token&redirectUrl=your.domain.com&partnerUserId=partnerUserId&<other params>
```

</TabItem>
</Tabs>


:::info
All transactions made during the session are linked to `partnerUserId` which can be used with the Transaction Status API to retrieve these transactions later. 
:::


## Getting a Session Token

{/* For reference: api-offramp-initializing#getting-a-session-token */}

Session tokens are optional. Developers can create session token to securely authenticate users and manage sessions.

Create a [CDP API Key](./getting-started.mdx#create-a-cdp-api-key)  and follow these instructions on [CDP API key authentication](/coinbase-app/docs/api-key-authentication) to make signed requests.

First call the Onramp Session Token API to obtain a token, then pass that token as the `sessionToken` query string parameter when generating Sell URLsthe Coinbase Onramp buy/sell URL. 

:::caution
The token expires after a short period of time and can only be used once. A new token must be obtained for every new session. 
:::

### Method

```
POST
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/token
```

### Request Parameters

The Session Token API is an RPC endpoint that accepts parameters as JSON in the request body.

| Name                  | Type                | Req | Description |
|:----------------------|:--------------------|:----|:------------|
| `addresses` | [Address[]](#address-parameters) | Y   | List of addresses that the purchased crypto should be sent to. Each entry in this array is an object containing an address and a list of blockchains the address supports. |
| `assets`    | String[]                         | N   | List of assets that will be available for the user to buy/send. Assets can either be symbols e.g. "ETH" or "BTC", or UUIDs retrieved from the [Buy Options API](./api-configurations.mdx#buy-options). This optional parameter acts as a filter on the addresses parameter. If it is included then only the assets in this list that are available on one of the supported blockchains in the Addresses list will be available to the user. See the See the [Buy Options API](./api-configurations.mdx#buy-options) for the full list of assets. |

#### Address Parameters

An Address object accepts the following parameters:

| Parameter         | Req'd | Type     | Description        |
| :---------------- | :---- | :------- | :----------------- |
| address           | Yes   | String   | Destination address where the purchased tokens will be sent. |
| blockchains       | No    | String[] | List of blockchains enabled for the associated address. All tokens available per blockchain are displayed to the user. Available blockchains include: "ethereum", "bitcoin", "base", "avacchain", "optimism", "solana", "polygon", "arbitrum", "stellar" and many more. See the [Buy Options API](./api-configurations.mdx#buy-options) for the full list. |

### Response Fields

The Session Token API returns a JSON response including the following fields.

| Name       | Description |
|:-----------|:------------|
| token      | A unique string that can be passed into the Pay SDK as the `sessionToken` [parameter](./sdk-generating-url.mdx#generateonrampurl-parameters) when manually generating a URL to initialize the onramp widget (the resulting URL will look like `https://pay.coinbase.com/buy/select-asset?sessionToken=<token>&<other params>`). This token is associated with the parameters and App ID header provided in the request. This token can only be used once. |
| channel_id | Not yet functional. Upcoming implementation: A socket.io channel ID that can be used to receive events from the Pay SDK while the customer goes through the transaction flow. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/token' \
  -k /tmp/cdp_api_key.json \
  -d '{"addresses": [{"address": "bc1qrdvlkt8rqsyj229thqzhm0q39edwdj2k7yps6x", "blockchains": ["bitcoin"]}]}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "token": "ZWJlNDgwYmItNjBkMi00ZmFiLWIxYTQtMTM3MGI2YjJiNjFh",
    "channel_id": "",
  }
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/sdk-integrating-aggregator.mdx -->

---
title: "Integrating into an OnRamp Aggregator"
sidebar_label: "Integrating into an OnRamp Aggregator"
slug: "integrating-aggregator"
---

The OnRamp Aggregator API lets developers get a quote for the fees and an exchange rate for a buy. 
Then it initializes Coinbase Pay with the appropriate parameters to execute that buy.

| Parameter            | Reqd | Type   | Description      |
| :------------------- | :--- | :----- | :--------------- |
| quoteId              | Yes  | String | ID of the quote. _Received from [Buy Quote](./api-generating-quotes.mdx#buy-quote)._ |
| defaultAsset         | Yes  | String | UUID of asset. <br /><br />_Received from [Buy Options](./api-generating-quotes.mdx#buy-options) and sent to [Buy Quote](./rest-api-reference.mdx#buy-quote)._  |
| defaultNetwork       | No   | String | Default network that should be selected when multiple networks are present. When not set, default is the asset network. <br /><br />_Received from [Buy Options](./api-configurations.mdx#buy-options) and sent to [Buy Quote](./api-generating-quotes.mdx#buy-quote)._ |
| defaultPaymentMethod | Yes  | String | Default payment method, one of: <ul> <li>`CRYPTO_ACCOUNT`</li> <li>`FIAT_WALLET`</li> <li>`CARD`</li> <li>`ACH_BANK_ACCOUNT`</li> <li>`APPLE_PAY`</li></ul> <i>Received from [Buy Options](./rest-api-reference.mdx#buy-options) and sent to [Buy Quote](./rest-api-reference.mdx#buy-quote).</i> |
| fiatCurrency         | Yes  | String | Ticker symbol of the fiat currency. |
| presetFiatAmount     | Yes  | Number | Amount to be spent on the crypto purchase, fees included. |



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-overview.mdx -->

---
title: "Overview of Onramp API"
sidebar_label: "Onramp Overview"
slug: "api-overview"
---

## Onramp API Endpoints

The Onramp API has the following endpoints:

| Method                                                          | Description |
|:----------------------------------------------------------------|:------------|
| [Session Token](./api-initializing.mdx#getting-a-session-token) | Optional: Provides a secure way for the client to initialize the Onramp and Offramp widget. |
| [Onramp Config](./api-configurations.mdx#onramp-config)               | Returns list of countries supported by Coinbase Onramp, and the payment methods available in each country. |
| [Onramp Options](./api-configurations.mdx#onramp-options)             | Returns supported fiat currencies and available crypto assets that can be passed into the Buy Quote API. |
| [Onramp Quote](./api-generating-quotes.mdx#onramp-quote)              | Provides a quote based on the asset the user would like to purchase, plus the network, the fiat payment, the payment currency, payment method, and country. |
| [Transaction Status](./api-reporting.mdx#transaction-status)    | Real time transaction status updates. |
| [Transactions](./api-reporting.mdx#transactions)                | Historical transaction status. |


## Rate Limiting

The **Buy Quote API and Sell Quote API** are rate limited to prevent abuse that would degrade our ability to maintain consistent API performance for all users. 
Throttling is enforced per endpoint by app ID at **VAR::BUY_QUOTE_API_REQS_PER_SEC requests per second**. 

If your requests are being rate limited, HTTP response code 429 is returned with a `rate_limit_exceeded` error. 
Rate limiting is implemented using a sliding window algorithm.



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-offramp-generating-quotes.mdx -->

---
title: "Generating Offramp Quotes"
sidebar_label: "Generating Quotes"
slug: "api-offramp-generating-quotes"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Offramp Quote

The Offramp Quote API provides clients with a quote based on the asset the user would like to sell, the network of the asset is on, the crypto amount of the asset, the cashout fiat currency, the payment method, and country of the user.

:::info Limitations
The quote provided by this API is an estimate only. It does not guarantee that the user will be able to complete their purchase using the returned quote. Depending on fluctuations in exchange rates, the actual fees charged may be different.
:::

### Method

```
POST
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/sell/quote
```

### Request Parameters

The Offramp Quote API is an RPC endpoint that accepts parameters as JSON in the request body.

| Name                | Type   | Req | Description |
|:--------------------|:-------|:----|:------------|
| `sell_currency`     |        | Y   | ID of the crypto asset the user wants to offramp. Retrieved from the Offramp Options API. |
| `sell_network`      |        | N   | Name of the network that the sell currency is on. Retrieved from the Offramp Options API. If omitted, the default network for the crypto currency is used. |
| `sell_amount`       | String | Y   | Crypto amount the user wants to offramp, exclusive of network fees |
| `cashout_currency`  | String | Y   | Fiat currency of the cashout amount, e.g., `USD`. |
| `payment_method`    |        | Y   | ID of payment method used to cashout the sell. Retrieved from the options API. |
| `country`           |        | Y   | [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two-digit country code string representing the user’s country of residence, e.g., `US`. |
| `subdivision`       |        | N   | [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) two-digit country subdivision code representing the user’s subdivision of residence within their country, e.g. `NY`. Required if the `country=“US”` because certain states (e.g., `NY`) have state specific asset restrictions. |

### Response Fields

The Offramp Quote API returns a JSON response including the following fields.

| Name               | Description |
|:-------------------|:------------|
| `cashout_total`    | Object with amount and currency of the fiat amount of crypto asset to be received, fees deducted. The currency will match the `cashout_currency` in the request if it is supported, otherwise it falls back to `USD`.  |
| `cashout_subtotal` | Object with amount and currency of the total fiat cost of the crypto asset, fees not deducted. The currency will match the `cashout_currency`. |
| `sell_amount`      | Object with amount and currency of the crypto that to be sold. The currency will match the `sell_currency` in the request. The number of decimals will be based on the crypto asset. |
| `coinbase_fee`     | Object with amount and currency of the fee changed by the Coinbase exchange to complete the transaction. The currency will match the `cashout_currency`. |
| `quote_id`         | Reference to the quote that should be passed into the initialization parameters when launching the Coinbase Onramp widget via the SDK or URL generator. |

:::info Creating a One-Click-Buy URL with the Quote
To create an Onramp link with all inputs pre-filled that takes users straight to the final order preview screen, please go to our [Aggregating](https://docs.cdp.coinbase.com/onramp/docs/api-aggregating) section for information.
:::


### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/sell/quote' \
  -k /tmp/cdp_api_key.json \
  -d '{"sell_currency": "BTC", "sell_amount": "0.01", "cashout_currency": "USD", "payment_method": "FIAT_WALLET", "country": "US", "subdivision": "NY"}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "cashout_total": {
      "amount": "98.50",
      "currency": "USD"
    },
    "cashout_subtotal": {
      "amount": "100.00",
      "currency": "USD"
    },
    "sell_amount": {
      "amount": "0.00100000",
      "currency": "BTC"
    },
    "coinbase_fee": {
      "amount": "1.50",
      "currency": "USD"
    },
    "quote_id": "46da84dc-b6d7-11ed-afa1-0242ac120002"
  }
}
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-offramp-configurations.mdx -->

---
title: "Offramp Configurations"
sidebar_label: "Configurations"
slug: "api-offramp-configurations"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Offramp Config

The Offramp Config API returns the list of countries that support offramp transactions, and the payment methods available in each country. 
Clients can call this API periodically and cache the response so that they know which users to present the Coinbase Offramp sell transaction option to.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/sell/config
```

### Request Parameters

The Offramp Config API has no request parameters.

### Response Fields

The Offramp Config API returns a JSON response including the following fields.

| Name        | Description   |
|:------------|:--------------|
| `countries` | A list of supported countries, represented by their [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two digit country code. Each country contains a list of payment method types available in that country; for the US it also contains a list of supported states. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/sell/config'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "countries": [
      {
        "id": "US",
        "subdivisions": ["CA","NY","WA"],
        "payment_methods": [
          {
            "id": "CRYPTO_WALLET",
          },
          {
            "id": "FIAT_WALLET",
          },
          {
            "id": "ACH_BANK_ACCOUNT",
          },
        ],
      },
      {
        "id": "CA",
        "subdivisions": []
        "payment_methods": [
          {
            "id": "CARD",
          },
        ],
      },
    ],
  }
}
```

</TabItem>
</Tabs>

## Offramp Options

The Offramp Options API provides clients with a way to discover the available options for selling Crypto with Coinbase Offramp. 
It returns the supported fiat currencies and available crypto assets that can be passed into the Sell Quote API.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/sell/options
```

### Request Parameters

| Name          | Req | Description |
|:--------------|:----|:------------|
| `country`     | Y   | [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) two-digit country code string representing the purchasing user’s country of residence, e.g., `US`. |
| `subdivision` | N   | [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) two-digit country subdivision code representing the purchasing user’s subdivision of residence within their country, e.g. `NY`. Required if the `country=“US”` because certain states (e.g., `NY`) have state specific asset restrictions. |

### Response Fields

The Offramp Options API returns a JSON response including the following fields.

| Name                  | Description |
|:----------------------|:------------|
| `cashout_currencies`  | List of supported fiat currencies that can exchange crypto to on Coinbase Onramp in the given location. Each currency contains a list of available payment methods, with min and max transaction limits for that currency. |
| `sell_currencies` | List of available crypto assets that can be sold on Onramp in the given location. |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/sell/options?country=US&subdivision=NY'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
  "data": {
    "cashout_currencies": [
      {
        "id": "USD",
        "payment_method_limits": [
          {
            "id": "card",
            "min": "10.00",
            "max": "7500.00",
          },
          {
            "id": "ach_bank_account",
            "min": "10.00",
            "max": "25000.00",
          },
        ],
      },
    ],
    "sell_currencies": [
      {
        "id": "2b92315d-eab7-5bef-84fa-089a131333f5",
        "name": "USD Coin",
        "symbol": "USDC",
        "networks": [
          {
            "name": "ethereum-mainnet",
            "display_name": "Ethereum",
            "chain_id": "1",
            "contract_address": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
          },
          {
            "name": "polygon-mainnet",
            "display_name": "Polygon",
            "chain_id": "137",
            "contract_address": "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
          },
        ]
      }
    ],
  }
}
```

</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/onramp/docs/sdk-installing-sdk.mdx -->

---
title: "Installing the SDK"
sidebar_label: "Installing the SDK"
slug: "installing-sdk"
---

The Coinbase Onramp SDK is called the CBPay SDK. 

This page explains how to install and upgrade the SDK with <a href="https://classic.yarnpkg.com/en/package/@coinbase/cbpay-js" target="_blank" rel="noreferrer">yarn</a> or <a href="https://www.npmjs.com/package/@coinbase/cbpay-js" target="_blank" rel="noreferrer">npm</a>. 


:::info
The Coinbase Onramp public GitHub can be found at [@coinbase/cbpay-js](https://github.com/coinbase/cbpay-js).
:::

## Installing CBPay SDK

### Yarn

1. Check available versions of CBPay SDK:

```
yarn info @coinbase/cbpay-js versions
```

2. Install a specific version or the latest version: 

  > Install specific version: 
  > 
  >  ```
  >  yarn add @coinbase/cbpay-js@1.0.0
  >  ```
  >
  > Install latest version:
  >
  > ```
  >  yarn add @coinbase/cbpay-js
  >  ```

3. Check your installed version: 

```
yarn list @coinbase/cbpay-js
```


### Npm

1. Check available versions of CBPay SDK:

```
npm view @coinbase/cbpay-js versions
```

2. Install a specific version or the latest version: 

  > Install specific version: 
  > 
  >   ```
  >   npm install @coinbase/cbpay-js@1.0.0
  >   ```
  > 
  > Install latest version:
  > 
  >   ```
  >   npm install @coinbase/cbpay-js
  >  ```

3. Check your installed version: 

```
npm list @coinbase/cbpay-js
```


## Upgrading CBPay SDK

### Yarn

1. Compare your installed version of CBPay SDK with the latest available version: 

```
yarn outdated @coinbase/cbpay-js
```

2. Update CBPay SDK to the latest: 

```
yarn upgrade @coinbase/cbpay-js --latest
```

3. Check your version: 

```
yarn list @coinbase/cbpay-js
```

### Npm

1. Compare your installed version of CBPay SDK with the latest available version: 

```
npm outdated @coinbase/cbpay-js
```

2. If necessary, update `package.json` with the latest version (or major version), for example:  

```
{
  "dependencies": {
    "@coinbase/cbpay-js": "./coinbase-cbpay-js-[paysdk-version-latest].tgz"
  }
}
```

3. Update CBPay SDK to the latest available version: 

```
npm update @coinbase/cbpay-js
```

<br />
 
**See Also:**  

- [Integrating Coinbase Onramp](./sdk-integrating-onramp.mdx)
- [Generating a URL with the SDK](./sdk-generating-url.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/guidance-payment-methods.mdx -->

---
title: "Onramp Supported Payment Methods"
sidebar_label: "Payment Methods"
slug: "payment-methods"
---

Coinbase Onramp is available in all countries in which Coinbase operates except Japan. 

| Payment method/funding source      | Currently supported countries                         |
|:-----------------------------------|:------------------------------------------------------|
| Crypto balance in Coinbase account | All countries in which Coinbase operates except Japan |
| Debit cards                        | US and 90+ additional countries (including EU, UK,CA) |
| Credit cards                       | 90 countries (including EU, UK, CA, and excluding US) |
| ACH (US Bank Transfer)             | US                                                    |

:::caution
Coinbase does not support credit cards in the US.
:::

<br />

**See Also:** 

- [Onramp FAQ](./guidance-faq.mdx)




<!-- File: /Users/tinahe/docs/projects/onramp/docs/guidance-faq.mdx -->

---
title: "Onramp FAQ"
sidebar_label: "FAQ"
slug: "faq"
---

### As a developer, how do I onboard to Coinbase Onramp? 

 You can onboard to the Coinbase Onramp product through the [Coinbase Developer Platform](https://www.coinbase.com/developer-platform). 
 Go to [Getting Started](./getting-started.mdx) for details on how to create an account.


### Do users need to have a Coinbase Account in order to use Coinbase Onramp?

In most cases, users must have a Coinbase Account to use Coinbase Onramp. In the US and available geographies non-Coinbase account holders can also checkout with low limits before creating an account using our “guest checkout” feature.

Coinbase has more than <a href="https://investor.coinbase.com" target="_blank" rel="noreferrer">103M+ verified users</a> and these users can seamlessly sign-in to their existing Coinbase Account and start using Coinbase Onramp. If users do not have a Coinbase account, they will be prompted to create one in the Coinbase Onramp widget.


### Which countries are currently supported by Coinbase Onramp?

Coinbase Onramp is available in all countries in which Coinbase operates except Japan. 


### Which payment methods are supported on Coinbase Onramp?

| Payment method/funding source      | Currently supported countries                         |
|:-----------------------------------|:------------------------------------------------------|
| Crypto balance in Coinbase account | All countries in which Coinbase operates except Japan |
| Debit cards                        | US and 90+ additional countries (including EU, UK,CA) |
| Credit cards                       | 90 countries (including EU, UK, CA, and excluding US) |
| ACH (US Bank Transfer)             | US                                                    |

:::info
Watch the [Supported Payment Methods](./guidance-payment-methods.mdx) page for updates.
:::


### Can the Coinbase Onramp widget open in a new tab or as a popup?

Yes, you can configure it to open in either form. The default functionality opens the Coinbase Onramp widget in a popup when the user is logged in and logged out. To open it in a new tab, configure the [initOnRamp parameters](./sdk-integrating-onramp.mdx#initonramp-parameters), `experienceLoggedIn` and `experienceLoggedOut`, to `new_tab`.

### Can the Coinbase Onramp widget be embedded inside my platform (versus the user seeing a popup/new tab)?

No, the Coinbase Onramp widget cannot be embedded in an iframe. It must be opened in either a popup or a new tab.

### Can the Coinbase Onramp widget by opened in a Webview within my mobile app?

No, the Coinbase Onramp widget will not function correctly in a webview. We recommend using an in-app browser.

### Which blockchains and cryptocurrencies does Coinbase Onramp support?

Coinbase Onramp supports all assets and networks available for trade/send/receive on Coinbase.com. 
You can use the [Buy Options API](./api-configurations.mdx#buy-options) to get the full list.


{/* | Blockchain            | Supported Assets on coinbase.com       |
|:----------------------|:---------------------------------------|
| Algorand              | ALGO                                   |
| Aptos                 | APT                                    |
| Arbitrum              | ETH, DAI, wBTC, ARB, CBETH, MAGIC, SPA |
| **Avalanche C-Chain** | AVAX, ETH, USDC, DAI, wBTC             |
| Axelar                | AXL                                    |
| Base                  | ETH, USDC, CBETH                       |
| **Bitcoin**           | BTC                                    |
| Bitcoin Cash          | BCH                                    |
| Cardano               | ADA                                    |
| Celo                  | CGLD                                   |
| Cosmos                | ATOM                                   |
| Dash                  | DASH                                   |
| Deso                  | DESO                                   |
| Dogecoin              | DOGE                                   |
| Elrond                | EGLD                                   |
| EOS                   | EOS                                    |
| Ethereum Classic      | ETC                                    |
| **Ethereum Mainnet**  | ETH and all ERC-20 tokens (<a href="https://help.coinbase.com/en/coinbase/supported-crypto/" target="_blank" rel="noreferrer">supported on coinbase.com</a>) |
| Flow                  | FLOW                                   |
| Filecoin              | FIL                                    |
| Dfinity               | ICP                                    |
| Hedera                | HBAR                                   |
| Horizenv              | ZEN                                    |
| Kusama                | KSM                                    |
| Litecoin              | LTC                                    |
| Mina                  | MINA                                   |
| Oasis                 | ROSE                                   |
| Optimism              | ETH, DAI, wBTC, OP, USDC               |
| Osmosis               | OSMO                                   |
| Polkadot              | DOT                                    |
| Polygon               | ETH, USDC, MATIC, CBETH, VOXEL         |
| Sei                   | SEI                                    |
| **Solana**            | SOL, USDC, MEDIA, GST, ORCA, FIDA, GMT |
| Stacks                | STX                                    |
| Stellar               | XLM                                    |
| Sui                   | SUI                                    |
| Tezos                 | XTZ                                    |
| Vara                  | Vara                                   |
| Vechain               | VET, VTHO                              |
| Zcash                 | ZEC                                    | */}


### Do you support L2 blockchains? 

Yes. We support the following assets and networks for L2 Sends:

| Asset | Networks                                                                      |
|:------|:------------------------------------------------------------------------------|
| DAI   | Ethereum / Avalanche C-Chain / Optimism / Arbitrum                            |
| ETH   | Ethereum / Base / Polygon / Avalanche C-Chain / Optimism / Arbitrum           |
| MATIC | Ethereum / Polygon                                                            |
| USDC  | Ethereum / Base / Polygon / Solana / Optimism / Avalanche C-Chain / Arbitrum  |
| wBTC  | Ethereum / Avalanche C-Chain / Optimism / Arbitrum                            |

See [Layer 2 Networks](./sdk-layer2.mdx) for details. 


### What fees do you charge?

Coinbase Onramp is free for developers to use. When end-users onramp funds, Coinbase Onramp charges the following fees:

- **Spread**: Coinbase Onramp includes a spread in the price when you buy cryptocurrencies. 
This allows us to temporarily lock in a price for trade execution while you review the transaction details prior to submitting your transaction.

- **Coinbase fees**: Fees are calculated at the time you place your order and may be determined by a combination of factors, including the selected payment method, the size of the order, and market conditions such as volatility and liquidity. 
Fees are listed in the order preview screen before you submit your transaction and may differ for similar transactions.

:::info
Coinbase does not charge any Coinbase fees when a user moves their existing crypto balance from their Coinbase Account to a self-custody wallet/app using Coinbase Pay.
:::

- **Network fees:** For transactions on cryptocurrency networks (i.e., transfers of cryptocurrency off the Coinbase platform), Coinbase incurs and pays network transaction fees (e.g., miner’s fees). 
We charge a fee based on our estimate of these network fees. 
In some cases, the final fee that Coinbase pays may differ from the estimated fee. 
All fees we charge are disclosed at the time of transaction.

:::info
Coinbase does not receive any portion of the network fees that we charge.
:::


### Can we customize the email sent to the users?

No. Users that make a purchase via Coinbase Onramp receive the standard emails that they receive when purchasing and sending crypto from their Coinbase.com account to a self-custody wallet. 


<br /><br />

**See Also:** 

- [Supported Payment Methods](./guidance-payment-methods.mdx)
- [Parameters for initOnRamp](./sdk-integrating-onramp.mdx#initonramp-parameters)
- [Layer 2 Networks](./sdk-layer2.mdx)



<!-- File: /Users/tinahe/docs/projects/onramp/docs/api-offramp-reporting.mdx -->

---
title: "Transaction Status & History"
sidebar_label: "Transaction Status"
slug: "api-offramp-reporting"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


## Offramp Transaction Status

The Offramp Transaction Status API provides developers with a list of user Offramp transactions. Developers can poll the real time status of offramp transactions and show users a view of their Coinbase transactions made within the client app.

To link all transactions created during the session, developers must provide the (optional) field `partnerUserId` as a query parameter when [initializing Coinbase Onramp and Offramp](./api-initializing.mdx).

Transaction Status returns a paginated list of all transactions from newest to oldest. If the client app doesn’t have a concept of a user, clients can pass a random `partnerUserId` to reference a one-off session.

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/sell/user/{partner_user_id}/transactions?page_key={next_page_key}&page_size={page_size}
```

### Request Parameters

The Transaction Status API is an RPC endpoint that accepts an argument as part of its URL path.

| Name              | Type   | Req | Description |
|:------------------|:-------|:----|:------------|
| `partner_user_id` | String | Y   | ID referring to user Offramp transactions in client app. |
| `page_key`        | String | N   | Reference to next page of transactions. Returned in previous page’s response. |
| `page_size`       | Number | N   | Number of transactions to return per page. Default is 1. |

### Response Fields

The Transaction Status API returns a JSON response including the following fields.

| Name            | Description |
|:----------------|:------------|
| `transactions`  | List of `OfframpTransactions` in reverse chronological order. |
| `next_page_key` | A reference to the next page of transactions. |
| `total_count`   | The total number of transactions made by the user. |

#### OfframpTransaction Schema
| Name                | Description | Value |
|:--------------------|:------------|:------| 
| `status`            | Status of the offramp transaction. | `TRANSACTION_STATUS_STARTED`<br/>`TRANSACTION_STATUS_SUCCESS`<br/>`TRANSACTION_STATUS_FAILED` |
| `asset`             | Crypto currency being sold. | String |
| `network`           | Network that crypto currency is on in the user’s wallet. | String |
| `sell_amount`       | Amount of crypto currency being sold. | String |
| `total`             | Total amount of fiat the user will receive, fees deducted. | String |
| `subtotal`          | Amount of fiat for the crypto asset, fees not deducted. | String |
| `coinbase_fee`      | Amount of fiat charged to cover brokerage fees. | String |
| `exchange_rate`     | Unit price of the crypto currency being sold. | String |
| `from_address`      | The address of the wallet the transaction was sent from. | String |
| `to_address`        | The address of the coinbase address the transaction was sent to. | String |
| `tx_hash`           | The block hash of the onchain send. | String |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/sell/user/{partner_user_id}/transactions?page_key={next_page_key}&page_size={page_size}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
    "transactions": [
        {
            "id": "1ef6658f-697e-6200-b081-ba4f2149344a",
            "asset": "ETH",
            "status": "TRANSACTION_STATUS_SUCCESS",
            "network": "base",
            "sell_amount": {
                "value": "0.005",
                "currency": "ETH"
            },
            "total": {
                "value": "12.58",
                "currency": "USD"
            },
            "subtotal": {
                "value": "12.51",
                "currency": "USD"
            },
            "coinbase_fee": {
                "value": "0.07",
                "currency": "USD"
            },
            "exchange_rate": {
                "value": "0.000453720508167",
                "currency": "ETH"
            },
            "fromAddress": "0x7D09655eF4664ED4D449b0d27E15AdA1D2Ae3bE5",
            "toAddress": "0x0b59d1001629c86da136a0B480Db68EDBf70e222",
            "tx_hash": "0x31814ba2fef2a400a9816767370be09ca12d9e9753b972198fe330a0ecedcbf6",
            "created_at": "2024-08-29T20:06:07.076Z",
            "updated_at": "2024-08-29T20:10:24.054Z",
        }
    ],
    "next_page_key":"eyJndF9za2lwIjowLCJvdF9za2lwIjoxfQ==",
    "total_count":"3"
}
```
</TabItem>
</Tabs>


## Offramp Transactions

The Offramp Transactions API provides clients with a list of historical Offramp transactions between two dates. 
Transactions returns a paginated list of all transactions from newest to oldest. 
The Transactions API is indented for analytics purposes.

If you need real time information about a specific transaction, use the  [Offramp Transaction Status API](#offramp-transaction-status).

### Method

```
GET
```

### URL

```
https://api.developer.coinbase.com/onramp/v1/sell/transactions?page_key={next_page_key}&page_size={page_size}&start_date={start_date}&end_date={end_date}
```

### Request Parameters

| Name              | Type   | Req | Description |
|:------------------|:-------|:----|:------------|
| `page_key`        | String | N   | Reference to next page of transactions. Returned in previous page’s response. |
| `page_size`       | Number | N   | Number of transactions to return per page. Default is 1000. |
| `start_date`      | String | N   | The start date (inclusive) of the range of transactions to return. YYYY-MM-DD format. Default is one month before `end_date`. |
| `end_date`        | String | N   | The end date (exclusive) of the range of transactions to return. YYYY-MM-DD format. Default is tomorrow. |

### Response Fields

The Transaction API returns a JSON response including the following fields.

| Name            | Description |
|:----------------|:------------|
| `transactions`  | List of `OfframpTransactions` in reverse chronological order. |
| `next_page_key` | A reference to the next page of transactions. |

#### OfframpTransaction Schema
| Name                | Description | Value |
|:--------------------|:------------|:------| 
| `status`            | Status of the sell transaction. | `TRANSACTION_STATUS_SUCCESS`<br/>`TRANSACTION_STATUS_FAILED` |
| `asset`             | Crypto currency being sold. | String |
| `network`           | Network that crypto currency is on in the user’s wallet. | String |
| `sell_amount`       | Amount of crypto currency being sold. | String |
| `total`             | Total amount of fiat the user will receive, fees deducted. | String |
| `subtotal`          | Amount of fiat for the crypto asset, fees not deducted. | String |
| `coinbase_fee`      | Amount of fiat charged to cover brokerage fees. | String |
| `exchange_rate`     | Unit price of the crypto currency being sold. | String |
| `from_address`      | The address of the wallet the transaction was sent from. | String |
| `to_address`        | The address of the coinbase address the transaction was sent to. | String |
| `tx_hash`           | The block hash of the onchain send. | String |

### Example Request/Response

<Tabs>
<TabItem value="bash" label="Request (cURL)">

```bash
cdpcurl -k /tmp/cdp_api_key.json 'https://api.developer.coinbase.com/onramp/v1/sell/transactions?page_key={next_page_key}&page_size={page_size}&start_date={start_date}&end_date={end_date}'
```

</TabItem>
<TabItem value="jsonResponse" label="Response 200 (JSON)">

```json
{
    "transactions": [
        {
            "id": "1ef6658f-697e-6200-b081-ba4f2149344a",
            "asset": "ETH",
            "status": "TRANSACTION_STATUS_SUCCESS",
            "network": "base",
            "sell_amount": {
                "value": "0.005",
                "currency": "ETH"
            },
            "total": {
                "value": "12.58",
                "currency": "USD"
            },
            "subtotal": {
                "value": "12.51",
                "currency": "USD"
            },
            "coinbase_fee": {
                "value": "0.07",
                "currency": "USD"
            },
            "exchange_rate": {
                "value": "0.000453720508167",
                "currency": "ETH"
            },
            "fromAddress": "0x7D09655eF4664ED4D449b0d27E15AdA1D2Ae3bE5",
            "toAddress": "0x0b59d1001629c86da136a0B480Db68EDBf70e222",
            "tx_hash": "0x31814ba2fef2a400a9816767370be09ca12d9e9753b972198fe330a0ecedcbf6",
            "created_at": "2024-08-29T20:06:07.076Z",
            "updated_at": "2024-08-29T20:10:24.054Z",
        }
    ],
    "next_page_key":"eyJndF9za2lwIjowLCJvdF9za2lwIjoxfQ==",
    "total_count":"3"
}
```
</TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/demo-project/docs/howto-setup-docusaurus.mdx -->

---
title: How to Set Up Docusaurus Server
sidebar_label: "Set Up Docusaurus Server"
slug: howto-setup-docusaurus
description: Install Docusaurus and run local preview
---

This workflow assumes that you have[ homebrew](https://docs.brew.sh/Installation) installed. 

1. Install `node.js` and check version.
2. Install `yarn` with `npm` and check version.

```bash
$ brew install node
$ node -v
$ npm install --global yarn
$ yarn –version
```

3. Clone the repo coinbase-cloud-docs (the original, not a fork).
4. Navigate into coinbase-cloud-docs.
5. Confirm that "origin" is the original non-forked repo.
6. Start `yarn` and preview the docs at [http://localhost:3000/](http://localhost:3000/)

```bash
$ git clone coinbase-cloud-docs
$ cd coinbase-cloud-docs
$ git remote -v
$ yarn start
```

:::caution
Commits must be signed – configure a GPG key and add it to your GitHub Settings. 
:::

<figcaption><i>Sign Commits with GPG Key</i></figcaption> <img src={require('../assets/images/sign-commits.png').default} alt="SSH and GPG Keys in GitHub Profile Settings"  />  


<!-- File: /Users/tinahe/docs/projects/demo-project/docs/howto-propose-edits.mdx -->

---
title: How to Propose Doc Edits in the UI
sidebar_label: "Propose Docs Edits in the UI"
slug: howto-propose-edits
description: Contribute to the docs without cloning the repo
---

1. Go to the live Production Developer docs. 
2. Navigate to the page you want to edit, for example, [Rate Limits Overview](/exchange/docs/rate-limits).
3. Click the GitHub logo button in the upper right.

<figcaption><i>GitHub Edit Button</i></figcaption> <img src={require('../assets/images/github-edit-button.png').default} alt="Click the GitHub logo to navigate to the docs GitHub repo where you can start a Pull Request."  />  


<!-- File: /Users/tinahe/docs/projects/demo-project/docs/howto-add-api-docs.mdx -->

---
title: How to Document REST APIs
sidebar_label: "Add REST API Docs"
slug: howto-add-api-docs
description: Add a new API Reference from an OpenAPI spec
---

Coinbase has a variety of APIs&mdash;REST, FIX, WebSocket. And some of the REST APIs are actually gRPC or Google AIP on the backend. This page explains how we generate and publish public-facing REST API docs (gRPC or not).

:::note
See **[Coinbase Exchange REST API Docs](https://docs.google.com/document/d/13uV11j1HnJjvUtyHRxVwg6wbe5dKdz4W1WwHY24Asoo/edit#heading=h.9ip6urgkob91)** for a great explanation of a Coinbase gRPC API.
:::

## Publishing API Docs

The only thing needed to publish an [API Reference](/exchange/reference) is an accurate and well-formed [API spec](#openapi-spec) that lives in `./projects/projectName/assets/apis`.

In theory, when a team wants to update their API docs:

- The product team should attach an updated spec to the JIRA ticket.
- The Docs team should validate the spec and do a diff against the last one to ensure no regressions.

:::info
The diff is necessary because some specs have manual changes that either don't or can't live in the source code (eg, `otc-fills` with a [hyphen](/exchange/assets/apis/exchange-spec.json#L6044) vs [underscore](https://github.cbhq.net/exchange/repo/blob/c1740c1421eb07d72cc8692741cf28a176e311f9/pro/api2/protos/coinbase/pro/api2/api/reports.proto#L32)). When an engineer generates a new script, they never know to update these manually required changes.
:::

## Adding Custom Markdown

Custom Markdown is content that lives on top fo the API spec, e.g., this [Exchange endpoint](/exchange/docs/apis/get-accounts):

<img src={require('../assets/images/apis-custom-markdown.png').default} width="700" alt="" /> <br /><br />

### Enabling Custom Markdown

To enable custom markdown with OpenAPI docs, update the `project.config.js` file to render custom markdown from a specified directory:

```js
openApi: {
  customMarkdownDir: "./projects/projectName/docs/apis",
},
```

### Creating Custom Pages

We store custom markdown files in `./projects/projectName/docs/apis` which you may need to create if the project does not have have any custom content.

Markdown files in the specified directory are rendered for OpenAPI pages that match the **operationId** specified in the frontmatter of the source markdown files.

For example:

```md
---
operationId: example_Operation
---

# Example content
```

This markdown content is rendered for the OpenAPI spec page with an operationId of `example_Operation`.

### Location on API Page

You can also specify the location of the custom markdown in the frontmatter to control where the content will render on the page. The available options are top and bottom. If not specified, the location will default to top.

```md
---
operationId: example_Operation
location: bottom
---

This content renders at the bottom of the OpenAPI page.
```

## OpenAPI Spec

With a few exceptions, all REST API documentation is published from an [OpenAPI spec](https://blog.stoplight.io/difference-between-open-v2-v3-v31), formerly called Swagger. This file can be in json or yaml/yml format. The bigger distinction is OpenAPI version 2 vs 3.

:::note
Good article: [What’s the Difference Between OpenAPI Types 2.0, 3.0, and 3.1?](https://blog.stoplight.io/difference-between-open-v2-v3-v31)
:::

##### OpenAPI 3

- [Commerce Onchain](/commerce-onchain/assets/apis/commerce-onchain-spec.yml) (`3.0.0`)
- [Eth2 Validator](/blockchain-infrastructure/assets/apis/eth2-spec.json) (`3.0.2`)
- [Intl Exchange](/intx/assets/apis/intx-public-api-spec.yaml) (`3.0.3`)
- [Rosetta/Mesh](/rosetta/assets/apis/rosetta-spec.json) (`3.0.2`)

##### OpenAPI/Swagger 2

- [Advanced Trade](/advanced-trade/assets/apis/retail-public-api-spec.json) (`2.0`)
- [Exchange](/exchange/assets/apis/exchange-spec.json) (`2.0`)
- [Prime](/prime-broker/assets/apis/prime-public-api-spec.json) (`2.0`)

##### Markdown

- [Paymaster and Bundler](/node/docs/paymaster-bundler-api)
- [Pay SDK/Onramp](/pay-sdk/docs/rest-api-reference)
- [Coinbase App](/coinbase-app/docs)

## OpenAPI Plugin

Coinbase API docs are rendered with an OpenAPI plugin that we forked from the original [docusaurus-openapi](https://github.com/cloud-annotations/docusaurus-openapi).

The fork's source code was moved locally to [plugins/docusaurus-plugin-openapi](https://github.com/bisontrails/cloud-docs/tree/main/plugins/docusaurus-plugin-openapi) and [plugins/docusaurus-theme-openapi](https://github.com/bisontrails/cloud-docs/tree/main/plugins/docusaurus-theme-openapi).

The fork was created to customize the appearance of the generated OpenAPI doc pages to closer resemble Readme.io (from which we migrated) and add advanced features that Readme offers (Try It functionality, additional code snippet generation, etc.).

## OpenAPI Plugin Options

### - `customMarkdownDir`

The path to the custom markdown files, relative to the root of the repository.

<details>
<summary><b>grep -rn "customMarkdownDir"</b></summary>
<div>

```sh
% grep -rn "customMarkdownDir" --exclude-dir="node_modules" --exclude-dir="build" --exclude-dir=".docusaurus" --exclude-dir="demo-project" --exclude=RUNBOOK.md *
plugins/docusaurus-plugin-openapi/lib/types.d.ts:25:    customMarkdownDir?: string;
plugins/docusaurus-plugin-openapi/lib/options.js:42:    customMarkdownDir: utils_validation_1.Joi.string(),
plugins/docusaurus-plugin-openapi/lib/index.js:17: * Loads custom markdown files from the `customMarkdownDir` directory
plugins/docusaurus-plugin-openapi/lib/index.js:20: * @param customMarkdownDir The directory that contains the custom markdown files.
plugins/docusaurus-plugin-openapi/lib/index.js:23:async function loadCustomMarkdownFiles(customMarkdownDir, apiMetadata, replacements = {}) {
plugins/docusaurus-plugin-openapi/lib/index.js:28:            cwd: customMarkdownDir,
plugins/docusaurus-plugin-openapi/lib/index.js:30:        const fileContents = await Promise.all(markdownFiles.map((file) => fs_extra_1.default.readFile(path_1.default.join(customMarkdownDir, file))));
plugins/docusaurus-plugin-openapi/lib/index.js:154:                if (options.customMarkdownDir) {
plugins/docusaurus-plugin-openapi/lib/index.js:155:                    await loadCustomMarkdownFiles(options.customMarkdownDir, loadedApi, variableReplacements);
plugins/docusaurus-plugin-openapi/src/types.ts:40:  customMarkdownDir?: string;
plugins/docusaurus-plugin-openapi/src/index.ts:38: * Loads custom markdown files from the `customMarkdownDir` directory
plugins/docusaurus-plugin-openapi/src/index.ts:41: * @param customMarkdownDir The directory that contains the custom markdown files.
plugins/docusaurus-plugin-openapi/src/index.ts:45:  customMarkdownDir: string,
plugins/docusaurus-plugin-openapi/src/index.ts:52:      cwd: customMarkdownDir,
plugins/docusaurus-plugin-openapi/src/index.ts:56:        fs.readFile(path.join(customMarkdownDir, file))
plugins/docusaurus-plugin-openapi/src/index.ts:218:        if (options.customMarkdownDir) {
plugins/docusaurus-plugin-openapi/src/index.ts:219:          await loadCustomMarkdownFiles(options.customMarkdownDir, loadedApi, variableReplacements);
plugins/docusaurus-plugin-openapi/src/options.ts:50:  customMarkdownDir: Joi.string(),
projects/exchange/project.config.js:78:    customMarkdownDir: "./projects/exchange/docs/apis",
projects/intx/project.config.js:57:    customMarkdownDir: "./projects/intx/docs/apis",
projects/prime-broker/project.config.js:39:    customMarkdownDir: "./projects/prime-broker/docs/apis",
projects/advanced-trade/project.config.js:51:    customMarkdownDir: "./projects/advanced-trade/docs/apis",
```

</div>
</details>

### - `disableRequestButton`

Default: `true`

If enabled, prevents the "Try it" button from displaying.

<details>
<summary><b>grep -rn "disableRequestButton"</b></summary>
<div>

```sh
% grep -rn "disableRequestButton" --exclude-dir="node_modules" --exclude-dir="build" --exclude-dir=".docusaurus" --exclude-dir="demo-project" --exclude=RUNBOOK.md *
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/hooks.js:5:  const { disableRequestButton, submitRequestButtonText } = useTypedSelector(
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/hooks.js:10:    requestButtonDisabled: disableRequestButton ?? false,
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/hooks.js:14:    disableRequestButton,
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/hooks.js:19:    requestButtonDisabled: disableRequestButton !== null && disableRequestButton !== void 0 ? disableRequestButton : false
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/hooks.ts:9:  const { disableRequestButton, submitRequestButtonText } = useTypedSelector(
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/hooks.ts:15:    requestButtonDisabled: disableRequestButton ?? false,
plugins/docusaurus-plugin-openapi/lib/types.d.ts:31:    disableRequestButton?: boolean;
plugins/docusaurus-plugin-openapi/lib/options.js:22:    disableRequestButton: false,
plugins/docusaurus-plugin-openapi/lib/options.js:43:    disableRequestButton: utils_validation_1.Joi.boolean().default(exports.DEFAULT_OPTIONS.disableRequestButton),
plugins/docusaurus-plugin-openapi/src/types.ts:46:  disableRequestButton?: boolean;
plugins/docusaurus-plugin-openapi/src/options.ts:25:  disableRequestButton: false,
plugins/docusaurus-plugin-openapi/src/options.ts:51:  disableRequestButton: Joi.boolean().default(
plugins/docusaurus-plugin-openapi/src/options.ts:52:    DEFAULT_OPTIONS.disableRequestButton
projects/exchange/project.config.js:79:    disableRequestButton: true,
projects/intx/project.config.js:58:    disableRequestButton: true,
projects/blockchain-infrastructure/project.config.js:39:    disableRequestButton: true,
projects/prime-broker/project.config.js:40:    disableRequestButton: true,
projects/commerce-onchain/project.config.js:39:    disableRequestButton: true,
projects/advanced-trade/project.config.js:52:    disableRequestButton: true,
projects/rosetta/project.config.js:29:    disableRequestButton: true,
```

</div>
</details>

### - `enableCodeSamples`

Default: `false`

Displays sample code snippets for different programming languages to perform a request against an API.

<details>
<summary><b>grep -rn "enableCodeSamples"</b></summary>
<div>

```sh
% grep -rn "enableCodeSamples" --exclude-dir="node_modules" --exclude-dir="build" --exclude-dir=".docusaurus" --exclude-dir="demo-project" --exclude=RUNBOOK.md *
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:42:  const { enableCodeSamples } = useTypedSelector(
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:71:    if (enableCodeSamples) {
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:123:  const sectionTitle = enableCodeSamples ? "Language" : undefined;
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:126:      {enableCodeSamples && (
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:213:      {enableCodeSamples && <Authorization />}
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:215:      {(enableCodeSamples || !requestButtonDisabled) && (
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:218:            {enableCodeSamples && (
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/Curl/index.js:226:              {enableCodeSamples && <CopyToClipboard text={code} />}
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:58:    enableCodeSamples
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:80:    if (enableCodeSamples) {
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:113:  const sectionTitle = enableCodeSamples ? "Language" : undefined;
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:115:      {enableCodeSamples && <div className={(0, _clsx.default)(_stylesModule.default.buttonGroup, "api-code-tab-group")}>
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:156:      {enableCodeSamples && <_Authorization.default />}
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:158:      {(enableCodeSamples || !requestButtonDisabled) && <div className={_stylesModule.default.requestContainer}>
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:160:            {enableCodeSamples && <_CodeMirror.default theme="material-palenight" mode={(0, _utils.getModeForLanguage)(language)} value={codeText}></_CodeMirror.default>}
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/Curl/index.js:162:              {enableCodeSamples && <_CopyToClipboard.default text={code} />}
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:57:  const { enableCodeSamples } = useTypedSelector(
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:92:    if (enableCodeSamples) {
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:148:  const sectionTitle = enableCodeSamples ? "Language" : undefined;
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:152:      {enableCodeSamples && (
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:239:      {enableCodeSamples && <Authorization />}
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:241:      {(enableCodeSamples || !requestButtonDisabled) && (
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:244:            {enableCodeSamples && (
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/Curl/index.tsx:252:              {enableCodeSamples && <CopyToClipboard text={code} />}
plugins/docusaurus-plugin-openapi/lib/types.d.ts:40:    enableCodeSamples?: boolean;
plugins/docusaurus-plugin-openapi/lib/options.js:23:    enableCodeSamples: false,
plugins/docusaurus-plugin-openapi/lib/options.js:44:    enableCodeSamples: utils_validation_1.Joi.boolean().default(exports.DEFAULT_OPTIONS.enableCodeSamples),
plugins/docusaurus-plugin-openapi/src/types.ts:55:  enableCodeSamples?: boolean;
plugins/docusaurus-plugin-openapi/src/options.ts:26:  enableCodeSamples: false,
plugins/docusaurus-plugin-openapi/src/options.ts:54:  enableCodeSamples: Joi.boolean().default(DEFAULT_OPTIONS.enableCodeSamples),
projects/exchange/project.config.js:80:    enableCodeSamples: true,
projects/intx/project.config.js:59:    enableCodeSamples: true,
projects/blockchain-infrastructure/project.config.js:40:    enableCodeSamples: true,
projects/prime-broker/project.config.js:41:    enableCodeSamples: true,
projects/commerce-onchain/project.config.js:40:    enableCodeSamples: true,
projects/advanced-trade/project.config.js:53:    enableCodeSamples: true,
projects/rosetta/project.config.js:30:    enableCodeSamples: true,
```

</div>
</details>

### - `id`

The ID of the OpenAPI project to render. This property is required and must be unique across all projects.

### - `routeBasePath`

The base URL path for the OpenAPI docs. If used in combination with markdown docs, the `routeBasePath` should start with the same `routeBasePath` in the `docs` plugin options.

For example, if the `docs` plugin options are:

```js
{
  docs: {
    routeBasePath: "exchange";
  }
}
```

Then the `openApi` plugin options should be:

```js
{
  openApi: {
    routeBasePath: "exchange/reference";
  }
}
```

<details>
<summary><b>grep -rn "routeBasePath"</b></summary>
<div>

```sh
% grep -rn "routeBasePath" --exclude-dir="node_modules" --exclude-dir="build" --exclude-dir=".docusaurus" --exclude-dir="demo-project"  --exclude=RUNBOOK.md *
docusaurus.config.js:572:
plugins/docusaurus-plugin-openapi/README.md:30:          routeBasePath: 'cars',
plugins/docusaurus-plugin-openapi/README.md:42:        routeBasePath: 'trains',
plugins/docusaurus-plugin-openapi/README.md:51:        routeBasePath: 'bikes',
plugins/docusaurus-plugin-openapi/lib/types.d.ts:9:    routeBasePath: string;
plugins/docusaurus-plugin-openapi/lib/options.js:12:    routeBasePath: "api", // URL Route.
plugins/docusaurus-plugin-openapi/lib/options.js:29:    routeBasePath: utils_validation_1.Joi.string()
plugins/docusaurus-plugin-openapi/lib/options.js:32:        .default(exports.DEFAULT_OPTIONS.routeBasePath),
plugins/docusaurus-plugin-openapi/lib/index.js:137:            const { routeBasePath } = options;
plugins/docusaurus-plugin-openapi/lib/index.js:163:                    routeBasePath,
plugins/docusaurus-plugin-openapi/lib/index.js:188:            const { routeBasePath, apiLayoutComponent, apiItemComponent, sidebarCollapsed, sidebarCollapsible, } = options;
plugins/docusaurus-plugin-openapi/lib/index.js:197:                const pageId = `site-${routeBasePath}-${item.id}`;
plugins/docusaurus-plugin-openapi/lib/index.js:236:            const apiBaseRoute = (0, utils_1.normalizeUrl)([baseUrl, routeBasePath]);
plugins/docusaurus-plugin-openapi/lib/index.js:241:                const pageId = `site-${routeBasePath}-${item.id}`;
plugins/docusaurus-plugin-openapi/lib/docs/docs.js:73:        options.routeBasePath,
plugins/docusaurus-plugin-openapi/lib/openapi/openapi.js:287:            options.routeBasePath,
plugins/docusaurus-plugin-openapi/lib/openapi/openapi.js:295:                    options.routeBasePath,
plugins/docusaurus-plugin-openapi/lib/openapi/openapi.js:305:                    options.routeBasePath,
plugins/docusaurus-plugin-openapi/lib/openapi/openapi.d.ts:11:    routeBasePath: string;
plugins/docusaurus-plugin-openapi/src/docs/docs.ts:133:    options.routeBasePath,
plugins/docusaurus-plugin-openapi/src/openapi/openapi.ts:330:    routeBasePath: string;
plugins/docusaurus-plugin-openapi/src/openapi/openapi.ts:370:      options.routeBasePath,
plugins/docusaurus-plugin-openapi/src/openapi/openapi.ts:379:          options.routeBasePath,
plugins/docusaurus-plugin-openapi/src/openapi/openapi.ts:390:          options.routeBasePath,
plugins/docusaurus-plugin-openapi/src/types.ts:20:  routeBasePath: string;
plugins/docusaurus-plugin-openapi/src/index.ts:200:      const { routeBasePath } = options;
plugins/docusaurus-plugin-openapi/src/index.ts:230:          routeBasePath,
plugins/docusaurus-plugin-openapi/src/index.ts:271:        routeBasePath,
plugins/docusaurus-plugin-openapi/src/index.ts:288:        const pageId = `site-${routeBasePath}-${item.id}`;
plugins/docusaurus-plugin-openapi/src/index.ts:339:      const apiBaseRoute = normalizeUrl([baseUrl, routeBasePath]);
plugins/docusaurus-plugin-openapi/src/index.ts:345:        const pageId = `site-${routeBasePath}-${item.id}`;
plugins/docusaurus-plugin-openapi/src/options.ts:15:  routeBasePath: "api", // URL Route.
plugins/docusaurus-plugin-openapi/src/options.ts:33:  routeBasePath: Joi.string()
plugins/docusaurus-plugin-openapi/src/options.ts:36:    .default(DEFAULT_OPTIONS.routeBasePath),
projects/mesh/project.config.js:14:    routeBasePath: "mesh",
projects/mesh/project.config.js:28:    routeBasePath: "mesh/reference",
projects/exchange/project.config.js:16:    routeBasePath: "exchange",
projects/exchange/project.config.js:39:    routeBasePath: "exchange/reference",
projects/intx/project.config.js:16:    routeBasePath: "intx",
projects/intx/project.config.js:39:    routeBasePath: "intx/reference",
projects/blockchain-infrastructure/project.config.js:15:    routeBasePath: "blockchain-infrastructure",
projects/blockchain-infrastructure/project.config.js:38:    routeBasePath: "blockchain-infrastructure/reference",
projects/derivatives/project.config.js:15:    routeBasePath: "derivatives",
projects/onchain-data/project.config.js:14:      routeBasePath: "onchain-data",
projects/commerce-onchain/project.config.js:15:    routeBasePath: "commerce-onchain",
projects/commerce-onchain/project.config.js:39:    routeBasePath: "commerce-onchain/reference",
projects/advanced-trade/project.config.js:15:    routeBasePath: "advanced-trade",
projects/advanced-trade/project.config.js:51:    routeBasePath: "advanced-trade/reference",
projects/product-apis/project.config.js:9:    routeBasePath: "product-apis",
projects/build-onchain/project.config.js:9:    routeBasePath: "build-onchain",
projects/delegation/project.config.js:14:    routeBasePath: "delegation",
projects/onramp/project.config.js:14:    routeBasePath: "onramp",
projects/staking/project.config.js:10:    routeBasePath: "staking",
projects/staking/project.config.js:23:    routeBasePath: "staking/reference",
projects/wallets/project.config.js:9:    routeBasePath: "wallets",
projects/cdp-apis/project.config.js:9:    routeBasePath: "cdp-apis",
projects/node/project.config.js:14:    routeBasePath: "node",
projects/walletlink/project.config.js:15:    routeBasePath: "wallet-sdk",
projects/get-started/project.config.js:10:    routeBasePath: "get-started",
projects/coinbase-app/project.config.js:15:    routeBasePath: "coinbase-app",
projects/prime/project.config.js:15:    routeBasePath: "prime",
projects/prime/project.config.js:38:    routeBasePath: "prime/reference",
scripts/cli/new-project.js:41:    routeBasePath: "${kebabCaseProjectName}",
src/theme/NavbarItem/DocsVersionDropdownNavbarItem.js:20:    const { routeBasePath } = contentDocsPlugin[0][1];
src/theme/NavbarItem/DocsVersionDropdownNavbarItem.js:21:    if (isBrowser && window.location.pathname.startsWith(`/${routeBasePath}`)) {
```

</div>
</details>

### - `submitRequestButtonText`

Default: `Try it`

The text of the button for performing an API request.

<details>
<summary><b>grep -rn "submitRequestButtonText"</b></summary>
<div>

```sh
% grep -rn "submitRequestButtonText" --exclude-dir="node_modules" --exclude-dir="build" --exclude-dir=".docusaurus" --exclude-dir="demo-project"  --exclude=RUNBOOK.md *
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/hooks.js:5:  const { disableRequestButton, submitRequestButtonText } = useTypedSelector(
plugins/docusaurus-theme-openapi/lib-next/theme/ApiDemoPanel/hooks.js:9:    requestButtonText: submitRequestButtonText ?? "Execute",
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/hooks.js:15:    submitRequestButtonText
plugins/docusaurus-theme-openapi/lib/theme/ApiDemoPanel/hooks.js:18:    requestButtonText: submitRequestButtonText !== null && submitRequestButtonText !== void 0 ? submitRequestButtonText : "Execute",
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/hooks.ts:9:  const { disableRequestButton, submitRequestButtonText } = useTypedSelector(
plugins/docusaurus-theme-openapi/src/theme/ApiDemoPanel/hooks.ts:14:    requestButtonText: submitRequestButtonText ?? "Execute",
plugins/docusaurus-plugin-openapi/lib/types.d.ts:35:    submitRequestButtonText?: string;
plugins/docusaurus-plugin-openapi/lib/options.js:45:    submitRequestButtonText: utils_validation_1.Joi.string(),
plugins/docusaurus-plugin-openapi/src/types.ts:50:  submitRequestButtonText?: string;
plugins/docusaurus-plugin-openapi/src/options.ts:55:  submitRequestButtonText: Joi.string(),
```

</div>
</details>



<!-- File: /Users/tinahe/docs/projects/demo-project/docs/template-markdown.mdx -->

---
title: "Markdown Demo"
sidebar_label: "Markdown Demo"
description: Examples of common Markdown features
slug: template-markdown
---

This page demonstrates some of the most used Markdown features, as well some features that are better coded in HTML.

## Admonitions

##### Display

:::tip
Information that helps improve performance, usability, etc.
:::

:::info
General information on a product, feature, process, etc.
:::

:::caution
Information that warns of potential errors or degradation (but not data loss).
:::

:::danger
Information that warns of potential data loss and/or value!
:::

:::note
Reserved to use for internal audiences when we get an internal audience flag.
:::

:::announcement
Announcement information
:::

--- 

##### Markdown

```
:::tip
Information that helps improve performance, usability, etc.
:::

:::info
General information on a product, feature, process, etc.
:::

:::caution
Information that warns of potential errors or degradation (but not data loss).
:::

:::danger
Information that warns of potential data loss and/or value!
:::

:::note
Reserved to use for internal audiences when we get an internal audience flag.
:::

:::announcement
Announcement information
:::
```


## Badges

Badge colors and labels are customizable. They can also link to other pages and page anchors. For more details, see [Using badges in markdown](https://github.com/bisontrails/cloud-docs/blob/main/getting-started/markdown/badges.md) and [shields.io](https://shields.io/).

##### Display

<!--- Import to use badge feature --->

import Badge from '@components/Badge';

> Badge with default blue
> <Badge color="blue" url="/demo-project/docs/template-relnotes.md" label="v1.2.0:New feature" />

<br />

> Badge with Coinbase blue
> <Badge color="0052ff" url="https://www.coinbase.com/" label="v1.2.0:New feature" />

--- 

##### Markdown

To use badges on a page, you must import the badge component:

```
import Badge from '@components/Badge';
```

```
# Badge with default blue
<Badge color="blue" url="template-relnotes.md" label="v1.2.0:New feature" />
```

```
# Badge with Coinbase blue
<Badge color="0052ff" url="https://www.coinbase.com/" label="v1.2.0:New feature" />
```

## Codeblocks

The [Docusaurus docs](https://docusaurus.io/docs/next/markdown-features/code-blocks) explain a wide array of code-block options. You will probably only need a simple code block, or a set of code block in a tabbed view. 

##### Display

###### Simple code block

```java
Action requestAccounts = new Web3JsonRPC.RequestAccounts().action(false);
```

###### Tabbed code block 

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val requestAccounts = Web3JsonRPC.RequestAccounts().action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action requestAccounts = new Web3JsonRPC.RequestAccounts().action(false);
```

</TabItem>
</Tabs>

---

##### Markdown


###### Simple code block

<pre>
```java<br />
Action requestAccounts = new Web3JsonRPC.RequestAccounts().action(false);<br />
```
</pre>


###### Tabbed code block 

I'm having trouble dispalying the entire thing as one, but here are the steps: 

1. Import the following somewhere on the page: 

```
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

2. Nest the code blocks in the following html tags: 

```
<Tabs>
<TabItem value="kotlin" label="Kotlin">
<i>Insert code block here</i>
</TabItem>

<TabItem value="java" label="Java">
<i>Insert code block here</i>
</TabItem>
</Tabs>
```

3. Insert each code block in between the TabItem tags. 

<pre>
```kotlin<br />
val requestAccounts = Web3JsonRPC.RequestAccounts().action()<br />
```
</pre>

<pre>
```java<br />
Action requestAccounts = new Web3JsonRPC.RequestAccounts().action(false);<br />
```
</pre>



## Comments

<!--- TODO: Look into [magic comments](https://docusaurus.io/docs/api/themes/configuration#codeblock-magicComments) --->

A comment is hidden text. To be truly hidden, it must not show up in view source or developer tools.

##### Display

These comments are hidden on the page, but do they show up in View Source () or Developer Tools ()? They shouldn't be there.

<!--- This is a comment. --->

<!-- This is a comment. -->

<!--{# This is a comment. #}-->

// This is a not comment.

##### Markdown

```
// Start code block

<!--- This is a mardown comment. --->

<!-- This is a comment. -->

<!--{# This is a comment. #}-->

// This is a not comment.

// End code block
```

## Conditionals

## Headings

There are 6 default heading levels. Only levels 2 and 3 show up in the right sidebar. Headings can be used as [link](#links) anchors.

For more, see the Docusaurus [heading examples](https://docusaurus.io/docs/next/markdown-features/toc#example-subsection-1-a).

##### Display

# Level 1 (does not display in right sidebar)

## Level 2

### Level 3

#### Level 4 (does not display in right sidebar)

##### Level 5 (does not display in right sidebar)

###### Level 6 (does not display in right sidebar)

##### Markdown

```
# Level 1 (does not display in right sidebar)

## Level 2

### Level 3

#### Level 4 (does not display in right sidebar)

##### Level 5 (does not display in right sidebar)

###### Level 6 (does not display in right sidebar)
```

## Images

Markdown is convenient for displaying images, but you can't easily control for size and alignment. HTML gives you control out of the box.

### Markdown Image

Coding images in Markdown renders them extremely large. You have much more control when you use HTML, which is recommended.

##### Display

**This image is gigantic** on a desktop because it was coded in Markdown. There are no good options for resizing images with Markown. Consider using [HTML](#html-image) instead.

![](../assets/images/user-flow-01-authenticate.png)

##### Markdown

This is how you code an image in Markdown:

```
![](../assets/images/user-flow-01-authenticate.png)
```

### HTML Image

The `img` tag lets you control for a variety of factors.

##### Display

This particular image:

- Has a caption ("Enter Credentials")
- Is sized to 350 pixels (click to enlarge)
- Has meaningful alt text for accessibility (see code below)
- Is left-aligned by default

<figcaption><i>Enter Credentials</i></figcaption> <img src={require('../assets/images/user-flow-01-authenticate.png').default} width="350" alt="Begin authentication by entering your credentials (email and password)."  />

###### HTML

This is how you code an image in HTML:

```
<figcaption><i>Enter Credentials</i></figcaption> <img src={require('../assets/images/user-flow-01-authenticate.png').default} width="350" alt="Begin authentication by entering your credentials (email and password)."  />
```

### Collapsing Images & Content

Use the HTML details tag to collapse images or content. To see this in action, go to the [Advanced Trade SDK quickstart](/advanced-trade/docs/sdk-rest-client-trade/#introduction).

##### Display

<details>
<summary><b>Expand for images and click to enlarge</b></summary>

<div>
<figcaption><i>Enter Credentials</i></figcaption> <img src={require('../assets/images/user-flow-01-authenticate.png').default} width="250" alt="Begin authentication by entering your credentials (email and password)."  />  
<figcaption><i>Go Through 2fa</i></figcaption> <img src={require('../assets/images/user-flow-02-2fa.png').default} width="250" alt="For 2FA enter the 7-digit code. Check the box to avoid being prompted again for 30 days."  /> 
<figcaption><i>Authorize App</i></figcaption> <img src={require('../assets/images/user-flow-03-authorize.png').default} width="250" alt="Authorize the app."   />
</div>
</details>

###### HTML

```
<div>
<figcaption><i>Enter Credentials</i></figcaption> <img src={require('../assets/images/user-flow-01-authenticate.png').default} width="250" alt="Begin authentication by entering your credentials (email and password)."  />
<figcaption><i>Go Through 2fa</i></figcaption> <img src={require('../assets/images/user-flow-02-2fa.png').default} width="250" alt="For 2FA enter the 7-digit code. Check the box to avoid being prompted again for 30 days."  />
<figcaption><i>Authorize app</i></figcaption> <img src={require('../assets/images/user-flow-03-authorize.png').default} width="250" alt="Authorize the app."   />
</div>
</details>
```

## Links

##### Display

- Link to a heading (or anchor) within a page: [Admonitions](#admonitions)

- Link to a heading on another page: [New Widget](template-changelog.md#2022-sep-02)

<!--- TODO: Figure out custom ID --->

- Link to a custom Id:

- Link from a badge: [<Badge color="orange" label="click:me" />](template-changelog.md)

##### Markdown

```
- Link to a heading (or anchor) within a page: [Admonitions](#admonitions)

- Link to a heading on another page: [New Widget](template-changelog.md#2022-sep-02)

- Link to a custom Id: [Danger Admonition](todo)

- Link from a badge: [<Badge color="orange" label="click:me" />](template-changelog.md)

```



<!-- File: /Users/tinahe/docs/projects/staking/docs/quickstart-legacy.mdx -->

---
title: "Quickstart: Make Your First API Call"
sidebar_label: "Quickstart (Legacy)"
slug: "quickstart-legacy"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Coinbase Staking API empowers developers to deliver a fully-featured staking experience in their apps using one common interface across protocols.

The goal of this quickstart is to stake ETH on Holesky within minutes.

:::info
This guide assumes you already have a Coinbase Developer Platform account. If not, you can signup [here](/get-started/docs/welcome).
:::

## Part 1: Make an API Call

### 1. Prerequisites

<Tabs groupId="programming-language">
<TabItem value="typescript" label="TypeScript" default>

[Node 20+](https://nodejs.org/en/download). To verify your installation, print the Node version:

```
node -v
```

</TabItem>

<TabItem value="golang" label="Golang">

[Go 1.21+](https://go.dev/doc/install). To verify your installation, print the Go version:

```
go version
```

</TabItem>

</Tabs>

### 2. API Key Setup

Create a secret API key from the Coinbase Developer Platform. Ensure you have the `apiKeyName` and `apiPrivateKey` info from the secret API key creation page.

:::info
If you don't have a secret API key, follow [this guide](/get-started/docs/cdp-keys/#creating-api-keys) to create one.
:::

### 3. Create a Workspace

In your preferred shell, create a new directory:

```shell 
mkdir staking-demo
cd staking-demo
```

### 4. Install the Staking Client

<Tabs groupId="programming-language">
<TabItem value="typescript" label="TypeScript" default>

[![npm version](https://badge.fury.io/js/@coinbase%2Fstaking-client-library-ts.svg)](https://github.com/coinbase/staking-client-library-ts)

```
npm install @coinbase/staking-client-library-ts
```
</TabItem>

<TabItem value="golang" label="Golang">

[![Current version](https://img.shields.io/github/tag/coinbase/staking-client-library-go?color=3498DB&label=version)](https://github.com/coinbase/staking-client-library-go/releases)

Setup a Go project and install the staking client:

```shell
go mod init example
go get github.com/coinbase/staking-client-library-go
```
</TabItem>

</Tabs>

### 5. Make an API Call

<Tabs groupId="programming-language">
<TabItem value="typescript" label="TypeScript" default>

Start an interactive shell:

```shell
npx ts-node
```

Paste the `apiKeyName` and `apiPrivateKey` that you created in [Step 2](#2-api-key-setup) into the interactive shell:

```ts
const apiKeyName: string = 'YOUR_API_KEY_NAME';
```

```ts
const apiPrivateKey: string = 'YOUR_API_PRIVATE_KEY';
```

:::tip
Ensure the `apiPrivateKey` is only one line. It should contain the `\n` character instead of actual new lines.
:::

Paste the code block below into the shell to make the API call:

```ts showLineNumbers
import { StakingClient } from '@coinbase/staking-client-library-ts';

const client = new StakingClient(apiKeyName, apiPrivateKey);

async function example() {
  const protocols = await client.listProtocols();
  console.log(protocols)
}

example().catch((error) => {
  console.error(error);
});
``` 
<details>
  <summary>Expected output</summary>
```text
{
  protocols: [ { name: protocols/ethereum_kiln }, { name: protocols/solana } ]
}
```
</details>

</TabItem>

<TabItem value="golang" label="Golang">

Create a new file named `example.go` in the `staking-demo` directory. Next, copy and paste the code below into `example.go`.

:::tip
Ensure the `apiPrivateKey` is only one line. It should contain the `\n` character instead of actual new lines.
:::

```go
package main

import (
  "context"
  "fmt"
  "log"

  "google.golang.org/protobuf/encoding/protojson"

  "github.com/coinbase/staking-client-library-go/auth"
  "github.com/coinbase/staking-client-library-go/client"
  "github.com/coinbase/staking-client-library-go/client/options"
  api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
// highlight-start
  apiKeyName    = "YOUR_API_KEY_NAME"
  apiPrivateKey = "YOUR_API_PRIVATE_KEY"
// highlight-end
)

func main() {
  ctx := context.Background()

  // Load the API key.
  apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
    if err != nil {
    log.Fatalf("error loading API key: %s", err.Error())
  }

  // Create a staking client.
  stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
  if err != nil {
    log.Fatalf("error instantiating staking client: %s", err.Error())
  }

  // List available protocols.
  protocols, err := stakingClient.Orchestration.ListProtocols(ctx, &api.ListProtocolsRequest{})
  if err != nil {
    log.Fatalf("error listing protocols: %s", err.Error())
  }

  marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(protocols)
  if err != nil {
    log.Fatalf("error marshaling reward: %s", err.Error())
  }

  fmt.Println(string(marshaled))
}
```

Lastly, run the code:

```
go mod tidy
go run example.go
```

<details>
  <summary>Expected output</summary>
```json
{
  "protocols":  [
    {
      "name":  "protocols/ethereum_kiln"
    },
    {
      "name":  "protocols/solana"
    }
  ]
}
```
</details>

</TabItem>
</Tabs>

Congratulations! You've successfully made your first Coinbase Staking API call.

In the next part, you'll publish a staking transaction onchain.

## Part 2: Publish a Staking Transaction Onchain

Now that you've made your first API call, let's publish a staking transaction on testnet.

You'll stake some ETH via our [Partial ETH Staking](../protocols/partial-eth/fundamentals) solution, which allows users to stake with any value of ETH. Since Holesky is an Ethereum testnet, no real assets are at risk.

### 1. Prerequisites

* A wallet with some testnet **Holesky** ETH in it. If needed, you can get some Holesky ETH from [this faucet](https://faucet.quicknode.com/ethereum/holesky).

* Your wallet's private key and address. 

### 2. Create and Sign a Staking Transaction

<Tabs groupId="programming-language">
<TabItem value="typescript" label="TypeScript" default>

Start an interactive shell:

```shell
npx ts-node
```

Paste your `apiKeyName` and `apiPrivateKey` from the CDP portal into the interactive shell:

```ts
const apiKeyName: string = 'YOUR_API_KEY_NAME';
```

```ts
const apiPrivateKey: string = 'YOUR_API_PRIVATE_KEY';
```

:::tip
Ensure `apiPrivateKey` is only one line. It should contain the `\n` character instead of actual new lines.
:::


Paste your `walletAddress` and `walletPrivateKey` into the interactive shell:

```ts
const walletAddress: string = 'YOUR_WALLET_ADDRESS';
```

```ts
const walletPrivateKey: string = 'YOUR_WALLET_PRIVATE_KEY';
```

Paste the code block below into the interactive shell to create the staking transaction:

:::info
The signer used in the below example is for demonstration purposes only. In production, you would use a wallet SDK or signer of your choice to sign transactions.
Checkout the [TS signer lib](https://github.com/coinbase/staking-client-library-ts/blob/main/src/signers/ethereum-signer.ts#L6-L24), which uses `etherjs` to sign unsigned transactions.
:::

```ts showLineNumbers
import { StakingClient, TxSignerFactory, getUnsignedTx } from '@coinbase/staking-client-library-ts';

const client = new StakingClient(apiKeyName, apiPrivateKey);

async function stake() {
    // Step 1 - Get an unsigned transaction corresponding to a
    // stake of 11 wei ETH from your wallet on network Holesky.
    let workflow = await client.Ethereum.stake('holesky', walletAddress, '11');
    let unsignedTx = getUnsignedTx(workflow);
    console.log('Unsigned transaction %s', unsignedTx);

    // Step 2 - Sign the unsigned transaction with your wallet's private key.
    // Note: In production, this part would be performed via a wallet-sdk of your choice.
    const signer = TxSignerFactory.getSigner('ethereum');
    const signedTx = await signer.signTransaction(walletPrivateKey, unsignedTx);
    console.log('Signed transaction %s', signedTx);
}

stake().catch((error) => {
    console.error(error);
});
```

</TabItem>

<TabItem value="golang" label="Golang">

Create a new file named `stake.go` in the `staking-demo` directory. Then, copy and paste the code below into `stake.go`.

:::info
The signer used in the below example is for demonstration purposes only. In production, you would use a wallet SDK or signer of your choice to sign transactions.
Checkout the [Go signer lib](https://github.com/coinbase/staking-client-library-go/blob/main/pkg/signer/ethereum.go#L13-L49), which uses `go-ethereum` to sign unsigned transactions.
:::

```go
package main

import (
    "context"
    "fmt"

    "github.com/coinbase/staking-client-library-go/auth"
    "github.com/coinbase/staking-client-library-go/client"
    "github.com/coinbase/staking-client-library-go/client/options"
    api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
    "github.com/coinbase/staking-client-library-go/pkg/signer"
)

var (
    // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
    // highlight-start
    apiKeyName    = "YOUR_API_KEY_NAME"
    apiPrivateKey = "YOUR_API_PRIVATE_KEY"
    // highlight-end

    // Set your wallet details
    // highlight-start
    walletAddress    = "YOUR_WALLET_ADDRESS"
    walletPrivateKey = "YOUR_WALLET_PRIVATE_KEY"
    // highlight-end
)

func main() {
    ctx := context.Background()

    // Load the API key.
    apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
    if err != nil {
        fmt.Printf("error loading API key: %s\n", err.Error())
    }

    // Create a staking client.
    stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
    if err != nil {
        fmt.Printf("error instantiating staking client: %s", err.Error())
    }

    // Step 1 - Get an unsigned transaction corresponding to a
    // stake of 11 wei ETH from your wallet on network Holesky.	req := &api.CreateWorkflowRequest{
    req := &api.CreateWorkflowRequest{
        Workflow: &api.Workflow{
            Action: "protocols/ethereum_kiln/networks/holesky/actions/stake",
            StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
                EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
                    Parameters: &api.EthereumKilnStakingParameters_StakeParameters{
                        StakeParameters: &api.EthereumKilnStakeParameters{
                            StakerAddress: walletAddress,
                            Amount: &api.Amount{
                                Value:    "11",
                                Currency: "ETH",
                            },
                        },
                    },
                },
            },
        },
    }

    workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
    if err != nil {
        fmt.Printf("error creating workflow: %s", err.Error())
    }
    unsignedTx := workflow.Steps[workflow.GetCurrentStepId()].GetTxStepOutput().GetUnsignedTx()
    fmt.Printf("Unsigned transaction %s\n", unsignedTx)

    // Step 2 - Sign the unsigned tx with your wallet's private key.
    // Note: In production, this part would be performed via a wallet-sdk of your choice.
    ethSigner := signer.New("ethereum_kiln")
    signedTx, err := ethSigner.SignTransaction([]string{walletPrivateKey}, &signer.UnsignedTx{Data: []byte(unsignedTx)})
    if err != nil {
        fmt.Printf("error signing transaction: %s\n", err.Error())
    }
    fmt.Printf("Signed transaction %s\n", string(signedTx.Data))
}
```

Lastly, run the code:

```
go mod tidy
go run stake.go
```

</TabItem>
</Tabs>

<details>
    <summary>Expected output</summary>
    ```shell
    Unsigned transaction 02f3824268808502540be4008502b5ca0fb683061a8094a55416de5de61a0ac1aa8970a280e04388b1de4b0b843a4b66f1c0808080
    Signed transaction 0x02f873824268808502540be4008502b5ca0fb683061a8094a55416de5de61a0ac1aa8970a280e04388b1de4b0b843a4b66f1c080a0a6571b03fe02675f432d6e5874f7fa46755032b931320a65ca82c663bfb7c889a0603643fb7b1618dc5069a4b200fdd00acb35894cc63281e91a1747d04f15cc09
    ```
</details>

### 3. Submit Onchain

Take the signed transaction from the output of [Step 2](#2-create-and-sign-a-staking-transaction) and broadcast it via [this raw transaction broadcaster](https://holesky.etherscan.io/pushTx).

### 4. Verify Onchain

Once broadcasted, view your wallet on Etherscan to see your staking transaction onchain.

```text
https://holesky.etherscan.io/address/{YOUR_WALLET_ADDRESS}
```

On Holesky, transactions may take up to a minute to be confirmed by a block explorer.

## Next Steps

Congratulations! You've used the Coinbase Staking APIs to publish a staking transaction onchain.

There's so much more that the Coinbase Staking APIs are capable of. Now that you've completed an action for one protocol, checkout these guides for more onchain actions and protocols:

* [Partial ETH Staking](./protocols/partial-eth/staking.mdx)
* [Solana Staking](./protocols/solana/staking.mdx)



<!-- File: /Users/tinahe/docs/projects/staking/docs/welcome-legacy.mdx -->

---
title: "Welcome to Coinbase Staking"
sidebar_label: "Welcome (Legacy)"
slug: "welcome-legacy"
---

***

:::caution deprecating
On 31 August 2024, we will deprecate this legacy Staking API client. All existing functionality will be moved to our  [Programmatic Staking](./welcome.mdx). For new staking customers, we highly recommend starting with Programmatic Staking wherever possible.
:::

Welcome to Coinbase Staking documentation for builders!

Our self-custodial Staking API offers programmatic access to Coinbase's best-in-class staking validators and rewards data.



The **Coinbase Staking API** empowers you to deliver a fully-featured staking experience for your users with *one common interface* across protocols. We offer users access to various protocols with more being added on a regular basis.

| Protocol                         | Staking via API          | Rewards via API                             |
|:---------------------------------|:-------------------------|:--------------------------------------------|
| Partial ETH _(no stake minimum)_ | Live (mainnet & testnet) | Live                                        |
| SOL                              | Live (mainnet & testnet) | Live (Validator rewards)                    |
| ETH  _(32 ETH minimum)_          | Coming Soon              | Live (Validator rewards & staking balances) |
| ATOM                             | Coming Soon              | Live (Validator rewards & staking balances) |


## How to get started

1. [Create](https://coinbase.com/developer-platform) a new Coinbase Developer Platform account or [sign in](https://portal.cdp.coinbase.com) to your existing account.

2. View our [Quickstart guide](../quickstart) for the fastest way to make your first call

3. Explore our list of popular use cases for guidance on how to integrate

    - [Staking Partial ETH (ETH Staking without minimums)](./protocols/partial-eth/staking.mdx)

    - [Staking SOL](./protocols/solana/staking.mdx)

    - [Retrieving rewards data for staked SOL](./protocols/solana/rewards.mdx)



<!-- File: /Users/tinahe/docs/projects/staking/docs/staking-context.mdx -->

---
title: "Staking Context"
sidebar_label: "Staking Context"
slug: "staking-context"
---

Developers typically need a way to gate staking actions, for example, the "stake" button should be enabled only if the user has enough balance to stake,
or the "unstake" button should be enabled only if the user has enough staked balance etc.

This information can be unique for every protocol and can be very hard to get. To make accessing this data easier, we have introduced the concept of "staking context" that can be fetched via our `ViewStakingContext` endpoint.
The staking context provides a point-in-time snapshot of the user's wallet's staking state. It has enough data for you to make decisions on how to go about enable/disabling UI elements representing these actions.

Here's an example of a user's wallet's "staking context" for partial eth staking:

```json
{
  "address":  "0x87Bf57c3d7B211a100ee4d00dee08435130A62fA",
  "ethereumKilnStakingContextDetails":  {
    "ethereumBalance":  {
      "value":  "35802562641399502",
      "currency":  "ETH"
    },
    "integratorShareBalance":  {
      "value":  "22139201596840575",
      "currency":  "SHARES"
    },
    "integratorShareUnderlyingBalance":  {
      "value":  "22506410117065206",
      "currency":  "ETH"
    },
    "totalExitableEth":  {
      "value":  "3341944410096998",
      "currency":  "ETH"
    },
    "totalSharesPendingExit":  {
      "value":  "3284270185509832",
      "currency":  "SHARES"
    },
    "fulfillableShareCount":  {
      "value":  "3284270185509832",
      "currency":  "SHARES"
    }
  }
}
```

The above API response shows how much ETH the user has that can be then used to gate the "stake" actions as an example.



<!-- File: /Users/tinahe/docs/projects/staking/docs/workflows.mdx -->

---
title: "Workflows"
sidebar_label: "Workflows"
slug: "workflows"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import WorkflowLifecyclePng from '../assets/images/workflow-lifecycle.png';
import WhatIsWorkflowPng from '../assets/images/what-is-a-workflow.png';

The Orchestration API simplifies the management of staking transactions across various protocols with the help of its core feature: the <b><i>workflow</i></b>.
A workflow represents a comprehensive backend process designed to manage all tasks required to complete any given staking action end-to-end.  

This system is protocol-agnostic, meaning it can adapt to the specific needs of different protocols without requiring a need to introduce new interfaces every time we want to add a new protocol.

### What does a workflow look like

Here's an example of a workflow created in order to stake partial eth (amounts less than 32 eth) using the Kiln integration:

<img src={WhatIsWorkflowPng} alt="What's a workflow" />

### How do we start a workflow

Every staking action is represented by a Workflow. To start a workflow, you need to only provide the following information:

1. *Action name*: The action you want to perform, and the protocol, network you want to do it on. Ex: `protocols/ethereum_kiln/networks/holesky/actions/stake` represents the action of "staking" "eth" on the "holesky" network.

2. *Staking parameters*: The parameters required to perform the action. Ex: For partial eth staking, you need to provide the wallet address you want to stake from, and the amount of eth you want to stake. The details of the parameters required for each action are provided in the protocol specific guides.

Good news - we have 2 clients (Typescript & Go) which make the process of starting a workflow even simpler. Here's an example of what that looks like:

import GoLangContent from './code_languages/go.mdx';
import TsLangContent from './code_languages/ts.mdx';

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>

### How to interact with a workflow

A workflow is designed to consume the staking intent once and from there on independently manage the entire lifecycle of the staking transaction. The only time the workflow needs intervention is when it needs customer input, which typically is when we want a customer to sign and broadcast our unsigned txs.

Here's a rough algorithm of what a typical interaction with a workflow can look like:

1. Create a workflow by providing the action name and staking parameters.

2. Poll and get the workflow to know what the current workflow state is.

    1. When the workflow state changes to `WAITING_FOR_EXT_BROADCAST`, you can read and consume the unsigned tx from the step currently being executed.

    2. If the unsigned tx is as per your needs, you can at this point sign and broadcast it.

    3. The workflow has ways of inferring whether our unsigned tx was indeed signed and broadcasted. If it was, the workflow will mark the current step has completed and move to the next step.

3. When there are no more steps left to execute, the workflow will move to the completed state.

Here's an example of a hypothetical workflow comprising 3 steps that are executed serially. The only time the workflow pauses is when it needs the customer to sign and broadcast the unsigned tx from step 1 - rest of the steps are executed independently by the workflow itself.

<img src={WorkflowLifecyclePng} alt="Workflow Lifecycle" />

:::info
The Orchestration API as of today, expects the customer to sign and broadcast the unsigned txs generated by the API. If you are a developer, who is interested in broadcasting tx capabilities and would like to use an API developed by us then do reach out to us on our [staking discord channel](https://discord.com/channels/1220414409550336183/1220465786750242836).
:::

### Workflow States

The workflow state is a high-level state that describes the current state of the workflow. The workflow state is different from the individual step state, which describes the state of the step that the workflow is currently executing.

| State                           | Definition                                                                         | Terminal State |
|---------------------------------|------------------------------------------------------------------------------------|----------------|
| STATE_IN_PROGRESS               | The workflow is making progress and currently does not need any inputs             | False          |
| STATE_WAITING_FOR_EXT_BROADCAST | The workflow is waiting for our generated unsigned tx to be signed and broadcasted | False          |
| STATE_COMPLETED                 | The workflow has successfully completed                                            | True           |
| STATE_FAILED                    | The workflow has failed at a step - check step details for error                   | True           |


### Workflow Steps

Workflows consist of steps, each representing a distinct task that the API automates to facilitate the staking action. These steps can be of different types representing the various tasks that need to be done to complete a staking action. Here are some examples of the types of steps that can be found in a workflow:

import TxStepContent from './step_types/tx_step.mdx';
import WaitStepContent from './step_types/wait_step.mdx';
import ProvisionInfraContent from './step_types/provision_infra_step.mdx';

<Tabs>
    <TabItem value="tx-step" label="Tx Step" default>
        <TxStepContent />
    </TabItem>
    <TabItem value="wait-step" label="Wait Step">
        <WaitStepContent />
    </TabItem>
    <TabItem value="provision-infra-step" label="Provision Infra Step">
        <ProvisionInfraContent />
    </TabItem>
</Tabs>

<details>
  <summary>End-to-End Staking Example</summary>

:::info
While this example deals with an individual person wanting to stake, the Staking API is designed in a way for
developers to build staking into their applications.
:::

Now that we have explored what Workflows are, how to start them and how to go about gating staking actions, we can look into a complete end-to-end staking example.

*Case Study*: User "Alice" loves Ethereum and would like to do her part of making the network stronger by staking some ETH. Staking makes the network happy and
also give her some rewards in return. But she realizes that as of today (May 2023) Ethereum only allows multiples of 32 ETH to be staked.
She unfortunately has only 15 ETH in her wallet but would like to be able to stake some part of that. But there's good news - she finds that [Coinbase in partnership with Kiln](https://www.coinbase.com/blog/coinbase-cloud-and-kiln-unlock-native-eth-staking)
have launched the `Partial ETH Staking` solution that allows her to stake any amount of ETH even lesser than 32 ETH. She's excited and wants to get started.
She finds that Coinbase has a Staking API precisely for this that she would like to leverage. She loves Typescript and finds that Coinbase supports a [staking client](https://github.com/coinbase/staking-client-library-ts) for it.

#### Step 1: Set up the Staking Client

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);
```

#### Step 2: Fetch Staking Context

Alice first needs to fetch her staking context to see if she has enough ETH to stake.
Although in this case, she already knows she has 15 ETH, but while trying to programmatically implement an e2e staking action,
it's always nice to have pre-checks and make sure all is good. For example, if she was trying to unstake her ETH,
she wouldn't know exactly how much her ETH has grown and would need some API to tell her, her current total staked balance.

```ts
stakingContext = await client.Ethereum.viewStakingContext('alice-wallet-address', 'holesky');
````

She finds that she has 15 ETH in her wallet and is willing to stake 10 ETH from it.

#### Step 3: Start a "Stake" Workflow

Alice starts a workflow to stake 10 ETH.

```ts
workflow = await client.Ethereum.stake('holesky', 'alice-wallet-address', '10000000000000000000');
```

#### Step 3: Poll Workflow until workflow state is `WAITING_FOR_EXT_BROADCAST` or `COMPLETED`

```ts
while (true) {
  workflow = await client.getWorkflow(workflowId);

  if (workflowWaitingForExternalBroadcast(workflow)) {
    unsignedTx = workflow.steps![workflow.currentStepId!].txStepOutput?.unsignedTx || '';
    console.log('Please sign and broadcast this unsigned tx %s ...', unsignedTx);
    break;
  } else if (workflowHasFinished(workflow)) {
    console.log('Workflow completed with state %s ...', workflow.state);
    break;
  }

  await new Promise((resolve) => setTimeout(resolve, 1000)); // sleep for 1 second
}
```

#### Step 4: Sign and Broadcast the unsigned tx

Alice signs and broadcasts the unsigned tx corresponding to the intent "stake 10 ETH" provided by the workflow.

#### Step 5: Workflow reaches "COMPLETED" state

Workflow marks the 1st tx step state as `FINALIZED` after it finds that Alice's broadcasted tx has landed on chain and
is greater than a safe finalization depth.

Since there are no more steps to execute, the workflow reaches the "COMPLETED" state and the end result is that Alice's 10 ETH is successfully staked.

At this point, Alice can sit back, relax and watch her staked ETH grow and also earn rewards in the process.

</details>



<!-- File: /Users/tinahe/docs/projects/staking/docs/rewards-data.mdx -->

---
title: "Rewards Data"
sidebar_label: "Rewards Data"
slug: "rewards"
---

:::info
We are actively working to expand our support for Rewards (i.e. onchain
earned rewards) and Stakes (i.e. an address's staking balance at a point in
time) across protocols, reward types, addresses, aggregations, and more.
:::

The Coinbase Staking API provides historical rewards and staking balance data across protocols.

## Rewards

| Protocol          | Reward Type      | Time Range               | Addresses                         | Aggregations |
|-------------------|------------------|--------------------------|-----------------------------------|--------------|
| Partial ETH       | All rewards      | October 3rd, 2023 Onward | All                    | Daily        | 
| Ethereum (32 ETH) | All rewards      | January 1st, 2024 Onward | All validators                    | Daily        |
| Solana            | Staking issuance | January 1st, 2024 Onward | All validators, select delegators | Epoch        |
| Cosmos            | Staking issuance | January 1st, 2024 Onward | All validators, select delegators | Daily        |

## Staking Balances

| Protocol        | Time Period   | Addresses                         |
|-----------------|---------------|-----------------------------------|
| Native Ethereum | Past 3 months | All validators                    |
| Solana          | Past 3 months | All validators, select delegators |

### Indexing Support

The Coinbase Staking API backend indexes all validators and select delegators for our Rewards and
Stake endpoints.



<!-- File: /Users/tinahe/docs/projects/staking/docs/welcome.mdx -->

---
title: Welcome to Programmatic Staking
sidebar_label: Welcome
slug: welcome
---

Welcome to **Coinbase Programmatic Staking** developer documentation! Our SDK supports programmatic staking across multiple networks for self-custodial builders.

Whether you're a small startup or larger enterprise, use Coinbase Programmatic Staking to create rich staking experiences for your users that allow them to earn rewards while supporting blockchain security.

## Key features

* **Easy to use** - start building solutions with just three lines of code with multi-network support through a single endpoint.
* **Powerful reporting** - we offer rich rewards data across our networks, enabling you to build out rewards reporting and insights for your users.
* **Multi-language SDK** - we offer developer focussed solutions with SDKs available in TypeScript, Ruby and with Golang coming soon.

## Supported Networks

1. [**Shared ETH Staking**](./networks/eth-shared/overview) - Stake any amount of ETH using a shared validator
2. [**Dedicated ETH Staking**](./networks/eth-dedicated/overview) - Stake increments of 32 ETH using your own dedicated validator
3. [**SOL Staking**](./networks/sol/overview) - Stake any amount of SOL to a Solana validator.

Reach out to us on [Discord](https://discord.com/channels/1220414409550336183/1220465786750242836) to discuss which staking model fits your use-case.

:::info
We are adding staking support for several more networks including Cardano and Polkadot. Get in touch in our [Discord Channel](https://discord.com/channels/1220414409550336183/1220465786750242836) - we love feedback.
:::



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/eth-dedicated/overview.mdx -->

---
title: Dedicated ETH Staking (32 ETH Minimum)
sidebar_label: Overview
slug: overview
---

Dedicated ETH Staking enables staking in exact increments of 32 ETH. Dedicated ETH Staking provides access to reserved ETH validators running in Coinbase's best-in-class staking infrastructure. This solution requires developers to **stake in 32 ETH increments**. Each validator is reserved for your staking purpose - there is no commingling of funds with other Coinbase Staking customers.

This approach ensures **end-users are always in custody of their funds**.

### Who this solution is for

* Custodians with users who will be staking larger amounts of ETH above the typical 32 ETH deposit minimum.
* Developers who do not want to see their funds commingled with other customers.
* Developers looking for higher ETH yields.

### Validator details

:::info
Dedicated ETH Staking is offered with a Standard Commission fee of 8% billed via Coinbase Developer Platform.
:::

### Rewards scope

| Data Type                   | Network      | Details          | Historical Depth | Addresses                           | Aggregations |
|-----------------------------|--------------|------------------|------------------|-------------------------------------|--------------|
| Historical Rewards          | Mainnet Only | All Reward Types | Jan 1st, 2024    | All Addresses (Validator Addresses) | Daily        |
| Historical Staking Balances | Mainnet Only |                  | Jan 1st, 2024    | All Addresses (Validator Addresses) | Daily        |



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/eth-dedicated/usage.mdx -->

---
title: Integrating Dedicated ETH Staking
sidebar_label: Usage
slug: usage
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Dedicated ETH Staking must use increments of 32 ETH. You will be staking directly to ETH validators that the API will stand up on your behalf.

:::tip
See the [quickstart](../../quickstart.mdx) to familiarize yourself with Coinbase Programmatic Staking and basic usage.
:::

***

## External Address

The external address model is an address model where the private keys are **not** managed by the Coinbase SDK. The developer would be responsible for "bringing their own wallet". All signing operations must be completed off-platform. Read more in the [external addresses documentation](../../../../mpc-wallet/docs/addresses#external-addresses).

### Stake

To stake, ensure that the address contains an increment of 32 ETH plus additional ETH to cover transaction fees. The example below illustrates how to stake from an [external address](../../../../mpc-wallet/docs/addresses#external-addresses).

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // Find out how much ETH is available to stake.
        let stakeableBalance = await address.stakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Build a stake operation for an amount <= stakeableBalance, and in multiples of 32. In this case, 64 ETH.
        // This step will trigger the provisioning of validator infrastructure for your dedicated usage.
        // Infrastructure setup times vary with the number of validators. For 30 validators (960 ETH), it can take up to 5 minutes.
        let stakingOperation = await address.buildStakeOperation(64, Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Native ETH staking involves setting up infrastructure, which can take time.
        // Example of polling the stake operation status until it reaches a terminal state using the SDK.
        await stakingOperation.wait();
        ```

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # Get the amount of ETH available to stake.
        stakeable_balance = address.stakeable_balance(:eth, mode: :native)

        # Build a stake operation for an amount <= stakeable_balance, and in multiples of 32. In this case, 64 ETH.
        # This step will trigger the provisioning of validator infrastructure for your dedicated usage.
        # Infrastructure setup times vary with the number of validators. For 30 validators (960 ETH), it can take up to 5 minutes.
        staking_operation = address.build_stake_operation(64, :eth, mode: :native)

        # Native ETH staking involves setting up infrastructure, which can take time.
        # Example of polling the stake operation status until it reaches a terminal state using the SDK.
        staking_operation.wait!
        ```

        Refer to the [ExternalAddress docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Create a new external address on the `ethereum-holesky` network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Find out how much ETH is available to stake.
        stakeableBalance, err := client.GetStakeableBalance(
            ctx,
            coinbase.Eth,
            address,
            coinbase.WithStakingBalanceMode(coinbase.StakingOperationModeNative),
        )
        if err != nil {
            log.Fatal(err)
        }

        // Build a stake operation for an amount <= stakeableBalance, and in multiples of 32. In this case, 32 ETH.
        stakingOperation, err := client.BuildStakeOperation(
            ctx,
            big.NewFloat(32.00),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModeNative),
        )
        if err != nil {
            log.Fatalf("error building staking operation: %v", err)
        }

        // Native ETH staking involves setting up infrastructure, which can take time.
        // Example of polling the stake operation status until it reaches a terminal state using the SDK.
        stakingOperation, err = client.Wait(ctx, stakingOperation)
        if err != nil {
            log.Fatalf("error waiting for staking operation: %v", err)
        }
        ```

        Refer to the [BuildStakeOperation docs](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildStakeOperation)
    </TabItem>
</Tabs>

Once the stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an example using Ethers.js.

### Unstake

Unstaking on native ETH requires a [voluntary exit message](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#signedvoluntaryexit) to be signed by the validator and submitted to the network to initiate the unstaking process. For external addresses, this can be done two ways:

* **[Coinbase managed unstake](#coinbase-managed-unstake)** _(recommended)_ : You can request Coinbase to begin unstaking your ETH. Coinbase will build a signed voluntary exit message and broadcast it to the network on your behalf.

* **[User managed unstake](#user-managed-unstake)**: Coinbase will pre-sign the voluntary exit message and provide it to you to broadcast whenever you decide. Pre-signed exit messages must be [broadcasted directly to the beacon chain](#broadcasting-exit-messages).

#### Coinbase Managed Unstake

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // To know how much ETH balance across all your validators is available for staking
        // you can use the `unstakeableBalance` method as shown below.
        // Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        // not your address. We surface the unstakeable balance on the address object for simplicity.
        let unstakeableBalance = await address.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        // This behind the scenes will identify validators to be exited, generate a voluntary exit message per validator,
        // sign it with the validator's private key and broadcast them for you.
        let stakingOperation = await address.buildUnstakeOperation(32, Coinbase.assets.Eth, StakeOptionsMode.NATIVE, {"immediate": "true"});

        // Immediate native eth unstaking is completely handled by the API with no user action needed.
        // Example of polling the unstake operation status until it reaches a terminal state using the SDK.
        await stakingOperation.wait();
        ```

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # To know how much ETH balance across all your validators is available for staking
        # you can use the `unstakeableBalance` method as shown below.
        # Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        # not your address. We surface the unstakeable balance on the address object for simplicity.
        unstakeable_balance = address.unstakeable_balance(:eth, mode: :native)

        # Build an unstake operation for an amount <= unstakeable_balance, and in multiples of 32. In this case, 32 ETH.
        # This behind the scenes will identify validators to be exited, generate a voluntary exit message per validator,
        # sign it with the validator's private key and broadcast them for you.
        staking_operation = address.build_unstake_operation(32, :eth, mode: :native, options: {"immediate": "true"})

        # Immediate native eth unstaking is completely handled by the API with no user action needed.
        # Example of polling the unstake operation status until it reaches a terminal state using the SDK.
        staking_operation.wait!
        ```

        Refer to the [ExternalAddress docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go">
        ```go
        // Create a new external address on the `ethereum-holesky` network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Find out how much ETH is available to unstake.
        unstakeableBalance, err := client.GetUnstakeableBalance(
            ctx,
            coinbase.Eth,
            address,
            coinbase.WithStakingBalanceMode(coinbase.StakingOperationModeNative),
        )
        if err != nil {
            log.Fatal(err)
        }

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        stakingOperation, err := client.BuildUnstakeOperation(
            ctx,
            big.NewFloat(32.00),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModeNative),
            coinbase.WithStakingOperationOption("immediate", "true"),
        )
        if err != nil {
            log.Fatalf("error building unstaking operation: %v", err)
        }

        // Immediate native eth unstaking is completely handled by the API with no user action needed.
        // Example of polling the unstake operation status until it reaches a terminal state using the SDK.
        stakingOperation, err = client.Wait(ctx, stakingOperation)
        if err != nil {
            log.Fatalf("error waiting for staking operation: %v", err)
        }
        ```

        Refer to the [BuildUnstakeOperation docs](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildUnstakeOperation)
    </TabItem>
</Tabs>

Once the unstake operation has completed successfully, congrats you've just exited a validator.

Refer to the [View Validator Information](#view-validator-information) section to monitor your validator status.
When it changes to `WITHDRAWAL_COMPLETE`, your funds should be available in the `withdrawal_address` set during staking.

#### User Managed Unstake

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // To know how much ETH balance across all your validators is available for staking
        // you can use the `unstakeableBalance` method as shown below.
        // Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        // not your address. We surface the unstakeable balance on the address object for simplicity.
        let unstakeableBalance = await address.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        // This behind the scenes will identify validators to be exited, generate a voluntary exit message per validator,
        // and relay them back to be broadcasted appropriately to the Ethereum network.
        let stakingOperation = await address.buildUnstakeOperation(32, Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Native eth unstaking can take some time as we build the voluntary exit message and have it signed by the validator.
        // Example of polling the unstake operation status until it reaches a terminal state using the SDK.
        await stakingOperation.wait();
        ```

        After unstaking, voluntary exit messages can be read and stored on your end and broadcasted to the network whenever you want to initiate the unstaking process. Refer to the [Broadcasting Exit Messages](#broadcasting-exit-messages) section for an example.

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # To know how much ETH balance across all your validators is available for staking
        # you can use the `unstakeableBalance` method as shown below.
        # Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        # not your address. We surface the unstakeable balance on the address object for simplicity.
        unstakeable_balance = address.unstakeable_balance(:eth, mode: :native)

        # Build an unstake operation for an amount <= unstakeable_balance, and in multiples of 32. In this case, 32 ETH.
        # This behind the scenes will identify validators to be exited, generate a voluntary exit message per validator,
        # and relay them back to be broadcasted appropriately to the Ethereum network.
        staking_operation = address.build_unstake_operation(32, :eth, mode: :native)

        # Native eth unstaking can take some time as we build the voluntary exit message and have it signed by the validator.
        # Example of polling the unstake operation status until it reaches a terminal state using the SDK.
        staking_operation.wait!
        ```

        After unstaking, voluntary exit messages can be read and stored on your end and broadcasted to the network whenever you want to initiate the unstaking process. Refer to the [Broadcasting Exit Messages](#broadcasting-exit-messages) section for an example.

        Refer to the [ExternalAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go">
        ```go
        // Create a new external address on the `ethereum-holesky` network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Find out how much ETH is available to unstake.
        unstakeableBalance, err := client.GetUnstakeableBalance(
            ctx,
            coinbase.Eth,
            address,
            coinbase.WithStakingBalanceMode(coinbase.StakingOperationModeNative),
        )
        if err != nil {
            log.Fatal(err)
        }

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        stakingOperation, err := client.BuildUnstakeOperation(
            ctx,
            big.NewFloat(32.00),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModeNative),
            coinbase.WithStakingOperationOption("immediate", "true"),
        )
        if err != nil {
            log.Fatalf("error building unstaking operation: %v", err)
        }

        // Native eth unstaking can take some time as we build the voluntary exit message and have it signed by the validator.
        // Example of polling the unstake operation status until it reaches a terminal state using the SDK.

        if err != nil {
            log.Fatalf("error waiting for staking operation: %v", err)
        }
        ```

        After unstaking, voluntary exit messages can be read and stored on your end and broadcasted to the network whenever you want to initiate the unstaking process. Refer to the [Broadcasting Exit Messages](#broadcasting-exit-messages) section for an example.
        stakingOperation, err = client.Wait(ctx, stakingOperation)

            Refer to the [BuildUnstakeOperation docs](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildUnstakeOperation)
    </TabItem>
</Tabs>


## Wallet Address

The wallet address model is an address model where the private keys are managed by the Coinbase SDK. This means that the SDK can sign transactions on behalf of the user. In production, it's recommend to use a server-signer for increased security. Find out more in the [wallet addresses section](../../../../mpc-wallet/docs/addresses#wallet-addresses).

The example below illustrates how to stake from a [wallet address](../../../../mpc-wallet/docs/addresses#wallet-addresses).

### Stake

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // A newly created wallet will have no balance. Use wallet.getDefaultAddress()
        // to retrieve the default address and fund it with the required ETH.

        // Find out how much ETH is available to stake.
        let stakeableBalance = await wallet.stakeableBalance(Coinbase.assets.Eth);

        // Build a stake operation for an amount <= stakeableBalance, and in multiples of 32. In this case, 32 ETH.
        let stakingOperation = await wallet.createStake(32, Coinbase.assets.Eth, StakeOptionsMode.NATIVE);
        ```
        
        Refer to the [WalletAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # A newly created wallet will have no balance. Use wallet.default_address
        # to retrieve the default address and fund it with the required ETH.

        # Get the amount of ETH available to stake.
        stakeable_balance = wallet.stakeable_balance(:eth, mode: :native)

        # Build a stake operation for an amount <= stakeable_balance, and in multiples of 32. In this case, 32 ETH.
        staking_operation = wallet.stake(32, :eth, mode: :native)
        ```

        Refer to the [WalletAddress docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.
    </TabItem>
</Tabs>

Once the stake operation has completed successfully, you've staked ETH to a dedicated validator!

### Unstake

Unstaking on native ETH requires a [voluntary exit message](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#signedvoluntaryexit) to be signed by the validator and submitted to the network to initiate the unstaking process. For wallet addresses, this can be done two ways:

* **[Coinbase managed unstake](#coinbase-managed-unstake)** _(recommended)_ : You can request Coinbase to begin unstaking your ETH. Coinbase will build a signed voluntary exit message and broadcast it to the network on your behalf.

* **[User managed unstake](#user-managed-unstake)**: Coinbase will pre-sign the voluntary exit message and provide it to you to broadcast whenever you decide. Pre-signed exit messages must be [broadcasted directly to the beacon chain](#broadcasting-exit-messages).

#### Coinbase Managed Unstake

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
            Refer to the [WalletAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.

        ```typescript
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // To know how much ETH balance across all your validators is available for staking
        // you can use the `unstakeableBalance` method as shown below.
        // Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        // not your wallet. We surface the unstakeable balance on the wallet object for simplicity.
        let unstakeableBalance = await wallet.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        let stakingOperation = await wallet.createUnstake(32, Coinbase.assets.Eth, StakeOptionsMode.NATIVE, {"immediate": "true"});
        ```

        Once the unstake operation has completed successfully, congrats you've just exited a validator.

        Refer to the [View Validator Information](#view-validator-information) section to monitor your validator status.
        When it changes to `WITHDRAWAL_COMPLETE`, your funds should be available in the `withdrawal_address` set during staking.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
            Refer to the [WalletAddress docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.

        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # To know how much ETH balance across all your validators is available for staking
        # you can use the `unstakeableBalance` method as shown below.
        # Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        # not your wallet. We surface the unstakeable balance on the wallet object for simplicity.
        unstakeable_balance = wallet.unstakeable_balance(:eth, mode: :native)

        # Build an unstake operation for an amount <= unstakeable_balance, and in multiples of 32. In this case, 32 ETH.
        staking_operation = wallet.unstake(32, :eth, mode: :native, options: {"immediate": "true"})
        ```

        Once the unstake operation has completed successfully, congrats you've just exited a validator.

        Refer to the [View Validator Information](#view-validator-information) section to monitor your validator status.
        When it changes to `WITHDRAWAL_COMPLETE`, your funds should be available in the `withdrawal_address` set during staking.
    </TabItem>
</Tabs>

#### User Managed Unstake

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
            Refer to the [WalletAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.

        ```typescript
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // To know how much ETH balance across all your validators is available for staking
        // you can use the `unstakeableBalance` method as shown below.
        // Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        // not your wallet. We surface the unstakeable balance on the wallet object for simplicity.
        let unstakeableBalance = await wallet.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.NATIVE);

        // Build an unstake operation for an amount <= unstakeableBalance, and in multiples of 32. In this case, 32 ETH.
        let stakingOperation = await wallet.createUnstake(32, Coinbase.assets.Eth, StakeOptionsMode.NATIVE);
        ```

        After unstaking, voluntary exit messages can be read and stored on your end and broadcasted to the network whenever you want to initiate the unstaking process. Refer to the [Broadcasting Exit Messages](#broadcasting-exit-messages) section for an example.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
            Refer to the [WalletAddress docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.

        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # To know how much ETH balance across all your validators is available for staking
        # you can use the `unstakeableBalance` method as shown below.
        # Note: For Dedicated ETH Staking, the unstakeable balance depends on the validators owned by the CDP account,
        # not your wallet. We surface the unstakeable balance on the wallet object for simplicity.
        unstakeable_balance = wallet.unstakeable_balance(:eth, mode: :native)

        # Build an unstake operation for an amount <= unstakeable_balance, and in multiples of 32. In this case, 32 ETH.
        staking_operation = wallet.unstake(32, :eth, mode: :native)
        ```

        After unstaking, voluntary exit messages can be read and stored on your end and broadcasted to the network whenever you want to initiate the unstaking process. Refer to the [Broadcasting Exit Messages](#broadcasting-exit-messages) section for an example.
    </TabItem>
</Tabs>

***

The functionality below applies to both External and wallet addresses.

## Broadcasting Exit Messages

The example below broadcasts pre-signed voluntary exit messages surfaced during an unstake process. Ethereum validator exit messages are special transaction types which are pre-signed by the validator keys and must be broadcast directly to the consensus layer.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        stakingOperation.getSignedVoluntaryExitMessages().forEach(async signedVoluntaryExitMessage => {
            let resp = await axios.post("HOLESKY_RPC_URL/eth/v1/beacon/pool/voluntary_exits", signedVoluntaryExitMessage)
            console.log(resp.status);
        });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        uri = URI.parse("HOLESKY_RPC_URL/eth/v1/beacon/pool/voluntary_exits")
        http_client = Net::HTTP.new(uri.host, uri.port)
        http_client.use_ssl = (uri.scheme == 'https')
        request = Net::HTTP::Post.new(uri)
        request.content_type = "application/json"

        staking_operation.signed_voluntary_exit_messages.each do |message|
            request.body = message
            resp = http_client.request(request)
            puts resp.code
        end
        ```
    </TabItem>
    <TabItem value="Go" label="Go">
        ```go
          exitMessages, err := stakingOperation.GetSignedVoluntaryExitMessages()
          if err != nil {
            log.Fatalf("error getting signed voluntary exit messages: %v", err)
          }

          for _, exitMessage := range exitMessages {
            // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
            url := fmt.Sprintf("%s/eth/v1/beacon/pool/voluntary_exits", rpcURL)

            resp, err := http.Post(url, "application/json", bytes.NewBuffer([]byte(exitMessage)))
            if err != nil {
              log.Fatalf("error sending exit message: %v", err)
            }
            defer resp.Body.Close()

            log.Printf("Response status: %s\n", resp.Status)
          }
        ```
    </TabItem>
</Tabs>

## Signing and Broadcasting Transactions

The example below signs and broadcasts transactions surfaced via the staking operation resource. These transaction are traditional EIP-1159 transactions that can be signed and broadcasted to the execution layer via a normal transaction flow.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Load your wallet's private key from which you initiated the above stake operation.
        const wallet = new ethers.Wallet("YOUR_WALLET_PRIVATE_KEY");

        // Sign the transactions within staking operation resource with your wallet.
        await stakingOperation.sign(wallet);

        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        const provider = new ethers.JsonRpcProvider("HOLESKY_RPC_URL");

        // Broadcast each of the signed transactions to the network.
        stakingOperation.getTransactions().forEach(async tx => {
            let resp = await provider.broadcastTransaction(tx.getSignedPayload()!);
            console.log(resp);
        });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Load your wallet's private key from which you initiated the above stake operation.
        private_key = Eth::Key.new(priv: "YOUR_WALLET_PRIVATE_KEY")

        # Sign the transactions within staking operation resource with your private key.
        staking_operation.sign(private_key)

        # For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        rpc = Jimson::Client.new("HOLESKY_RPC_URL")

        # Broadcast each of the signed transactions to the network.
        staking_operation.transactions.each do |transaction|
            resp = rpc.eth_sendRawTransaction "0x"+transaction.raw.hex
            puts "Broadcasted tx hash #{resp}"
        end
        ```
    </TabItem>
    <TabItem value="Go" label="Go">
        ```go
        // Load your wallet's private key from which you initiated the above stake operation.
        key, err := crypto.HexToECDSA("YOUR_WALLET_PRIVATE_KEY")
        if err != nil {
            log.Fatal(err)
        }

        // Sign the transactions within staking operation resource with your private key.
        err = stakingOperation.Sign(key)
        if err != nil {
            log.Fatal(err)
        }

        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        ethClient, err := ethclient.Dial("HOLESKY_RPC_URL")
        if err != nil {
            log.Fatal(err)
        }

        // Broadcast each of the signed transactions to the network.
        for _, transaction := range stakingOperation.Transactions() {
            if err := ethClient.SendTransaction(context.Background(), transaction.Raw()); err != nil {
                log.Fatal(err)
            }

            log.Printf("Broadcasted transaction hash: %s", transaction.Raw().Hash().Hex())
        }
        ```
    </TabItem>
</Tabs>


## View Staking Rewards

After staking an asset, you can view your staking rewards. This allows you to track the rewards earned over time from your staked assets.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        **SDK Documentation**

        Refer to the [StakingReward docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_staking_reward.StakingReward.html) for a full list of supported methods.

        Look up staking rewards for a list of addresses.

        ```typescript
        import { Coinbase, StakingReward } from "@coinbase/coinbase-sdk";

        let now = new Date();
        let tenDaysAgo = new Date();
        tenDaysAgo.setDate(now.getDate() - 10);

        let rewards = await StakingReward.list(
            Coinbase.networks.EthereumMainnet, Coinbase.assets.Eth,
            ["VALIDATOR_ADDRESS1", "VALIDATOR_ADDRESS2"],
            tenDaysAgo.toISOString(), now.toISOString(),
        );

        // Loop through the rewards and print each staking reward
        rewards.forEach(reward => console.log(reward.toString()));
        ```
        View the USD value of rewards including conversion price and time.

        ```typescript
        // Loop through the rewards and print each staking reward's USD conversion information
        rewards.forEach(reward => {
            console.log(
                `USD value: ${reward.usdValue()},
                Conversion price: ${reward.conversionPrice().toString()},
                Conversion time: ${reward.conversionTime().toISOString()}`,
            );
        });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        Refer to the [StakingReward documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/StakingReward.html) for a full list of supported methods.

        Look up staking rewards for a list of addresses.

        ```ruby
        rewards = Coinbase::StakingReward.list(
            :ethereum_mainnet, :eth,
            ["VALIDATOR_ADDRESS1", "VALIDATOR_ADDRESS2"],
            start_time: Time.now - (10 * 24 * 60 * 60),
            end_time: Time.now,
        )

        # Loop through the enumerator and print each staking reward
        rewards.each do |reward| puts "#{reward}" end
        ```
        View the USD value of rewards including conversion price and time.

        ```ruby
        # Loop through the enumerator and print the USD value of rewards including conversion price and time
        rewards.each do |reward|
        puts "USD value: #{reward.usd_value}, " +
            "Conversion price: #{reward.usd_conversion_price}, " +
            "Conversion time: #{reward.usd_conversion_time}"
        end
        ```
    </TabItem>
    <TabItem value="Go" label="Go">
        **SDK Documentation**

        Look up staking rewards for a list of addresses.

        ```go
        rewards, err := client.ListStakingRewards(
            context.Background(),
            coinbase.Eth,
            []coinbase.Address{*validator1, *validator2},
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
            api.STAKINGREWARDFORMAT_USD,
        )
        if err != nil {
            log.Fatal(err)
        }

        // Loop through the rewards and print each staking reward.
        for _, reward := range rewards {
            log.Printf("Staking reward: %s", reward.ToString())
        }
        ```
    </TabItem>
</Tabs>

## View Historical Staking Balances

Detailed information about the historical staking balances for given validator address, including bonded and unbonded stakes.
- **Bonded Stakes**: The total amount of stake that is actively earning rewards to this address. Pending active stake is not included.
- **Unbonded Balance**: This amount includes any ETH balance that is under the control of the wallet address but is not actively staked.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        **SDK Documentation**

        Refer to the [StakingBalance docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_staking_balance.StakingBalance.html) for a full list of supported methods.

        Look up staking balances for an address.

        ```typescript
        import { Coinbase, StakingBalance } from "@coinbase/coinbase-sdk";

        let now = new Date();
        let tenDaysAgo = new Date();
        tenDaysAgo.setDate(now.getDate() - 10);

        let stakingBalances = await StakingBalance.list(
            Coinbase.networks.EthereumMainnet, Coinbase.assets.Eth,
            "VALIDATOR_ADDRESS",
            tenDaysAgo.toISOString(), now.toISOString(),
        );

        // Loop through the historical staking balances and print each balance
        stakingBalances.forEach(stakingBalance => console.log(stakingBalance.toString()));
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        Refer to the [StakingBalance documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/StakingBalance) for a full list of supported methods.

        Look up historical staking balances for an address.

        ```ruby
        stakingBalances = Coinbase::StakingBalance.list(
            :ethereum_mainnet, :eth,
            "VALIDATOR_ADDRESS",
            start_time: Time.now - (10 * 24 * 60 * 60),
            end_time: Time.now,
        )

        # Loop through the enumerator and print each staking balance
        stakingBalances.each do |stakingBalance| puts "#{stakingBalance}" end
        ```
    </TabItem>
    <TabItem value="Go" label="Go">
        **SDK Documentation**

        Refer to the [ListHistoricalStakingBalances documentation](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.ListHistoricalStakingRewards) for a full list of supported methods.

        Look up historical staking balances for an address.

        ```go
        address = coinbase.NewExternalAddress(
          coinbase.EthereumMainnet,
          "VALIDATOR_ADDRESS",
        )
        stakingBalances, err := client.ListHistoricalStakingBalances(
          ctx,
          coinbase.Eth,
          address,
          time.Now().Add(-10*24*time.Hour),
          time.Now(),
        )
        if err != nil {
          log.Fatalf("error listing staking balances: %v", err)
        }

        // Loop through the staking balances and print
        for _, stakingBalance := range stakingBalances {
          fmt.Println(stakingBalance.String())
        }
        ```
    </TabItem>
</Tabs>


## View Validator Information

Detailed information is available for any validators that you've created. The validator status (i.e. `provisioned`, `active`, etc) is available in the response and is printed to stdout in the example below.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Get the validators that you've provisioned for staking.
        const validators = await Validator.list(Coinbase.networks.EthereumHolesky, Coinbase.assets.Eth);

        // Loop through the validators and print each validator
        validators.forEach(validator => {
            console.log(validator.toString());
        });
        ```

        The Validator object documentation is available [here](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_validator.Validator.html)
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Get the validators that you've provisioned for staking.
        validators = Coinbase::Validator.list("ethereum-holesky", :eth)

        # Loop through the validators and print each validator
        validators.each do |validator| puts validator end
        ```

        The Validator object documentation is available [here](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Validator.html)
    </TabItem>
    <TabItem value="Go" label="Go">
        ```go
        // Get the validators that you've provisioned for staking.
        validators := client.ListValidator(ctx, coinbase.EthereumHolesky, coinbase.Eth)

        // Loop through the validators and print each validator
        for _, validator := range validators {
          fmt.Println(validator.String())
        }
        ```
        
        The ListValidators documentation is available [here](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.ListValidators)
    </TabItem>
</Tabs>

<details>
  <summary>Example output</summary>
    Your validators will be listed with their respective statuses.

    ```text
    Id: 0x984209f61e2507de65de2b0b08ca9cb02c66fb5deab5eb780bfe298b4870e5babd942624c9028cb7820577a6f52ac2d2, Status: provisioned
    Id: 0xa3fc791b5abb4b83fe0e9fe2f6bc5a2728f967c5e845dd353cfac6d9ed4677ad39aa32ee25a1dbdaad8248d71ee1e3a4, Status: active
    Id: 0xadc25472f45a72446d0b5f7b5ec5760db14b198a21a8b0ad40ec673365c54ba1688ad0913f171135a94d4ce1f0ee684f, Status: active
    Id: 0x8071b39b9cfaefc094aff22c76a30f41709ed18f00b36efd63c7c64c644b3482bdfad5018fa32246af1a6c96943c750c, Status: active
    Id: 0x881eb088e400920706bf3281fcabd23bbea081d818c8a60f91faa1f2a1f2c8170b5a89f355ef832d05d8d1685c3e7a52, Status: unavailable
    ```
</details>

### Validator Statuses

A validator can have the following statuses, provided in the `status` field of the response:

| Status               | Description                                                                                                                                                                                 | Onchain State Equivalent               | Action Required                                     |
|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------|-----------------------------------------------------|
| Provisioning         | Validator is being created by Coinbase                                                                                                                                                      | :no_entry_sign: (Coinbase Only Status) | Wait :hourglass_flowing_sand:                       |
| Provisioned          | Validator has been created by Coinbase and is ready for a deposit                                                                                                                           | :no_entry_sign: (Coinbase Only Status) | Sign and broadcast the provided deposit transaction |
| Deposited            | Deposit transaction has been signed, broadcasted, and finalized on the Ethereum network                                                                                                     | :no_entry_sign: (Coinbase Only Status) | Wait :hourglass_flowing_sand:                       |
| Pending              | Validator is in the activation queue. This means the Ethereum network has successfully executed the deposit transaction                                                                     | `pending_queued`                       | Wait :hourglass_flowing_sand:                       |
| Active               | Validator is active and earning rewards                                                                                                                                                     | `active_ongoing`                       | None                                                |
| Exiting              | Validator is in the exit queue. The validator is still earning rewards                                                                                                                      | `active_exiting`                       | Wait :hourglass_flowing_sand:                       |
| Exited               | Validator is waiting to enter the withdrawal queue. This means the validator has exited the active set and rewards are no longer being earned.                                              | `exited_unslashed`                     | Wait :hourglass_flowing_sand:                       |
| Withdrawal Available | Validator is in the withdrawal queue. The network will sweep available funds to the `withdrawal_address` on a predetermined schedule                                                        | `withdrawal_possible`                  | Wait :hourglass_flowing_sand:                       |
| Withdrawal Complete  | Validator has completed its lifecycle. It no longer has any validating responsibilities and the available funds (rewards and initial stake) have been swept to the `withdrawal_address`     | `withdrawal_done`                      | None                                                |
| Unavailable          | Validator was provisioned, but a deposit transaction was never broadcasted. Coinbase has spun down the provisioned validator                                                                | :no_entry_sign: (Coinbase Only Status) | None                                                |
| Active Slashed       | Validator has been slashed in a previous epoch. The validator is still in the active set, but rewards cannot be earned and a voluntary exit cannot be performed                             | `active_slashed`                       | Wait :hourglass_flowing_sand:                       |
| Exited Slashed       | Validator has been slashed in a previous epoch. The validator has exited the active set                                                                                                     | `exited_slashed`                       | None                                                |

### Filtering By Validator Statuses

You can filter the list of validators to view all validators with a specific status.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Show all your validators with an active status.
        const validators = await Validator.list(
            Coinbase.networks.EthereumHolesky,
            Coinbase.assets.Eth,
            ValidatorStatus.ACTIVE,
        );
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby" default>
        ```ruby
        # Show all your validators with an active status.
        validators = Coinbase::Validator.list("ethereum-holesky", :eth, status: 'active')
        ```
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Get the validators that you've provisioned for staking.
        validators := client.ListValidator(
          ctx,
          coinbase.EthereumHolesky,
          coinbase.Eth,
          coinbase.WithListValidatorsStatusOption(coinbase.ValidatorStatusActive),
        )
        ```
    </TabItem>
</Tabs>

<details>
  <summary>Example output</summary>
    Your validators will be listed only if the status is active.

    ```text
    Id: 0xa3fc791b5abb4b83fe0e9fe2f6bc5a2728f967c5e845dd353cfac6d9ed4677ad39aa32ee25a1dbdaad8248d71ee1e3a4, Status: active
    Id: 0xadc25472f45a72446d0b5f7b5ec5760db14b198a21a8b0ad40ec673365c54ba1688ad0913f171135a94d4ce1f0ee684f, Status: active
    Id: 0x8071b39b9cfaefc094aff22c76a30f41709ed18f00b36efd63c7c64c644b3482bdfad5018fa32246af1a6c96943c750c, Status: active
    ```
</details>



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/sol/overview.mdx -->

---
title: SOL Staking
sidebar_label: Overview
slug: overview
---

The Coinbase Staking API enables staking any amount of SOL on the Solana network to earn rewards for you and your users. [Get started](./usage.mdx)!

The only inputs required are your own wallet and the desired stake (or unstake) amount. There is no need to tediously manage the underlying Solana stake accounts - the API does that heavy lifting for you. The staking rewards automatically accrue on the derived stake accounts, which can be claimed in the two-step process of [unstaking](./usage.mdx#unstake) and [claiming stake](./usage.mdx#claim-stake).

### Who this solution is for

* Wallet providers, onchain apps, and custodians who want to stake native SOL to Coinbase operated validators and have access to detailed staking rewards data.
* Developers looking for a simplified SOL staking solution where they do not need to directly manage stake account creation, splits and merges.

### Validator details

| Network | Address                                                                                                                                  | Location | Commission Fee | Operator  |
|---------|------------------------------------------------------------------------------------------------------------------------------------------|----------|----------------|-----------|
| Mainnet | [`6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9`](https://solanabeach.io/validator/6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9)          | Ireland  | 8%             | Coinbase  |
| Devnet  | [`GkqYQysEGmuL6V2AJoNnWZUz2ZBGWhzQXsJiXm2CLKAN`](https://solscan.io/account/GkqYQysEGmuL6V2AJoNnWZUz2ZBGWhzQXsJiXm2CLKAN?cluster=devnet) | N/A      | N/A            | Community |

### Rewards scope

| Data Type                   | Network      | Details                 | Historical Depth | Addresses                 | Aggregations |
|-----------------------------|--------------|-------------------------|------------------|---------------------------|--------------|
| Historical Rewards          | Mainnet Only | Consensus Rewards Only  | Jan 1st, 2024    | All Staked Addresses      | Epoch        |
| Historical Staking Balances | Mainnet Only |                         | Aug 15th, 2024   | All Staked Addresses      | Epoch        |

:::tip
Some staking rewards earned via SOL Staking may be too small to be represented accurately in USD.
It's recommended to view the staking rewards with the `Native` format option to see the rewards in 
Solana's native denomination, [lamport](https://solana.com/docs/terminology#lamport), which is 9 decimal places.
:::



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/sol/usage.mdx -->

---
title: SOL Staking
sidebar_label: Usage
slug: usage
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip
See the [quickstart](../../quickstart.mdx) to familiarize yourself with Coinbase Programmatic Staking and basic usage.
:::

The Coinbase Staking API enables users to stake or unstake any amount of SOL. A user only needs to specify a wallet and a stake amount, and the API will handle the rest.

The API automatically creates and manages the underlying Solana [stake accounts](https://solana.com/docs/economics/staking/stake-accounts) on your behalf. The staking rewards automatically accrue on the derives stake accounts, which can be claimed in the two-step process of [unstaking](#unstake) and [claiming rewards](#claim-rewards).

Currently, only the [external address model](../../../../mpc-wallet/docs/addresses#external-addresses) is supported for SOL staking.

***

## Stake

Before staking, **ensure that your address contains enough SOL** to cover the stake amount and network fees. For devnet funds, you can use [this faucet](https://faucet.solana.com).

The amount of SOL that is ultimately staked will be the user input subtracted by the [rent reserve](https://solana.com/docs/core/fees#rent) amount. The rent reserve amount is a Solana-mandated account minimum. So if the user input is 1 SOL and the rent reserve is 0.02 SOL, the amount that will ultimately be staked is ~0.98 SOL. Without this rent adjustment, the stake wouldn't become active.

:::info
We currently only support delegating to the Coinbase public validator [`6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9`](https://solanabeach.io/validator/6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9). This validator is operated by Coinbase and is located in Ireland.
:::

### Step 1. Create a Stake Operation

<Tabs groupId="programming-language" queryString="lang">
    <TabItem value="ts" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the solana-devnet testnet network.
        let address = new ExternalAddress(Coinbase.networks.SolanaDevnet, "YOUR_WALLET_ADDRESS");

        // Find out how much SOL is available to stake.
        let stakeableBalance = await address.stakeableBalance(Coinbase.assets.Sol);

        // Build a stake operation for an amount <= stakeableBalance, in this case 0.1 SOL.
        let stakingOperation = await address.buildStakeOperation(0.1, Coinbase.assets.Sol);
        ```

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="go" label="Go">
        ```go
        // Code assumes you've already created a CDP client as shown in the quickstart guide.

        // Create a new external address on the solana-devnet testnet network.
        address := coinbase.NewExternalAddress(coinbase.SolanaDevnet, "YOUR_WALLET_ADDRESS")

        // Get the amount of SOL available to stake.
        stakeableBalance, err := client.GetStakeableBalance(ctx, coinbase.Sol, address)
        if err != nil {
            return err
        }

        // Build a stake operation for an amount <= stakeableBalance, in this case 0.1 SOL.
        stakingOperation, err := client.BuildStakeOperation(
            context.Background(),
            big.NewFloat(0.1),
            coinbase.Sol,
            address,
        )
        if err != nil {
            return err
        }
        ```

        Refer to the [ExternalAddress](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#NewExternalAddress), [GetStakeableBalance](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.GetStakeableBalance) and [BuildStakeOperation](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildStakeOperation) functions for more details.
    </TabItem>
</Tabs>

### Step 2. Sign and Broadcast

Once the unstake operation has been built, the transaction has been constructed based on your inputs, but not signed or broadcasted. Now, you must relay the transactions to your end-user for signing and broadcasting. 

If you'd like to sign and broadcast in your own system, refer to the [signing and broadcasting transactions](#signing-and-broadcasting-transactions) section for an example.

### Step 3. Wait

Once the transaction is signed and broadcasted, the SOL will be "pending staked" for ~2 days. This delay is a direct consequence of the Solana network's staking mechanics. After this period, the SOL will be staked and begin to earn rewards.

You can tell your SOL is fully staked and earning rewards by checking for when your SOL is added to the unstakeable balance.

## Unstake

Unstaking is the first part of a two-step process to withdraw your staked assets. The second step is [Claim Stake](#claim-stake).

In direct Solana staking, a user would need to select a specific [stake account](https://solana.com/docs/economics/staking/stake-accounts) and unstake each stake account individually. With the Coinbase Staking API, the user can simply specify the wallet and the desired unstake amount, and the API will handle the rest. The Coinbase Staking API hides this complexity by automatically creating, merging, and splitting the underlying Solana stake accounts for you. All a user must do is sign and broadcast the transactions and the API will handle the rest.

### Step 1. Create a Stake Operation

<Tabs groupId="programming-language" queryString="lang">
    <TabItem value="ts" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the solana-devnet testnet network.
        let address = new ExternalAddress(Coinbase.networks.SolanaDevnet, "YOUR_WALLET_ADDRESS");

        // To determine the amount of SOL available to unstake, use the `unstakeableBalance` method as shown below:
        let unstakeableBalance = await address.unstakeableBalance(Coinbase.assets.Sol);

        // Build an unstake operation for an amount <= unstakeableBalance, in this case 0.1 SOL.
        let stakingOperation = await address.buildUnstakeOperation(0.1, Coinbase.assets.Sol);
        ```

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="go" label="Go">
        ```go
        // Code assumes you've already created a CDP client as shown in the quickstart guide.

        // Create a new external address on the solana-devnet testnet network.
        address := coinbase.NewExternalAddress(coinbase.SolanaDevnet, "YOUR_WALLET_ADDRESS")

        // To determine the amount of SOL available to unstake, use the `unstakeableBalance` method as shown below:
        unstakeableBalance, err := client.GetUnstakeableBalance(ctx, coinbase.Sol, address)
        if err != nil {
            return err
        }

        // Build an unstake operation for an amount <= unstakeableBalance, in this case 0.1 SOL.
        stakingOperation, err := client.BuildStakeOperation(
            context.Background(),
            big.NewFloat(0.1),
            coinbase.Sol,
            address,
        )
        if err != nil {
            return err
        }
        ```

        Refer to the [ExternalAddress](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#NewExternalAddress), [GetStakeableBalance](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.GetStakeableBalance) and [BuildStakeOperation](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildStakeOperation) functions for more details.
    </TabItem>
</Tabs>

### Step 2. Sign and Broadcast

Once the unstake operation has been built, the transaction has been constructed based on your inputs, but not signed or broadcasted. Now, you must relay the transactions to your end-user for signing and broadcasting. 

If you'd like to sign and broadcast in your own system, refer to the [signing and broadcasting transactions](#signing-and-broadcasting-transactions) section for an example.

### Step 3. Wait

After the transaction is signed and broadcasted, the SOL will be "pending unstaked" for ~2 days. This delay is a direct consequence of the Solana network's staking mechanics. After the SOL in unstaked, the SOL will be in a claimable state and can be claimed using the [Claim Stake](#claim-stake) operation.

## Claim Stake

Claim Stake is the second part of a two-step process to withdraw your staked assets. The first step is [Unstake](#unstake).

After SOL is unstaked and the necessary time has passed (~2 days), the unstaked SOL will be sitting idle on the underlying stake account. This SOL is ready to be claimed. The claim stake operation allows you to claim the unstaked SOL and transfer it back to your wallet.

### Step 1. Create a Stake Operation

<Tabs groupId="programming-language" queryString="lang">
    <TabItem value="ts" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the solana-devnet testnet network.
        let address = new ExternalAddress(Coinbase.networks.SolanaDevnet, "YOUR_WALLET_ADDRESS");

        // Check if there is any balance available to claim.
        let claimableBalance = await address.unstakeableBalance(Coinbase.assets.Sol);

        // Build a claim_stake operation for an amount = claimableBalance.
        // The claim stake operation aims to claim all the withdrawable SOL at that point in time.
        let stakingOperation = await address.buildClaimStakeOperation(claimableBalance, Coinbase.assets.Sol);
        ```

        Refer to the [ExternalAddress docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="go" label="Go">
        ```go
        // Code assumes you've already created a CDP client as shown in the quickstart guide.

        // Create a new external address on the solana-devnet testnet network.
        address := coinbase.NewExternalAddress(coinbase.SolanaDevnet, "YOUR_WALLET_ADDRESS")

        // Check if there is any balance available to claim.
        claimableBalance, err := client.GetClaimableBalance(ctx, coinbase.Sol, address)
        if err != nil {
            return err
        }

        // Build a claim_stake operation for an amount = claimableBalance.
        // The claim stake operation aims to claim all the withdrawable SOL at that point in time.
        stakingOperation, err := client.BuildClaimStakeOperation(
            context.Background(),
            claimableBalance.Amount(),
            coinbase.Sol,
            address,
        )
        if err != nil {
            return err
        }
        ```

        Refer to the [ExternalAddress](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#NewExternalAddress), [GetStakeableBalance](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.GetStakeableBalance) and [BuildStakeOperation](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.BuildStakeOperation) functions for more details.
    </TabItem>
</Tabs>

### Step 2. Sign and Broadcast

Once the claim  operation has been built, the transaction has been constructed based on your inputs, but not signed or broadcasted. Now, you must relay the transactions to your end-user for signing and broadcasting. 

If you'd like to sign and broadcast in your own system, refer to the [signing and broadcasting transactions](#signing-and-broadcasting-transactions) section for an example.

After the transaction is signed and broadcasted, the SOL will be transferred back to your wallet almost immediately. At this stage, the full SOL staking lifecycle is complete.

## View Staking Rewards

After staking your SOL, rewards will begin to accrue on the blockchain that are withdrawable by your wallet. The staking rewards endpoint allows you to view these rewards earned by your wallet over time.

:::caution
Viewing historical rewards earned to Solana stake accounts that have dropped below the [rent reserve](https://solana.com/docs/core/fees#rent) are currently not supported. This means that the endpoint might not show all rewards that were earned in the past. This is a known limitation that will be addressed in a future release.
:::

The API provides rewards both in native units (i.e. SOL) and in equivalent USD value. The USD value is calculated using the Coinbase exchange rate in the ~30 seconds after the reward period concluded. As an example, if we provide aggregated rewards on January 20th, 2024 UTC, the underlying SOL value is calculated based on the USD value of SOL within the first 30 seconds of January 21st, 2024.

<Tabs groupId="programming-language">
    <TabItem value="ts" label="Typescript" default>
        Look up staking rewards for a specific address.

        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the solana-mainnet network for which you want to view staking rewards.
        let address = new ExternalAddress(Coinbase.networks.SolanaMainnet, "YOUR_WALLET_ADDRESS");

        // Get the rewards earned from staking in the last 1 week (default window).
        // Note that it can take several hours for new rewards to show up.
        let rewards = await address.stakingRewards(Coinbase.assets.Sol);

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```

        Look up staking rewards for a list of addresses.

        ```typescript
        import { Coinbase, StakingReward } from "@coinbase/coinbase-sdk";

        let rewards = await StakingReward.list(
            Coinbase.networks.SolanaMainnet, Coinbase.assets.Sol,
            ["ADDRESS1", "ADDRESS2"],
            tenDaysAgo.toISOString(), now.toISOString(),
        );

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```
        View the USD value of rewards including conversion price and time.

        ```typescript
        // Loop through the rewards and print each staking reward's USD conversion information
        rewards.forEach(reward => {
            console.log(
                `USD value: ${reward.usdValue()},
                Conversion price: ${reward.conversionPrice().toString()},
                Conversion time: ${reward.conversionTime().toISOString()}`,
            );
        });
        ```

        Refer to the [StakingReward docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_staking_reward.StakingReward.html) for a full list of supported methods and their parameters.
    </TabItem>
    <TabItem value="go" label="Go">
        Look up staking rewards for a specific address.

        ```go
        // Create a new external address on the solana-devnet network for which you want to view staking rewards.
        address := coinbase.NewExternalAddress(coinbase.SolanaDevnet, "YOUR_WALLET_ADDRESS")

        // Get the rewards earned from staking in the last 10 days.
        // Note that it can take several hours for new rewards to show up.
        rewards, err := client.ListStakingRewards(
            context.Background(),
            coinbase.Sol,
            []coinbase.Address{*address},
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
            api.STAKINGREWARDFORMAT_USD,
        )
        if err != nil {
            return err
        }

        // Loop through the rewards and print each staking reward.
        for _, reward := range rewards {
            log.Printf("Staking reward: %s", reward.ToString())
        }
        ```

        Look up staking rewards for a list of addresses.

        ```go
        // Get the rewards earned from staking across multiple wallets in the last 10 days.
        // Note that it can take several hours for new rewards to show up.
        rewards, err := client.ListStakingRewards(
            context.Background(),
            coinbase.Sol,
            []coinbase.Address{*address1, *address2},
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
            api.STAKINGREWARDFORMAT_USD,
        )
        if err != nil {
            return err
        }

        // Loop through the rewards and print each staking reward.
        for _, reward := range rewards {
            log.Printf("Staking reward: %s", reward.ToString())
        }
        ```

        Refer to the [ListStakingRewards](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.ListStakingRewards) function for more details.
    </TabItem>
</Tabs>

## View Historical Staking Balances

The staking balances endpoint allows you to view the historical staking balances of your wallet over time, accounting for accruing rewards and auto-compounding stake.

<Tabs groupId="programming-language">
    <TabItem value="ts" label="Typescript" default>
        Look up historical staking balances for a specific address.

        ```ts
        const balances = await StakingBalance.list(
            NetworkIdentifier.SolanaMainnet,
            Coinbase.assets.Sol,
            wallet,
            startTime,
            new Date().toISOString(),
        );
        ```

        Refer to the [StakingBalance docs](https://coinbase.github.io/coinbase-sdk-nodejs/interfaces/client_api.StakingBalance.html) for a full list of supported methods and their parameters.
    </TabItem>
    <TabItem value="go" label="Go">
        Look up historical staking balances for a specific address.

        ```go
        // Get the balances earned from staking in the last 10 days.
        // Note that it can take several hours for balance snapshots to show up.
        balances, err := client.ListHistoricalStakingBalances(
            ctx,
            coinbase.Sol,
            address,
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
        )
        if err != nil {
            log.Fatalf("error fetching staking balances: %v", err)
        }

        // Loop through the balances and print each staking balance.
        for _, balance := range balances {
            log.Printf("Staking balance: %s", balance.String())
        }
        ```

        Refer to the [ListHistoricalStakingBalances documentation](https://pkg.go.dev/github.com/coinbase/coinbase-sdk-go/pkg/coinbase#Client.ListHistoricalStakingBalances) function for more details.
    </TabItem>
</Tabs>


## Signing and Broadcasting Transactions

Here's an example of how to sign and broadcast transactions surfaced via the staking operation resource.

<Tabs groupId="programming-language">
    <TabItem value="ts" label="Typescript" default>
        ```typescript
        import { Connection, Transaction, Keypair, SendOptions } from "@solana/web3.js";
        import bs58 from "bs58";

        const connection = new Connection("https://api.devnet.solana.com");
        const secretKey = Uint8Array.from(bs58.decode("YOUR_WALLET_PRIVATE_KEY"));
        const key = Keypair.fromSecretKey(secretKey);

        // This code assumes a solana stakingOperation has already been created.

        for (const tx of stakingOperation.getTransactions()) {
            console.log("Tx unsigned payload:", tx.getUnsignedPayload());

            const transaction = Transaction.from(bs58.decode(tx.getUnsignedPayload()));

            transaction.partialSign(key);

            const sendOptions: SendOptions = {
                skipPreflight: false,
                preflightCommitment: "finalized",
            };

            let maxRetries = 20;

            while (maxRetries > 0) {
                try {
                    const signature = await connection.sendRawTransaction(transaction.serialize(), sendOptions);
                    console.log("Transaction signature:", getTxLink(signature, networkID));
                    break;
                } catch (error) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    console.error(`Trying again [%d] Sending transaction...`, 21 - maxRetries);
                    maxRetries--;
                }
            }
        }

        function getTxLink(signature: string, networkID: string): string {
            const baseUrl = "https://explorer.solana.com/tx";

            let network = "mainnet";
            if (networkID === Coinbase.networks.SolanaDevnet) {
                network = "devnet";
            }

            return `${baseUrl}/${signature}?cluster=${network}`;
        }
        ```
    </TabItem>
    <TabItem value="go" label="Go">
        ```go
        package main

        import (
            "context"
            "fmt"
            "log"
            "os"
            "time"

            "github.com/btcsuite/btcutil/base58"
            "github.com/coinbase/coinbase-sdk-go/pkg/coinbase"
            bin "github.com/gagliardetto/binary"
            "github.com/gagliardetto/solana-go"
            "github.com/gagliardetto/solana-go/rpc"
        )

        const (
            walletPrivateKey = "YOUR_WALLET_PRIVATE_KEY"
            devnetRPC        = "https://api.devnet.solana.com"
        )

        func main() {
            ctx := context.Background()

            // This code assumes a solana stakingOperation has already been created.

            privateKey, err := decodePrivateKey(walletPrivateKey)

            err = stakingOperation.Sign(privateKey)
            if err != nil {
                log.Fatalf("error signing transaction: %v", err)
            }

            rpcClient := rpc.New(rpcURL)

            maxRetries := uint(5)
            opts := rpc.TransactionOpts{
                SkipPreflight: false,
                MaxRetries:    &maxRetries,
                // NOTE: In production, consider using rpc.CommitmentFinalized instead to ensure the block is included.
                PreflightCommitment: rpc.CommitmentProcessed,
            }

            for _, transaction := range stakingOperation.Transactions() {
                unsignedTx := transaction.UnsignedPayload()
                signedTx := transaction.SignedPayload()

                log.Printf("Unsigned tx payload: %s\n\n", unsignedTx)
                log.Printf("Signed tx payload: %s\n\n", signedTx)

                rawTx := transaction.Raw()
                solanaTx, ok := rawTx.(*solana.Transaction)
                if !ok {
                    log.Fatal("failed to cast raw transaction to solana.Transaction")
                }

                sig, err := rpcClient.SendTransactionWithOpts(ctx, solanaTx, opts)
                if err != nil {
                    log.Fatalf("failed to send transaction: %v", err)
                }

                log.Printf("Broadcasted tx: %s\n\n", getTxLink(stakingOperation.NetworkID(), sig.String()))
            }
        }

        func decodePrivateKey(privateKeyString string) (*ed25519.PrivateKey, error) {
            // Decode the base58 encoded private key
            privateKeyBytes := base58.Decode(privateKeyString)
            if len(privateKeyBytes) != ed25519.PrivateKeySize {
                log.Fatalf("invalid private key length: expected %d bytes, got %d bytes", ed25519.PrivateKeySize, len(privateKeyBytes))
            }

            // Convert the byte slice to an ed25519 private key
            privateKey := ed25519.PrivateKey(privateKeyBytes)

            return &privateKey, nil
        }

        func getTxLink(networkID, signature string) string {
            if networkID == coinbase.SolanaMainnet {
                return fmt.Sprintf("https://explorer.solana.com/tx/%s", signature)
            } else if networkID == coinbase.SolanaDevnet {
                return fmt.Sprintf("https://explorer.solana.com/tx/%s?cluster=devnet", signature)
            }

            return ""
        }
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/eth-shared/overview.mdx -->

---
title: Shared ETH Staking (No Minimum) 
sidebar_label: Overview
slug: overview
---

Shared ETH Staking allows you to enable ETH rewards for you and your users without requiring the 32 ETH deposit increments typically required by ETH staking.

Our shared ETH staking solution is built using proprietary onchain smart contracts to remove deposit requirements in conjunction with standard Ethereum staking contracts. This approach ensures **end-users are always in custody of their funds**.  

### Who this solution is for

* Wallet providers, onchain apps, and custodians with users who will be staking amounts of ETH below the 32 ETH deposit minimums.
* Developers looking for instant onchain payouts of revenue share (if applicable).

### Validator details

:::info
Validator contract addresses:  

**Mainnet**: `0x2e3956e1ee8b44ab826556770f69e3b9ca04a2a7`  
**Testnet (Holesky)**: `0xA55416de5DE61A0AC1aa8970a280E04388B1dE4b`  
**Commission fee**: 15% 

Developers with a private integrating contract will have been sent their contract address details separately.
:::

### Rewards scope

| Data Type                   | Network      | Details                 | Historical Depth             | Addresses                 | Aggregations |
|-----------------------------|--------------|-------------------------|------------------------------|---------------------------|--------------|
| Historical Rewards          | Mainnet Only | All Reward Types        | Oct 1st, 2023 (Inception)    | All Staked Addresses      | Daily        |

:::tip
Some staking rewards earned via Shared ETH Staking may be too small to be represented accurately in USD.
It's recommended to view the staking rewards with the `Native` format option in that scenario to
see the rewards in Ethereum's native denomination, [Wei](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations), which is 18 decimal places.
:::



<!-- File: /Users/tinahe/docs/projects/staking/docs/networks/eth-shared/usage.mdx -->

---
title: Integrating Shared ETH Staking
sidebar_label: Usage
slug: usage
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Shared ETH Staking enables users to stake with any amount of ETH.

:::tip
See the [quickstart](../../quickstart.mdx) to familiarize yourself with Coinbase Programmatic Staking and basic usage.
:::

***

## External Address

The external address model is an address model where the private keys are **not** managed by the Coinbase SDK. The developer would be responsible for "bringing their own wallet". All signing operations must be completed off-platform. Read more in the [external addresses documentation](../../../../mpc-wallet/docs/addresses#external-addresses).

### Stake

To stake, **ensure that the external address contains enough ETH on the network you are using** to cover the stake amount and network transaction fees. To fund your (Holesky) testnet address with ETH, we provide a [faucet](/mpc-wallet/docs/wallets#faucets) method.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // Find out how much ETH is available to stake.
        let stakeableBalance = await address.stakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Build a stake operation for an amount <= stakeableBalance, in this case 0.005 ETH.
        let stakeOperation = await address.buildStakeOperation(0.005, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an Ethers.js example.

        Refer to the [ExternalAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # Get the amount of ETH available to stake.
        stakeable_balance = address.stakeable_balance(:eth, mode: :partial)

        # Build a stake operation for an amount <= stakeable_balance, in this case 0.005 ETH.
        stake_operation = address.build_stake_operation(0.005, :eth, mode: :partial)
        ```

        Once the stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for how to accomplish this with standard ruby libraries.

        Refer to the [ExternalAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Create a new external address on the `ethereum-holesky` testnet network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Get the amount of ETH available to stake.
        stakeableBalance, err := client.GetStakeableBalance(ctx, coinbase.Eth, address, coinbase.WithStakingBalanceMode(coinbase.StakingOperationModePartial))
        if err != nil {
            log.Fatal(err)
        }

        // Build a stake operation for an amount <= stakeableBalance, in this case 0.005 ETH.
        stakeOperation, err := client.BuildStakeOperation(
            context.Background(),
            big.NewFloat(0.005),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModePartial),
        )
        if err != nil {
            log.Fatal(err)
        }
        ```

        Once the stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an go-ethereum example.
    </TabItem>
</Tabs>

### Unstake

Unstake is the first part of a two-step process to withdraw your staked assets. This step involves submitting an exit request to the network. This **can take 1-3 days to process**.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // Since the time you first staked, it is possible that the amount of staked ETH has increased.
        // To determine the amount of ETH available to unstake, use the `unstakeableBalance` method as shown below.
        let unstakeableBalance = await address.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Build an unstake operation for an amount <= unstakeableBalance, in this case 0.005 ETH.
        let unstakeOperation = await address.buildUnstakeOperation(0.005, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the unstake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an Ethers.js example.

        Refer to the [ExternalAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # Since the time you first staked, it is possible that the amount of staked ETH has increased.
        # To determine the amount of ETH available to unstake, use the `unstakeable_balance` method as shown below.
        unstakeable_balance = address.unstakeable_balance(:eth, mode: :partial)

        # Build an unstake operation for an amount <= unstakeable_balance, in this case 0.005 ETH.
        unstake_operation = address.build_unstake_operation(0.005, :eth, mode: :partial)
        ```

        Once the unstake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for how to accomplish this with standard ruby libraries.

        Refer to the [ExternalAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Create a new external address on the `ethereum-holesky` testnet network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Since the time of staking, it is possible that the amount of staked ETH has increased.
        // To determine the amount of ETH available to unstake, use the `unstakeableBalance` method as shown below:
        unstakeableBalance, err := client.GetUnstakeableBalance(ctx, coinbase.Eth, address, coinbase.WithStakingBalanceMode(coinbase.StakingOperationModePartial))
        if err != nil {
            log.Fatal(err)
        }

        // Build an unstake operation for an amount <= unstakeableBalance, in this case 0.005 ETH.
        unstakeOperation, err := client.BuildUnstakeOperation(
            context.Background(),
            big.NewFloat(0.005),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModePartial),
        )
        if err != nil {
            log.Fatal(err)
        }
        ```

        Once the unstake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an go-ethereum example.
    </TabItem>
</Tabs>

### Claim Stake

Once your exit request has been processed by the network you may proceed with the Claim Stake method below.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-holesky testnet network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // Check if there is any staked balance available to claim.
        let claimableBalance = await address.claimableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Build a claim_stake operation for an amount = claimableBalance.
        // The claim stake operation aims to claim all the exitable ETH available at that point in time,
        // which may have been requested from multiple previous unstake attempts.
        let claimStakeOperation = await address.buildClaimStakeOperation(claimableBalance, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the claim stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an Ethers.js example.

        Refer to the [ExternalAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the ethereum-holesky testnet network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # Check if there is any staked balance available to claim.
        claimable_balance = address.claimable_balance(:eth, mode: :partial)

        # Build a claim_stake operation for an amount = claimable_balance.
        # The claim stake operation aims to claim all the exitable ETH available at that point in time,
        # which may have been requested from multiple previous unstake attempts.
        claim_stake_operation = address.build_claim_stake_operation(claimable_balance, :eth, mode: :partial)
        ```

        Once the claim stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for how to accomplish this with standard ruby libraries.

        Refer to the [ExternalAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/ExternalAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Create a new external address on the `ethereum-holesky` testnet network.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Check if there is any staked balance available to claim.
        claimableBalance, err := client.GetClaimableBalance(ctx, coinbase.Eth, address, coinbase.WithStakingBalanceMode(coinbase.StakingOperationModePartial))
        if err != nil {
            log.Fatal(err)
        }

        // Build a claim_stake operation for an amount = claimableBalance.
        // The claim stake operation aims to claim all the exitable ETH available at that point in time,
        // which may have been requested from multiple previous unstake attempts.
        claimStakeOperation, err := client.BuildClaimStakeOperation(
            context.Background(),
            claimableBalance.Amount(),
            coinbase.Eth,
            address,
            coinbase.WithStakingOperationMode(coinbase.StakingOperationModePartial),
        )
        if err != nil {
            log.Fatal(err)
        }
        ```

        Once the claim stake operation has been built, relay the transactions to your end-user for signing and broadcasting. Refer to the [Signing and Broadcasting Transactions](#signing-and-broadcasting-transactions) section for an go-ethereum example.
    </TabItem>
</Tabs>

### View Staking Rewards

After staking your ETH, reward will begin to accrue on your address. These rewards can be listed via the `stakingRewards` call.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        Refer to the [StakingRewards documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html#stakingRewards) for an explanation of the method's parameters.

        Look up staking rewards for a specific address.

        ```typescript
        import { Coinbase, ExternalAddress } from "@coinbase/coinbase-sdk";

        // Create a new external address on the ethereum-mainnet network for which you want to view staking rewards.
        let address = new ExternalAddress(Coinbase.networks.EthereumMainnet, "YOUR_WALLET_ADDRESS");

        // Get the rewards earned from staking in the last 1 week (default window).
        // Note that it can take upto a day for new rewards to show up.
        let rewards = await address.stakingRewards(Coinbase.assets.Eth);

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```

        Refer to the [StakingReward documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_staking_reward.StakingReward.html) for a full list of supported methods and their parameters.

        Look up staking rewards for a list of addresses.

        ```typescript
        import { Coinbase, StakingReward } from "@coinbase/coinbase-sdk";

        let rewards = await StakingReward.list(
            Coinbase.networks.EthereumMainnet, Coinbase.assets.Eth,
            ["ADDRESS1", "ADDRESS2"],
            tenDaysAgo.toISOString(), now.toISOString(),
        );

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```
        View the USD value of rewards including conversion price and time.

        ```typescript
        // Loop through the rewards and print each staking reward's USD conversion information
        rewards.forEach(reward => {
            console.log(
                `USD value: ${reward.usdValue()},
                Conversion price: ${reward.conversionPrice().toString()},
                Conversion time: ${reward.conversionTime().toISOString()}`,
            );
        });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        Refer to the [StakingReward documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/StakingReward.html) for an explanation of the method's parameters.

        Look up staking rewards for a specific address.

        ```ruby
        # Create a new external address on the ethereum-mainnet network for which you want to view staking rewards.
        address = Coinbase::ExternalAddress.new(:ethereum_mainnet, "YOUR_WALLET_ADDRESS")

        # Get the rewards earned from staking in the last 1 week (default window).
        # Note that it can take upto a day for new rewards to show up.
        rewards = address.staking_rewards(:eth)

        # Loop through the enumerator and print each staking reward.
        rewards.each do |reward| puts "#{reward}" end
        ```

        Refer to the [StakingReward documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/StakingReward.html) for a full list of supported methods and their parameters.

        Look up staking rewards for a list of addresses.

        ```ruby
        rewards = Coinbase::StakingReward.list(
            :ethereum_mainnet, :eth,
            ["ADDRESS1", "ADDRESS2"],
            start_time: Time.now - (10 * 24 * 60 * 60),
            end_time: Time.now,
        )

        # Loop through the enumerator and print each staking reward.
        rewards.each do |reward| puts "#{reward}" end
        ```
        View the USD value of rewards including conversion price and time.

        ```ruby
        # Loop through the enumerator and print the USD value of rewards including conversion price and time
        rewards.each do |reward|
        puts "USD value: #{reward.usd_value}, " +
            "Conversion price: #{reward.usd_conversion_price}, " +
            "Conversion time: #{reward.usd_conversion_time}"
        end
        ```
    </TabItem>
    <TabItem value="Go" label="Go">
        Look up staking rewards for a specific address.

        ```go
        // Create a new external address on the `ethereum-holesky` network for which you want to view staking rewards.
        address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, "YOUR_WALLET_ADDRESS")

        // Get the rewards earned from staking in the last 10 days.
        // Note that it can take upto a day for new rewards to show up.
        rewards, err := client.ListStakingRewards(
            context.Background(),
            coinbase.Eth,
            []coinbase.Address{*address},
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
            api.STAKINGREWARDFORMAT_USD,
        )
        if err != nil {
            log.Fatal(err)
        }

        // Loop through the rewards and print each staking reward.
        for _, reward := range rewards {
            log.Printf("Staking reward: %s", reward.ToString())
        }
        ```

        Look up staking rewards for a list of addresses.

        ```go
        rewards, err := client.ListStakingRewards(
            context.Background(),
            coinbase.Eth,
            []coinbase.Address{*address1, *address2},
            time.Now().Add(-10*24*time.Hour),
            time.Now(),
            api.STAKINGREWARDFORMAT_USD,
        )
        if err != nil {
            log.Fatal(err)
        }

        // Loop through the rewards and print each staking reward.
        for _, reward := range rewards {
            log.Printf("Staking reward: %s", reward.ToString())
        }
        ```
    </TabItem>
</Tabs>

***

## Wallet Address

The wallet address model is an address model where the private keys are managed by the Coinbase SDK. This means that the SDK can sign transactions on behalf of the user. In production, it's recommend to use a server-signer for increased security. Find out more in the [wallet addresses section](../../../../mpc-wallet/docs/addresses#wallet-addresses).

### Stake

Shared ETH Staking enables users to stake with any amount of ETH. To stake, **ensure that the wallet address contains enough ETH on the network you are using** to cover the stake amount and network transaction fees. To fund your (Holesky) testnet address with ETH, we provide a [faucet](/mpc-wallet/docs/wallets#faucets) method.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        Refer to the [WalletAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.

        ```typescript
        import { Coinbase, Wallet, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // Find out how much ETH is available to stake.
        let stakeableBalance = await wallet.stakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Create a stake operation for an amount <= stakeableBalance, in this case 0.0001 ETH.
        let stakeOperation = await wallet.createStake(0.0001, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the stake operation has completed successfully, congrats you've just staked some ETH!
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        Refer to the [WalletAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.

        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # Get the amount of ETH available to stake.
        stakeable_balance = wallet.stakeable_balance(:eth, mode: :partial)

        # Create a stake operation for an amount <= stakeable_balance, in this case 0.0001 ETH.
        stake_operation = wallet.stake(0.005, :eth, mode: :partial)
        ```

        Once the stake operation has been created successfully, congrats you've just staked some ETH!
    </TabItem>
</Tabs>

### Unstake

Unstake is the first part of a two-step process to withdraw your staked assets. This step involves submitting an exit request to the network. This **can take 1-3 days to process**.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        Refer to the [WalletAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.

        ```typescript
        import { Coinbase, Wallet, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // Since the time you first staked, it is possible that the amount of staked ETH has increased.
        // To determine the amount of ETH available to unstake, use the `unstakeableBalance` method as shown below.
        let unstakeableBalance = await wallet.unstakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Create an unstake operation for an amount <= unstakeableBalance, in this case 0.0001 ETH.
        let unstakeOperation =  await wallet.createUnstake(0.0001, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the unstake operation has been created, it could take around 1-3 days to eventually claim your stake. Check below how to claim stake.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        Refer to the [WalletAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.

        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # Since the time you first staked, it is possible that the amount of staked ETH has increased.
        # To determine the amount of ETH available to unstake, use the `unstakeable_balance` method as shown below.
        unstakeable_balance = wallet.unstakeable_balance(:eth, mode: :partial)

        # Build an unstake operation for an amount <= unstakeable_balance, in this case 0.0001 ETH.
        unstake_operation = wallet.unstake(0.0001, :eth, mode: :partial)
        ```

        Once the unstake operation has been created, it could take around 1-3 days to eventually claim your stake. Check below how to claim stake.
    </TabItem>
</Tabs>

### Claim Stake

Once your exit request has been processed by the network, the stake can be withdrawn from the address.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, Wallet, StakeOptionsMode } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // Check if there is any staked balance available to claim.
        let claimableBalance = await wallet.claimableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);

        // Build a claim_stake operation for an amount = claimableBalance.
        // The claim stake operation aims to claim all the exitable ETH available at that point in time,
        // which may have been requested from multiple previous unstake attempts.
        let claimStakeOperation = await wallet.createClaimStake(claimableBalance, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
        ```

        Once the claim stake operation has been created, you have fully claimed all your stake!

        Refer to the [WalletAddress documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_wallet_address.WalletAddress.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new wallet address on the ethereum-holesky testnet network.
        wallet = Coinbase::Wallet.create(network: :ethereum_holesky)

        # Check if there is any staked balance available to claim.
        claimable_balance = wallet.claimable_balance(:eth, mode: :partial)

        # Build a claim_stake operation for an amount = claimable_balance.
        # The claim stake operation aims to claim all the exitable ETH available at that point in time,
        # which may have been requested from multiple previous unstake attempts.
        claim_stake_operation = wallet.claim_stake(claimable_balance, :eth, mode: :partial)
        ```

        Once the claim stake operation has been created, you have fully claimed all your stake!

        Refer to the [WalletAddress documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/WalletAddress) for a full list of supported methods.
    </TabItem>
</Tabs>

### View Staking Rewards

After staking your ETH, reward will begin to accrue on your address. These rewards can be listed via the `stakingRewards` call.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        Look up staking rewards for a wallet.

        ```typescript
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

        // Create a new wallet address on the ethereum-holesky testnet network.
        let wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });

        // Get the rewards earned from staking in the last 1 week (default window).
        // Note that it can take upto a day for new rewards to show up.
        let rewards = await wallet.stakingRewards(Coinbase.assets.Eth);

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```

        Look up staking rewards for a list of addresses.

        ```typescript
        import { Coinbase, StakingReward } from "@coinbase/coinbase-sdk";

        let rewards = await StakingReward.list(
            Coinbase.networks.EthereumMainnet, Coinbase.assets.Eth,
            ["ADDRESS1", "ADDRESS2"],
            tenDaysAgo.toISOString(), now.toISOString(),
        );

        // Loop through the rewards and print each staking reward.
        rewards.forEach(reward => console.log(reward.toString()));
        ```

        View the USD value of rewards including conversion price and time.

        ```typescript
        // Loop through the rewards and print each staking reward's USD conversion information
        rewards.forEach(reward => {
            console.log(
                `USD value: ${reward.usdValue()},
                Conversion price: ${reward.conversionPrice().toString()},
                Conversion time: ${reward.conversionTime().toISOString()}`,
            );
        });
        ```

        Refer to the [StakingRewards documentation](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address_external_address.ExternalAddress.html#stakingRewards) for an explanation of the method's parameters.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        Look up staking rewards for a specific address.

        ```ruby
        # Create a new external address on the ethereum-mainnet network for which you want to view staking rewards.
        address = Coinbase::ExternalAddress.new(:ethereum_mainnet, "YOUR_WALLET_ADDRESS")

        # Get the rewards earned from staking in the last 1 week (default window).
        # Note that it can take upto a day for new rewards to show up.
        rewards = address.staking_rewards(:eth)

        # Loop through the enumerator and print each staking reward.
        rewards.each do |reward| puts "#{reward}" end
        ```

        Look up staking rewards for a list of addresses.

        ```ruby
        rewards = Coinbase::StakingReward.list(
            :ethereum_mainnet, :eth,
            ["ADDRESS1", "ADDRESS2"],
            start_time: Time.now - (10 * 24 * 60 * 60),
            end_time: Time.now,
        )

        # Loop through the enumerator and print each staking reward.
        rewards.each do |reward| puts "#{reward}" end
        ```

        View the USD value of rewards including conversion price and time.

        ```ruby
        # Loop through the enumerator and print the USD value of rewards including conversion price and time
        rewards.each do |reward|
        puts "USD value: #{reward.usd_value}, " +
            "Conversion price: #{reward.usd_conversion_price}, " +
            "Conversion time: #{reward.usd_conversion_time}"
        end
        ```

        Refer to the [StakingReward documentation](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/StakingReward.html) for an explanation of the method's parameters.
    </TabItem>
</Tabs>

***

The functionality below applies to both External and wallet addresses.

## Signing and Broadcasting Transactions

Here's an example of how to sign and broadcast transactions surfaced via the staking operation resource.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Load your wallet's private key from which you initiated the above stake operation.
        const wallet = new ethers.Wallet("YOUR_WALLET_PRIVATE_KEY");

        // Sign the transactions within staking operation resource with your wallet.
        await stakingOperation.sign(wallet);

        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        const provider = new ethers.JsonRpcProvider("HOLESKY_RPC_URL");

        // Broadcast each of the signed transactions to the network.
        stakingOperation.getTransactions().forEach(async tx => {
            let resp = await provider.broadcastTransaction(tx.getSignedPayload()!);
            console.log(resp);
        });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Load your wallet's private key from which you initiated the above stake operation.
        private_key = Eth::Key.new(priv: "YOUR_WALLET_PRIVATE_KEY")

        # Sign the transactions within staking operation resource with your private key.
        staking_operation.sign(private_key)

        # For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        rpc = Jimson::Client.new("HOLESKY_RPC_URL")

        # Broadcast each of the signed transactions to the network.
        staking_operation.transactions.each do |transaction|
            resp = rpc.eth_sendRawTransaction "0x"+transaction.raw.hex
            puts "Broadcasted tx hash #{resp}"
        end
        ```
    </TabItem>
    <TabItem value="Go" label="Go" default>
        ```go
        // Load your wallet's private key from which you initiated the above stake operation.
        key, err := crypto.HexToECDSA("YOUR_WALLET_PRIVATE_KEY")
        if err != nil {
            log.Fatal(err)
        }

        // Sign the transactions within staking operation resource with your private key.
        err = stakeOperation.Sign(key)
        if err != nil {
            log.Fatal(err)
        }

        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        ethClient, err := ethclient.Dial("HOLESKY_RPC_URL")
        if err != nil {
            log.Fatal(err)
        }

        // Broadcast each of the signed transactions to the network.
        for _, transaction := range stakeOperation.Transactions() {
            if err := ethClient.SendTransaction(context.Background(), transaction.Raw()); err != nil {
                log.Fatal(err)
            }

            log.Printf("Broadcasted transaction hash: %s", transaction.Raw().Hash().Hex())
        }
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/step_types/tx_step.mdx -->

Customer input needed: YES

This is the most commonly used step type and is responsible for constructing a non-custodial transactions in the required format.
Users need to sign and broadcast this transaction, after which the API monitors to make sure it has landed onchain.

Here's what it looks like within a workflow:

```json
{
  "name": "stake tx",
  "txStepOutput": {
    "unsignedTx": "02f3824268068502540be40085041dad875c83061a8094a55416de5de61a0ac1aa8970a280e04388b1de4b7b843a4b66f1c0808080",
    "txHash": "",
    "state": "STATE_PENDING_EXT_BROADCAST",
    "errorMessage": ""
  }
}
```

The table below details the full list of tx step states that are available and what they mean:

| State                       | Definition                                                                                               | Terminal State |
|-----------------------------|----------------------------------------------------------------------------------------------------------|----------------|
| STATE_NOT_CONSTRUCTED       | The unsigned transaction is being constructed                                                            | False          |
| STATE_CONSTRUCTED           | The unsigned transaction has been constructed, but not yet available for use                             | False          |
| STATE_PENDING_EXT_BROADCAST | The generated unsigned tx is waiting to be signed and broadcasted                                        | False          |
| STATE_CONFIRMING            | The transaction is waiting to be included in a block                                                     | False          |
| STATE_CONFIRMED             | The transaction has been confirmed in a block, but is awaiting additional confirmations to be finalized  | False          |
| STATE_FINALIZED             | The transaction has the correct number of confirmations and is now considered finalized onchain          | True           |
| STATE_FAILED                | The transaction has failed for one or many reasons, with the specific error provided in the step payload | True           |



<!-- File: /Users/tinahe/docs/projects/staking/docs/step_types/provision_infra_step.mdx -->

Customer input needed: NO

This step provisions the necessary infrastructure for protocols like Ethereum, setting up an Ethereum validator, for example.

Here's what it looks like within a workflow:

```json
{
  "name":  "provision-validator-infra",
  "provisionInfraStepOutput":  {
    "state":  "STATE_IN_PROGRESS"
  }
}
```

The table below details the full list of provision infra step states that are available and what they mean:

| State             | Definition                                             | Terminal State |
|-------------------|--------------------------------------------------------|----------------|
| STATE_IN_PROGRESS | Infrastructure is in the process of being provisioned  | False          |
| STATE_COMPLETED   | Infrastructure provisioning has completed successfully | True           |
| STATE_FAILED      | Infrastructure provisioning has finished but failed    | True           |



<!-- File: /Users/tinahe/docs/projects/staking/docs/step_types/wait_step.mdx -->

Customer input needed: NO

This step provides a generic way for workflows to implement waiting. There are times when we need to wait for certain onchain periods such as cooldown etc before we can execute the next step. This step provides a way to do that.

Here's what it looks like within a workflow:

```json
{
  "name":  "wait-for-cooldown-period",
  "waitStepOutput":  {
    "start": 10000,
    "current": 15000,
    "target": 20000,
    "unit": "WAIT_UNIT_CHECKPOINTS",
    "state": "STATE_IN_PROGRESS"
  }
}
```

The table below details the full list of wait step states that are available and what they mean:

| State             | Definition                                                                                                             | Terminal State |
|-------------------|------------------------------------------------------------------------------------------------------------------------|----------------|
| STATE_NOT_STARTED | The waiting has not started yet                                                                                        | False          |
| STATE_IN_PROGRESS | The step is currently waiting on the corresponding <br/>unit such as Blocks, Checkpoints etc to reach the target state | False          |
| STATE_COMPLETED   | The waiting period has finished                                                                                        | True           |



<!-- File: /Users/tinahe/docs/projects/staking/docs/quickstart.mdx -->

---
title: "Make your first request"
sidebar_label: "Quickstart"
slug: "quickstart"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import StakeWalletAddressTs from './code_languages/wallet-types/wallet-address/stake-ts.mdx'
import StakeWalletAddressRuby from './code_languages/wallet-types/wallet-address/stake-ruby.mdx'
import StakeExternalAddressTs from './code_languages/wallet-types/external-address/stake-ts.mdx'
import StakeExternalAddressGo from './code_languages/wallet-types/external-address/stake-go.mdx'
import StakeExternalAddressRuby from './code_languages/wallet-types/external-address/stake-ruby.mdx'
import SignBroadcastExternalAddressTs from './code_languages/wallet-types/external-address/sign-broadcast-ts.mdx'
import SignBroadcastExternalAddressRuby from './code_languages/wallet-types/external-address/sign-broadcast-ruby.mdx'
import SignBroadcastExternalAddressGo from './code_languages/wallet-types/external-address/sign-broadcast-go.mdx'

Coinbase Programmatic Staking empowers developers to deliver a fully-featured staking experience in their applications using one common interface across protocols.

This quickstart shows you how to stake Holesky (an Ethereum testnet) ETH to our best-in-class staking infrastructure using the Coinbase Programmatic Staking.

### What you will learn

* Installing the CDP SDK
* How to check your stakeable balance
* How to create a transaction to stake Holesky ETH
* How to sign and broadcast a staking transaction

### 1. Prerequisites

<Tabs groupId="programming-language">
    <TabItem value="typescript" label="TypeScript" default>

        The Coinbase Typescript SDK requires [Node.js](https://nodejs.org/en/download) version 18+. To verify your Node version:

        ```
        node -v
        ```

    </TabItem>

    <TabItem value="ruby" label="Ruby">

        The Coinbase Ruby SDK requires Ruby 2.7+ and recommends using 3.2+ . To verify your Ruby version:

        ```
        ruby -v
        ```

    </TabItem>

    <TabItem value="Go" label="Go">

        The Coinbase Go SDK requires Go 1.19 and recommends using 1.21+. To verify your Go version:

        ```
        go version
        ```

    </TabItem>
</Tabs>

### 2. API Key Setup

To use the CDP SDK, you need a CDP secret API key. If you need to create one, follow [this guide](/get-started/docs/cdp-keys/#creating-api-keys).

Once you have the key, place it on your filesystem. You will need to reference this file path later in your code.

### 3. Create a Workspace

In your preferred shell, create a new directory:

```shell
mkdir staking-demo
cd staking-demo
```

### 4. Install the CDP SDK

<Tabs groupId="programming-language">
    <TabItem value="typescript" label="TypeScript" default>

        Install the CDP SDK using your preferred package manager:

        ```bash
        npm install @coinbase/coinbase-sdk
        ```

    </TabItem>

    <TabItem value="ruby" label="Ruby">

        Install the CDP SDK:

        ```shell
        gem install coinbase-sdk
        ```
    </TabItem>

    <TabItem value="Go" label="Go">

        Install the Coinbase SDK:

        ```shell
        go get github.com/coinbase/coinbase-sdk-go
        ```
    </TabItem>
</Tabs>

***
:::warning match your wallet address model with your use cases
Staking can be done using two different models types depending on your use case.

* **External Address (_recommended_)** - The External Address represents the End User Custody model where the private keys are **not** managed by the CDP SDK. All of our networks will support this address model. Read more in the [External Addresses documentation](/mpc-wallet/docs/addresses#external-addresses).

* **Wallet Address** - The Wallet Address represents the Developer Custody model where the private keys are managed by the CDP SDK. Only a subset of our networks support this address model. Find out more in the [Wallet Addresses section](/mpc-wallet/docs/addresses#wallet-addresses).
:::
***

### 5a. Create a Staking Transaction using an External Address

To proceed with the stake example below, you need some Holesky ETH in your wallet. If you don't have any, you can request some from the [Ethereum Holesky Faucet](https://faucet.quicknode.com/ethereum/holesky).

<Tabs groupId="programming-language">
    <TabItem value="typescript" label="TypeScript" default>
        <StakeExternalAddressTs />
    </TabItem>
    <TabItem value="ruby" label="Ruby">
        <StakeExternalAddressRuby />
    </TabItem>
    <TabItem value="Go" label="Go">
        <StakeExternalAddressGo />
    </TabItem>
</Tabs>
The transaction that was generated is an unsigned transaction. This still needs to be signed and broadcasted to the network to stake successfully. See the next section for instructions on how to sign and broadcast the transaction.

<details>
    <summary>Sample output</summary>
    ```text
    Stakeable balance of address 0x87Bf57c3d7B211a100ee4d00dee08435130A62fA is 207.65555527344569 ETH
    Building stake operation for 0.005 ETH ... Done.
    Unsigned payloads: ["7b2274797065223a22307832222c22636861696e4964223a22307834323638222c226e6f6e6365223a223078313030222c22746f223a22307861353534313664653564653631613061633161613839373061323830653034333838623164653462222c22676173223a2230783364303930222c226761735072696365223a6e756c6c2c226d61785072696f72697479466565506572476173223a223078323534306265343030222c226d6178466565506572476173223a223078323534306265343065222c2276616c7565223a2230783131633337393337653038303030222c22696e707574223a2230783361346236366631222c226163636573734c697374223a5b5d2c2276223a22307830222c2272223a22307830222c2273223a22307830222c2279506172697479223a22307830222c2268617368223a22307832623335363130643637653936313864326338343739613638623362383163626232323734323933353935326331626334626536313364363965366662643037227d"]
    ```
</details>

***

### 5b. Create a Staking Transaction using a Wallet Address

<Tabs groupId="programming-language">
    <TabItem value="typescript" label="TypeScript" default>
        <StakeWalletAddressTs />
    </TabItem>
    <TabItem value="ruby" label="Ruby">
        <StakeWalletAddressRuby />
    </TabItem>
</Tabs>

<details>
    <summary>Sample output</summary>
    ```text
    Creating wallet...Done.
    Wallet created with ID: ab6efe3b-ea0d-4e1d-8360-cc7b47d4d024 and default address: 0x962e0561475a34e933a41b0dA6e5c4F4b9f39315
    Saving wallet seed information to local directory...Done.
    Funding wallet with testnet funds...Done.
    Wallet funding transaction: https://holesky.etherscan.io/tx/0x1963584c3953f0cd72c31f1f3560ba20f2295a4ae87b173c778a633ca6535eea
    Waiting for transaction to finalize.......Done.
    Getting stakeable balance of wallet...Done.
    Stakeable balance of wallet: 0.01 ETH
    Staking 0.00001 ETH from your wallet...Done.
    View your stake transaction: https://holesky.etherscan.io/tx/0xb6ef8dec0464569ba303d435cf5d32a5d1c9b27740fa42ebe57726f05029916e
    ```
</details>

#### Note
- To reuse the wallet created in the steps above, see [Re-instantiating a Wallet](/mpc-wallet/docs/wallets#re-instantiating-a-wallet) with the CDP SDK.
- Network congestion can sometimes delay a transaction, which can cause the funding or stake transaction to fail.

### 6. [Optional]: Sign and Broadcast your Staking Transaction (External Address only)

:::warning This optional step is only applicable to external address model only
The external wallet address model assumes developers will sign and broadcast transactions outside of our SDK. The example below shows how this can be done using [`Ethers.js`](https://docs.ethers.org/v5/) web library as an example.
:::
The previous step generated an unsigned transaction. To stake successfully, the transaction needs to be signed and broadcasted to the network.

Signing and broadcasting functionality is added to the example from above. The additional lines are highlighted for clarity.

<Tabs groupId="programming-language">
    <TabItem value="typescript" label="TypeScript" default>
        <SignBroadcastExternalAddressTs />
    </TabItem>

    <TabItem value="ruby" label="Ruby">
        <SignBroadcastExternalAddressRuby />
    </TabItem>

    <TabItem value="Go" label="Go">
        <SignBroadcastExternalAddressGo />
    </TabItem>
</Tabs>

<details>
    <summary>Sample output</summary>

    You should see the transaction being created, signed, and then broadcast to the network:

    ```text
    Stakeable balance of address 0x87Bf57c3d7B211a100ee4d00dee08435130A62fA is 207.64830262344410791 ETH
    Building a transaction to stake 0.005 ETH... Done.
    Unsigned payloads: [
    '7b2274797065223a22307832222c22636861696e4964223a22307834323638222c226e6f6e6365223a223078313031222c22746f223a22307861353534313664653564653631613061633161613839373061323830653034333838623164653462222c22676173223a2230783364303930222c226761735072696365223a6e756c6c2c226d61785072696f72697479466565506572476173223a223078323534306265343030222c226d6178466565506572476173223a223078323534306265343065222c2276616c7565223a2230783131633337393337653038303030222c22696e707574223a2230783361346236366631222c226163636573734c697374223a5b5d2c2276223a22307830222c2272223a22307830222c2273223a22307830222c2279506172697479223a22307830222c2268617368223a22307839346364373935376334373962396266396464623233326561333939393366653234636661313464663839396563343938386234613038663862613065623936227d'
    ]
    Signing the stake operation... Done.
    Broadcasting the stake operation... Broadcasted transaction hash: 0x2c66c1d716ceadeef25115cc5c2834c600cd9c35292195d9e2511c7f8c89a123
    ```
</details>

Visit the Etherscan block explorer to view the finalized transaction after it has been broadcasted. Testnet transactions may take up to a minute to be confirmed by a block explorer.


```text
https://holesky.etherscan.io/tx/{BROADCASTED_TX_HASH}
```

## Next Steps

Congratulations! You've used the CDP SDK to stake your first ETH on the Holesky testnet.

See also:

* [Shared ETH Staking (no minimum)](./networks/eth-shared/usage.mdx)
* [Dedicated ETH Staking (32 ETH minimum)](./networks/eth-dedicated/usage.mdx)



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/ts.mdx -->

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);

// The ts client abstracts away the concept of workflows and exposes helper functions
// to expose intents such as stake, unstake etc.
client.Ethereum.stake(network, stakerAddress, amount);
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/wallet-address/stake-ruby.mdx -->

Create a new file named `stake.rb` and paste the code block below:

```ruby showLineNumbers title="stake.rb"
require 'coinbase'

// highlight-start
API_KEY_FILE_PATH = "YOUR_API_KEY_FILE_PATH"
// highlight-end

# Import the CDP API key from the file.
Coinbase.configure_from_json(API_KEY_FILE_PATH)

# Create a wallet on the ethereum-holesky testnet network.
print "Creating wallet..."
wallet = Coinbase::Wallet.create(network: :ethereum_holesky)
print "Done.\n"
print "Wallet created with ID: #{wallet.id} and default address: #{wallet.default_address}\n"

# Save wallet seed locally for future use.
print "Saving wallet seed information to local directory..."
wallet.save_seed!('wallet-seed', encrypt: true)
print "Done.\n"

# Fund your wallet from a faucet with some ethereum-holesky testnet funds.
print "Funding wallet with testnet funds..."
faucet_tx = wallet.faucet
print "Done.\n"
print "Wallet funding transaction: #{faucet_tx.transaction_link}\n"

# Wait for the transaction to finalize on the blockchain.
print "Waiting for transaction to finalize"
loop do
  print "."
  sleep(2)
  balance = wallet.stakeable_balance(:eth, mode: :partial).to_f
  break unless balance.zero?
end
print "Done.\n"

# Find out how much ETH is available to stake from your wallet.
print "Getting stakeable balance of wallet..."
stakeable_balance = wallet.stakeable_balance(:eth, mode: :partial).to_f
print "Done.\n"
print "Stakeable balance of wallet: #{stakeable_balance} ETH\n"

# Stake a small amount of ETH.
print "Stake 0.00001 ETH from your wallet..."
staking_operation = wallet.stake(0.00001, :eth, mode: :partial).wait!
print "Done.\n"
print "View your stake transaction: #{staking_operation.transactions[0].transaction_link}\n"
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
```

Then run the code to create a staking transaction:

```
ruby stake.rb
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/wallet-address/stake-ts.mdx -->

Create a new file named `stake.ts` and paste the code block below:

```typescript showLineNumbers title="stake.ts"
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";
import { Decimal } from "decimal.js";

// highlight-start
const apiKeyFilePath = "YOUR_API_KEY_FILE_PATH";
// highlight-end

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Perform a stake operation.
 */
async function stake() {
  // Import the CDP API key from the file.
  const coinbase = Coinbase.configureFromJson({ filePath: apiKeyFilePath });

  // Create a wallet on the `ethereum-holesky` testnet network.
  process.stdout.write("Creating wallet...");
  const wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumHolesky });
  console.log(
    `Wallet created with ID: ${wallet.getId()} and default address: ${(await wallet.getDefaultAddress()).getId()}`,
  );

  // Save wallet seed locally for future use.
  process.stdout.write("Saving wallet seed information to local directory...");
  wallet.saveSeed("wallet-seed", true);
  console.log("Done.");

  // Fund your wallet from a faucet with some ethereum-holesky testnet funds.
  process.stdout.write("Funding wallet with testnet funds...");
  const faucetTransaction = await wallet.faucet();
  console.log("Done.");
  console.log(`Wallet funding transaction: ${faucetTransaction.getTransactionLink()}`);

  // Wait for the transaction to finalize on the blockchain.
  process.stdout.write("Waiting for transaction to finalize");
  await (async function waitForNonZeroBalance() {
    let balance: Decimal;
    do {
      process.stdout.write(".");
      await sleep(2000);
      balance = await wallet.stakeableBalance(Coinbase.assets.Eth);
    } while (balance.isZero());
  })();
  console.log("Done.");

  // Find out how much ETH is available to stake from your wallet.
  process.stdout.write("Getting stakeable balance of wallet...");
  const stakeableBalance = await wallet.stakeableBalance(Coinbase.assets.Eth);
  console.log("Done.");
  console.log(`Stakeable balance of wallet: ${stakeableBalance} ETH`);

  // Stake a small amount of ETH.
  process.stdout.write("Staking 0.00001 ETH from your wallet...");
  const stakingOperation = await wallet.createStake(0.00001, Coinbase.assets.Eth);
  console.log("Done.");
  console.log(
    `View your stake transaction: ${stakingOperation.getTransactions()[0].getTransactionLink()}`,
  );
}

(async () => {
  try {
    await stake();
  } catch (error) {
    console.error("Error during stake operation", error);
  }
})();
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
```

Then run the code to create a staking transaction:

```
npx ts-node stake.ts
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/stake-go.mdx -->

Create a new file named stake.go

```go showLineNumbers title="stake.go"
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"

	"github.com/coinbase/coinbase-sdk-go/pkg/coinbase"
)

const (
	// highlight-start
	ApiKeyFilePath = "YOUR_API_KEY_FILE_PATH"
	WalletAddress  = "YOUR_WALLET_ADDRESS"
	// highlight-end
)

func main() {
	client, err := coinbase.NewClient(
		coinbase.WithAPIKeyFromJSON(ApiKeyFilePath),
	)
	if err != nil {
		log.Fatalf("error creating coinbase client: %v", err)
	}

	address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, WalletAddress)

	stakeableBalance, err := client.GetStakeableBalance(
		context.Background(),
		coinbase.Eth,
		address,
		coinbase.WithStakingBalanceMode(coinbase.StakingOperationModePartial),
	)
	if err != nil {
		log.Fatal(err)
	}
	println(fmt.Sprintf("Stakeable balance of address %s is %f ETH", WalletAddress, stakeableBalance.Amount()))

	print("Building a transaction to stake 0.005 ETH...")
	stakeOperation, err := client.BuildStakeOperation(
		context.Background(),
		big.NewFloat(0.005),
		coinbase.Eth,
		address,
		coinbase.WithStakingOperationMode(coinbase.StakingOperationModePartial),
	)
	if err != nil {
		log.Fatalf("error building staking operation: %v", err)
	}
	println("Done.")
	println(fmt.Sprintf("Stake operation ID: %v", stakeOperation.ID()))
}
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
```

Run the code:

```
go run stake.go
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/sign-broadcast-ts.mdx -->

```typescript showLineNumbers title="stake.ts"
import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";
// highlight-start
import { ethers } from "ethers";
// highlight-end

const apiKeyFilePath = "YOUR_API_KEY_FILE_PATH";
const walletAddress = "YOUR_WALLET_ADDRESS";

/**
 * Stake 0.005 ETH on the ethereum-holesky testnet network.
 */
async function stake() {
  Coinbase.configureFromJson({ filePath: apiKeyFilePath });

  // Create a new external address on the ethereum-holesky testnet network.
  const address = new ExternalAddress(Coinbase.networks.EthereumHolesky, walletAddress);

  // Find out how much ETH is available to stake.
  const stakeableBalance = await address.stakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
  console.log("Stakeable balance of address %s is %s ETH", walletAddress, stakeableBalance);

  // Build a stake transaction for an amount <= stakeableBalance
  process.stdout.write("Building a transaction to stake 0.005 ETH... ");
  const stakingOperation = await address.buildStakeOperation(0.005, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
  console.log("Done.");

  // highlight-start
  // Load your wallet's private key from which you initiated the above stake operation.
  const walletPrivateKey = "YOUR_WALLET_PRIVATE_KEY";
  const wallet = new ethers.Wallet(walletPrivateKey);
  // Additional public Holesky RPC endpoints can be found here https://chainlist.org/chain/17000
  const holeskyNodeURL = "HOLESKY_NODE_URL";

  // Sign the transactions within staking operation resource with your wallet.
  process.stdout.write("Signing the stake operation... ");
  await stakingOperation.sign(wallet);
  console.log("Done.");

  const provider = new ethers.JsonRpcProvider(holeskyNodeURL);

  // Broadcast each of the signed transactions to the network.
  process.stdout.write("Broadcasting the stake operation... ");
  for (const tx of stakingOperation.getTransactions()) {
    const resp = await provider.broadcastTransaction(tx.getSignedPayload()!);
    console.log("Broadcasted transaction hash: %s", resp.hash);
  }
  // highlight-end
}

(async () => {
  try {
    await stake();
  } catch (error) {
    console.error("Error during stake operation", error);
  }
})();
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
```

Run the code:

```
npx ts-node stake.ts
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/sign-broadcast-ruby.mdx -->

```ruby showLineNumbers title="stake.rb"
require 'coinbase'
// highlight-start
require 'jimson'
// highlight-end

API_KEY_FILE_PATH = "YOUR_API_KEY_FILE_PATH"
WALLET_ADDRESS = "YOUR_WALLET_ADDRESS"

Coinbase.configure_from_json(API_KEY_FILE_PATH)

address = Coinbase::ExternalAddress.new(:ethereum_holesky, WALLET_ADDRESS)

stakeable_balance = address.stakeable_balance(:eth, mode: :partial).to_f
print "Stakeable balance of address #{WALLET_ADDRESS} is #{stakeable_balance} ETH\n"

print "Building stake operation for 0.005 ETH ... "
staking_operation = address.build_stake_operation(0.005, :eth, mode: :partial)
print "Done.\n"

// highlight-start
WALLET_PRIVATE_KEY = "YOUR_WALLET_PRIVATE_KEY"
HOLESKY_RPC_URL = "HOLESKY_RPC_URL"

print "Signing the stake operation ... "
staking_operation.sign(Eth::Key.new(priv: WALLET_PRIVATE_KEY))
print "Done.\n"

rpc = Jimson::Client.new(HOLESKY_RPC_URL)

print "Broadcasting the stake operation ..."
staking_operation.transactions.each do |transaction|
    resp = rpc.eth_sendRawTransaction "0x"+transaction.raw.hex
    print "Broadcasted Tx Hash: #{resp}"
end
// highlight-end
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
```

Run the code:

```
ruby stake.rb
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/stake-ruby.mdx -->

Create a new file named `stake.rb` and paste the code block below:

```ruby showLineNumbers title="stake.rb"
require 'coinbase'

// highlight-start
API_KEY_FILE_PATH = "YOUR_API_KEY_FILE_PATH"
WALLET_ADDRESS = "YOUR_WALLET_ADDRESS"
// highlight-end

Coinbase.configure_from_json(API_KEY_FILE_PATH)

address = Coinbase::ExternalAddress.new(:ethereum_holesky, WALLET_ADDRESS)

stakeable_balance = address.stakeable_balance(:eth, mode: :partial).to_f
print "Stakeable balance of address #{WALLET_ADDRESS} is #{stakeable_balance} ETH\n"

print "Building stake operation for 0.005 ETH ... "
staking_operation = address.build_stake_operation(0.005, :eth, mode: :partial)
print "Done.\n"
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
```

Then run the code to create a staking transaction:

```
ruby stake.rb
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/stake-ts.mdx -->

Create a new file named `stake.ts` and paste the code block below:

```typescript showLineNumbers title="stake.ts"
import { Coinbase, ExternalAddress, StakeOptionsMode } from "@coinbase/coinbase-sdk";

// highlight-start
const apiKeyFilePath = "YOUR_API_KEY_FILE_PATH";
const walletAddress = "YOUR_WALLET_ADDRESS";
// highlight-end

/**
 * Stake 0.005 ETH on the ethereum-holesky testnet network.
 */
async function stake() {
  Coinbase.configureFromJson({ filePath: apiKeyFilePath });

  // Create a new external address on the ethereum-holesky testnet network.
  const address = new ExternalAddress(Coinbase.networks.EthereumHolesky, walletAddress);

  // Find out how much ETH is available to stake.
  const stakeableBalance = await address.stakeableBalance(Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
  console.log("Stakeable balance of address %s is %s ETH", walletAddress, stakeableBalance);

  // Build a stake transaction for an amount <= stakeableBalance
  process.stdout.write("Building a transaction to stake 0.005 ETH...");
  const stakingOperation = await address.buildStakeOperation(0.005, Coinbase.assets.Eth, StakeOptionsMode.PARTIAL);
  console.log("Done.");
}

(async () => {
  try {
    await stake();
  } catch (error) {
    console.error("Error during stake operation", error);
  }
})();
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
```

Then run the code to create a staking transaction:

```
npx ts-node stake.ts
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/wallet-types/external-address/sign-broadcast-go.mdx -->

```go showLineNumbers title="stake.go"
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"

	"github.com/coinbase/coinbase-sdk-go/pkg/coinbase"
	// highlight-start
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	// highlight-end
)

const (
	ApiKeyFilePath = "YOUR_API_KEY_FILE_PATH"
	WalletAddress  = "YOUR_WALLET_ADDRESS"
	PrivateKey     = "YOUR_WALLET_PRIVATE_KEY"
	NodeURL        = "HOLESKY_NODE_URL"
)

func main() {
	client, err := coinbase.NewClient(
		coinbase.WithAPIKeyFromJSON(ApiKeyFilePath),
	)
	if err != nil {
		log.Fatalf("error creating coinbase client: %v", err)
	}

	address := coinbase.NewExternalAddress(coinbase.EthereumHolesky, WalletAddress)

	stakeableBalance, err := client.GetStakeableBalance(
		context.Background(),
		coinbase.Eth,
		address,
		coinbase.WithStakingBalanceMode(coinbase.StakingOperationModePartial),
	)
	if err != nil {
		log.Fatal(err)
	}

	println(fmt.Sprintf("Stakeable balance of address %s is %f ETH", WalletAddress, stakeableBalance.Amount()))

	print("Building a transaction to stake 0.005 ETH...")
	stakeOperation, err := client.BuildStakeOperation(
		context.Background(),
		big.NewFloat(0.0001),
		coinbase.Eth,
		address,
		coinbase.WithStakingOperationMode(coinbase.StakingOperationModePartial),
	)
	if err != nil {
		log.Fatalf("error building staking operation: %v", err)
	}
	println("Done.")

	// highlight-start
	// Load your wallet's private key from which you initiated the above stake operation.
	key, err := crypto.HexToECDSA(PrivateKey)
	if err != nil {
		log.Fatal(err)
	}

	// Sign the transactions within staking operation resource with your private key.
	print("Signing the stake transaction...")
	err = stakeOperation.Sign(key)
	if err != nil {
		log.Fatal(err)
	}
	println("Done.")

	// For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
	ethClient, err := ethclient.Dial(NodeURL)
	if err != nil {
		log.Fatal(err)
	}

	// Broadcast each of the signed transactions to the network.
	print("Broadcasting the stake transaction...")
	for _, transaction := range stakeOperation.Transactions() {
		if err := ethClient.SendTransaction(context.Background(), transaction.Raw()); err != nil {
			log.Fatal(err)
		}
		println(fmt.Sprintf("Broadcasted transaction hash: %s", transaction.Raw().Hash().Hex()))
	}
	// highlight-end
}
```

#### Note
- Be sure to replace the placeholder values with your own for:
```text
YOUR_API_KEY_FILE_PATH
YOUR_WALLET_ADDRESS
YOUR_WALLET_PRIVATE_KEY
HOLESKY_NODE_URL
```

Run the code:

```
go run stake.go
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/code_languages/go.mdx -->

```go
req := &api.CreateWorkflowRequest{
    Workflow: &api.Workflow{
        Action: "protocols/ethereum_kiln/networks/holesky/actions/stake",
        StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
            EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
                Parameters: &api.EthereumKilnStakingParameters_StakeParameters{
                    StakeParameters: &api.EthereumKilnStakeParameters{
                        StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
                        Amount: &api.Amount{
                            Value:    "20",
                            Currency: "ETH",
                        },
                    },
                },
            },
        },
    },
}

workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
if err != nil {
    log.Fatalf("couldn't create workflow: %s", err.Error())
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/the-staking-operation.mdx -->

---
title: "The Staking Operation"
sidebar_label: "The Staking Operation"
slug: "the-staking-operation"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Staking API simplifies management of staking transactions for  multiple networks through the _**Staking Operation**_.

### Overview

A Staking Operation is a list of transactions that need to be signed and broadcasted sequentially in order to complete a staking action such as stake, unstake etc.

### Staking Operation Lifecycle

Performing any staking activity within the Staking API initiates a Staking Operation.

This triggers an asynchronous process behind the scenes that constructs the required transactions for the staking action you specified (ex: stake, unstake, etc). For some networks, you might be presented with a single transaction, while for others, there might be multiple. These transactions might be available immediately or after necessary infrastructure setup that can take longer.

Regardless of the network or the type of staking, your interaction with the Staking Operation remains consistent. **Your only responsibility is to sign and broadcast the presented transactions as they become available**.

Here's an example of how you can start a staking operation.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Create a new external address on the `ethereum-holesky` network.
        let address = new ExternalAddress(Coinbase.networks.EthereumHolesky, "YOUR_WALLET_ADDRESS");

        // Build a stake operation. For Dedicated ETH Staking this results in
        // standing up the necessary infrastructure, and then creating deposit transactions.
        let stakingOperation = await address.buildStakeOperation(96, Coinbase.assets.Eth, StakeOptionsMode.NATIVE);
        ```

    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a new external address on the `ethereum-holesky` network.
        address = Coinbase::ExternalAddress.new(:ethereum_holesky, "YOUR_WALLET_ADDRESS")

        # Build a stake operation
        staking_operation = address.build_stake_operation(96, :eth, mode: :native)
        ```
    </TabItem>
</Tabs>

Once the staking operation is built, you can keep polling on the staking operation until it reaches a terminal state. During successful operation, this means the transactions are fully constructed and ready to be signed and broadcasted.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Example of polling the stake operation status until it reaches a terminal state.
        await stakingOperation.wait();
        ```

    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Example of polling the stake operation status until it reaches a terminal state.
        staking_operation.wait!
        ```
    </TabItem>
</Tabs>

Now, simply sign and broadcast the transactions that were created as part of the staking operation.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Load your wallet's private key from which you initiated the above stake operation.
        const wallet = new ethers.Wallet("YOUR_WALLET_PRIVATE_KEY");

        // Sign the transactions within staking operation resource with your wallet.
        await stakingOperation.sign(wallet);

        // For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        const provider = new ethers.JsonRpcProvider("HOLESKY_RPC_URL");

        // Broadcast each of the signed transactions to the network.
        stakingOperation.getTransactions().forEach(async tx => {
            let resp = await provider.broadcastTransaction(tx.getSignedPayload()!);
            console.log(resp);
        });
        ```

    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Load your wallet's private key from which you initiated the above stake operation.
        private_key = Eth::Key.new(priv: "YOUR_WALLET_PRIVATE_KEY")

        # Sign the transactions within staking operation resource with your private key.
        staking_operation.sign(private_key)

        # For Holesky, publicly available RPC URL's can be found here https://chainlist.org/chain/17000
        rpc = Jimson::Client.new("HOLESKY_RPC_URL")

        # Broadcast each of the signed transactions to the network.
        staking_operation.transactions.each do |transaction|
            resp = rpc.eth_sendRawTransaction "0x"+transaction.raw.hex
            puts "Broadcasted tx hash #{resp}"
        end
        ```
    </TabItem>
</Tabs>

### Staking Operation States

A staking operation can have the following states:

| State       | Definition                                                                                                                                                                                                          | Terminal State |
|-------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|
| initialized | The staking operation has been initialized. Behind the scenes,<br/>the necessary transactions and/or infrastructure are being created.                                                                              | False          |
| complete    | The staking operation is now complete and has no more transactions to create. <br/> In addition, for Wallet Address model this also means that the transactions <br/>have been successfully signed and broadcasted. | True           |
| failed      | The staking operation has failed.                                                                                                                                                                                   | True           |

### FAQs

#### How do I know when a staking operation is complete?

You can poll the staking operation until it reaches a terminal state of `complete` or `failed`.

The SDK provides the `wait` helper method to make this process easier.

#### What happens if a staking operation fails?

If initiating a staking operation fails, an error with a meaningful message will be returned. You can retry the staking operation as needed.

If a staking operation fails after a successful initialization, it typically means something in the backend failed with an internal error. There isn't any action you can take to recover from this, and you'll need to retry the staking operation.
You should be able to retry as often as needed until the staking operation completes successfully without worrying about any side effects.

#### When should I sign and broadcast the transactions?

Currently, our supported networks don't require transactions to be signed and broadcasted on the fly. As a result, we can wait for the staking operation to complete before proceeding ahead.

In the future, this will change to accommodate more complex networks where a set of transactions need to be signed and broadcasted before the next round of transactions can be created as they are dependent on the successful broadcast of previous transactions.

We will provide examples and documentation on how to handle when this change occurs.

#### Who should sign the transactions?

Staking API supports two address models. Answer depends on the address model you choose:

1. **External Address Model**: In this model, the private keys are not managed by the SDK. As a result, transactions need to be relayed to the owner of the external address for signing.
2. **Wallet Address Model**: In this model, the private keys are managed by the SDK. As a result, the SDK can sign and broadcast the transactions on behalf of the user.

#### Where can I reach out for help?

Feel free to reach out to us on our [staking discord channel](https://discord.com/channels/1220414409550336183/1220465786750242836) if you have any questions or need help with the Staking API.




<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/unstaking.mdx -->

---
title: "Unstake Partial ETH"
sidebar_label: "Unstake"
slug: "unstake"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './actions/unstake/code_languages/go.mdx';
import TsLangContent from './actions/unstake/code_languages/ts.mdx';

The `unstake` action triggers the withdrawal process for Partial ETH Staking.
The workflow initialization returns a corresponding unsigned transaction that a
consumer can sign and submit to the blockchain. In this case, the amount of ETH requested
to unstake is added to the exit queue with the withdrawal address. On a successful broadcast,
you are issued an 'exit queue ticket', which is a soulbound NFT token representing your withdrawal request.

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/rewards.mdx -->

---
title: "Partial ETH Rewards"
sidebar_label: "Rewards"
slug: "rewards"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './rewards/code_languages/go.mdx';
import TsLangContent from './rewards/code_languages/ts.mdx';

# Rewards

The Coinbase Staking API exposes historical rewards data you've earned while staking with Partial ETH Staking.
Once you [stake](./staking.mdx) some of your Ethereum from your wallet address, call out using the API with that wallet address
to view the rewards data.

:::info
The rewards earned via Partial ETH Staking are labeled in the API response as `PENDING_CLAIMABLE` which indicates
they have not yet landed on your wallet. In other words they are rewards not yet materialized but calculated
based on the share your stake contributed to the overall staking pool.

You must `unstake` then `claim stake` to get the earned reward amount along with your original principal.
:::

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>

<details>
  <summary>Expected output</summary>
```json
{
  "address": "0x60c7e246344ae3856cf9abe3a2e258d495fc39e0",
  "date": "2024-05-01",
  "aggregationUnit": "DAY",
  "periodStartTime": "2024-05-01T00:00:00Z",
  "periodEndTime": "2024-05-01T23:59:59Z",
  "totalEarnedNativeUnit": {
    "amount": "0.001212525541415161",
    "exp": "18",
    "ticker": "ETH",
    "rawNumeric": "1212525541415161"
  },
  "totalEarnedUsd": [
    {
      "source": "COINBASE_EXCHANGE",
      "conversionTime": "2024-05-02T00:09:00Z",
      "amount": {
        "amount": "3.61",
        "exp": "2",
        "ticker": "USD",
        "rawNumeric": "361"
      },
      "conversionPrice": "2971.419922"
    }
  ],
  "endingBalance": null,
  "protocol": "ethereum",
  "rewardState": "PENDING_CLAIMABLE"
}
```
</details>

# Stakes

<p>Coming Soon<sup>TM</sup></p>

Join the [CDP Discord server](https://discord.com/invite/cdp) to learn more!



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/rewards/code_languages/ts.mdx -->

```ts
// examples/ethereum/list-rewards.ts
import { StakingClient } from "@coinbase/staking-client-library-ts";

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);

// Defines which address and rewards we want to see
const address: string =
  '0x60c7e246344ae3856cf9abe3a2e258d495fc39e0';
const filter: string = `address='${address}' AND period_end_time > '2024-05-01T00:00:00Z' AND period_end_time < '2024-05-02T00:00:00Z'`;

// Loops through rewards array and prints each reward
var list = async function () {
  const resp = await client.Ethereum.listRewards(filter)
  resp.rewards!.forEach((reward) => {
    console.log(JSON.stringify(reward, null, 2));
  });
}

list();
```


<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/rewards/code_languages/go.mdx -->

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "log"
    "time"

    "google.golang.org/api/iterator"
    "google.golang.org/protobuf/encoding/protojson"

    "github.com/coinbase/staking-client-library-go/auth"
    "github.com/coinbase/staking-client-library-go/client"
    "github.com/coinbase/staking-client-library-go/client/options"
    "github.com/coinbase/staking-client-library-go/client/rewards"
    filter "github.com/coinbase/staking-client-library-go/client/rewards/rewardsfilter"
    api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/rewards/v1"
)

const (
    apiKeyName    = "your-api-key-name"
    apiPrivateKey = "your-api-private-key"

    address = "0x60c7e246344ae3856cf9abe3a2e258d495fc39e0"
)

func main() {
    ctx := context.Background()

    // Loads the API key.
    apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
    if err != nil {
       log.Fatalf("error loading API key: %s", err.Error())
    }

    // Creates the Coinbase Staking API client
    stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
    if err != nil {
        log.Fatalf("error instantiating staking client: %s", err.Error())
    }

     // Lists the rewards for the given address for May 1st 2024, aggregated by day.
    rewardsIter := stakingClient.Rewards.ListRewards(ctx, &api.ListRewardsRequest{
        Parent:   rewards.Ethereum,
        PageSize: 200,
        Filter: filter.WithAddress().Eq(address).
            And(filter.WithPeriodEndTime().Gte(time.Date(2024, 5, 1, 0, 0, 0, 0, time.Local))).
            And(filter.WithPeriodEndTime().Lt(time.Date(2024, 5, 2, 0, 0, 0, 0, time.Local))).String(),
    })

    // Iterates through the rewards and pretty print them.
    for {
        reward, err := rewardsIter.Next()
        if errors.Is(err, iterator.Done) {
            break
        }

        if err != nil {
            log.Fatalf("error listing rewards: %s", err.Error())
        }

        marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(reward)
        if err != nil {
            log.Fatalf("error marshaling reward: %s", err.Error())
        }

        fmt.Println(string(marshaled))
    }
}
```


<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/fundamentals.mdx -->

---
title: "Fundamentals: Partial ETH Smart Contract Flows"
sidebar_label: "Fundamentals"
slug: "fundamentals"
---

# Partial ETH Smart Contract Flows

The Coinbase Staking API makes use of Kiln smart contracts to enable Partial ETH Staking for you and your users.
All smart contracts were externally audited by Spearbit as well as by Coinbase's blockchain security team.  

The Staking API distributed stakes across a vast and diverse operator set, which is:

* Deployed to AWS and GCP across 5 non-US regions
* Utilizing a mix of Prysm & Lighthouse for Consensus
* Utilizing a mix of Geth & Nethermind for Execution
* MEV-boost enabled

## Our onchain smart contracts

* **Integration Contract** -
Deposit contract where users can send their ETH to be deposited to the pool. Developers may be given access to our shared integrator contract or have a dedicated contract deployed where there is a specific agreement with Coinbase Staking. Commissions and reward addresses are configured in this contract and settled onchain meaning offchain rebating or invoicing is required.

:::info
Shared Partial ETH integrator Ethereum contract addresses:  

**Testnet (Holesky)**: `0xA55416de5DE61A0AC1aa8970a280E04388B1dE4b`

**Mainnet**: `0x2e3956e1ee8b44ab826556770f69e3b9ca04a2a7`
:::

* **vPool** - 
Combines all end user assets across Coinbase Staking's wallet integrators. End user assets are moved from vPool to vFactory to create new validators in 32 ETH increments. For withdrawal requests, this contract manages liquidity generation to convert an end user's shares back to ETH.
* **vFactory** - 
Staking integrator contract that manages validator entry and exit. This contract handles the deposit transaction to the ETH deposit contract.

## Deposit Flow

When funds are deposited through the integration contract to the vPool, the integration contract returns shares, which represent the deposited ETH amount. These shares are held as a non-liquid `cToken` and appear as ERC-20s in the depositing wallet on block explorers. 

:::caution
The only functionality these `cToken`'s have are mint or burn.  
Integrators may choose to display shares to end users or abstract away the shares and display values in ETH.
:::  

The vPool aggregates all deposited ETH and sends it to the `vFactory` contract in 32 ETH increments. Then, `vFactory` deposits to the [Ethereum Foundation's deposit contract](https://etherscan.io/address/0x00000000219ab540356cBB839Cbe05303d7705Fa), triggering validator creation.

A `cToken` model determines the conversion rate between shares and ETH. A Coinbase Staking-managed oracle updates and **broadcasts the conversion rate once per day at 1PM UTC**. At update time, the oracle triggers calculation of commissions owed to all parties, and this amount will be assigned to the payable addresses with incoming deposits. The commission payout will be triggered automatically once a month on the first.

:::info
**For developers with a dedicated integrator contract:**  

Coinbase Staking will collect the commission recipient addresses during the onboarding process, so commissions are distributed onchain.  

Upgrading and managing the integrator's contract, which includes altering commissions or changing addresses, will approval from two-of-three parties including Coinbase Staking, Kiln and the integrating developer.
:::

<div align="center">
<img src={require('../../../assets/images/deposit_flow.png').default} alt="Deposit Flow" style={{width:'50%', height: '50%'}}/>  
</div> 

## Request Withdrawal Flow

The integration contract mints an exit ticket for the amount of shares the end user requested to withdraw. When the oracle conversion rate refreshes once per day, the `vPool` evaluates all pending exit requests. If there is not enough liquidity in the `vPool`, the `vPool` contract will exit validators to free up ETH fund exits.

<div align="center">
<img src={require('../../../assets/images/request_withdrawal_flow.png').default} alt="Request Withdrawal Flow" style={{width:'50%', height: '50%'}}/>  
</div> 


Liquid ETH entering the vPool from rewards or new deposits will fund withdrawals before new validator creation.

<div align="center">
<img src={require('../../../assets/images/liquidity_generation_flow.png').default} alt="Liquidity Generation Flow"  style={{width:'50%', height: '50%'}}/>
</div> 


## Request Claim Flow

Once the liquidity has been established, the end user can trigger the final claim process. 

<div align="center">
<img src={require('../../../assets/images/request_claim_flow.png').default} alt="Request Claim Flow" style={{width:'50%', height: '50%'}}/>
</div> 



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/staking.mdx -->

---
title: "Stake Partial ETH"
sidebar_label: "Stake"
slug: "staking"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './actions/stake/code_languages/go.mdx';
import TsLangContent from './actions/stake/code_languages/ts.mdx';

The `stake` action deposits a user's ETH (doesn't have to be a multiple of 32, hence the name Partial ETH staking) into the Coinbase Staking vPool through
the specified integration contract. The workflow initialization returns a corresponding
unsigned transaction that a consumer can sign and submit to the blockchain.
On a successful broadcast, you always receive a soulbound token that represents
the staked position and withdrawal rights.

See our [Fundamentals page](./fundamentals.mdx) for more detail on the smart contracts powering Partial ETH staking.

:::info
Shared Partial ETH integrator Ethereum contract addresses:  

**Testnet (Holesky)**: `0xA55416de5DE61A0AC1aa8970a280E04388B1dE4b`

**Mainnet**: `0x2e3956e1ee8b44ab826556770f69e3b9ca04a2a7`

**End user commission fee**: 15%  

For users with a dedicated integrator client you will have been sent your contract addresses details separately.

:::


<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/stake/code_languages/ts.mdx -->


The sample code below generates an unsigned Partial ETH staking transaction.

### 1. Instantiate your staking client
Import the necessary dependencies and create your staking client.

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);
```

### 2. Declare your variables
Add the wallet address you intend to stake from, the amount you wish stake and the network.

```ts
const stakerAddress: string = '0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE'; // replace with your wallet address where you want to stake from
const amount: string = '123'; // replace with the amount you want to stake. For partial eth, the minimum staking amount is 10 wei
const network: string = 'holesky'; // replace with the network you want to stake on, e.g. holesky, mainnet etc.
```

### 3. Generate an unsigned staking transaction
Call the staking client to generate an unsigned staking transaction using the parameters you defined in step 2.

```ts
async function stakePartialEth(): Promise<void> {
    if (stakerAddress === '') {
        throw new Error('Please set the stakerAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        // Create a new eth kiln stake workflow
        workflow = await client.Ethereum.stake(network, stakerAddress, amount);

        console.log(JSON.stringify(workflow, null, 2));
    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

stakePartialEth()
    .then(() => {
        console.log('Done creating eth staking workflow');
    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating eth staking workflow: ', error.message);
        }
    });

```
### More Examples

For dozens more examples, refer to the [examples folder](https://github.com/coinbase/staking-client-library-ts/tree/main/examples) on GitHub!



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/stake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/stake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_StakeParameters{
						StakeParameters: &api.EthereumKilnStakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
							Amount: &api.Amount{
								Value:    "20",
								Currency: "ETH",
							},
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/unstake/code_languages/ts.mdx -->

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

const stakerAddress: string = '0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE'; // replace with your wallet address where you want to unstake from
const amount: string = '123'; // replace with the amount you want to unstake
const network: string = 'holesky'; // replace with the network you want to unstake on, e.g. holesky, mainnet etc.

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);

async function unstakePartialEth(): Promise<void> {
    if (stakerAddress === '') {
        throw new Error('Please set the stakerAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        // Create a new eth kiln stake workflow
        workflow = await client.Ethereum.unstake(network, stakerAddress, amount);

        console.log(JSON.stringify(workflow, null, 2));
    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

unstakePartialEth()
    .then(() => {
        console.log('Done creating eth staking workflow');
    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating eth staking workflow: ', error.message);
        }
    });

```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/unstake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/unstake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_UnstakeParameters{
						UnstakeParameters: &api.EthereumKilnUnstakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
							Amount: &api.Amount{
								Value:    "20",
								Currency: "ETH",
							},
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/claim_stake/code_languages/ts.mdx -->

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

const stakerAddress: string = '0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE'; // replace with your wallet address where you want to claim stake from
const network: string = 'holesky'; // replace with the network you want to claim stake on, e.g. holesky, mainnet etc.

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);

async function claimStakePartialEth(): Promise<void> {
    if (stakerAddress === '') {
        throw new Error('Please set the stakerAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        // Create a new eth claim stake workflow.
        // This claims all the claimable eth for the staker address at this time.
        workflow = await client.Ethereum.claimStake(network, stakerAddress);

        console.log(JSON.stringify(workflow, null, 2));
    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

claimStakePartialEth()
    .then(() => {
        console.log('Done creating eth staking workflow');
    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating eth staking workflow: ', error.message);
        }
    });

```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/actions/claim_stake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/claim_stake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_ClaimStakeParameters{
						ClaimStakeParameters: &api.EthereumKilnClaimStakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/partial-eth/claim-stake.mdx -->

---
title: "Claim Partial ETH Stake"
sidebar_label: "Claim Stake"
slug: "claim-stake"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './actions/claim_stake/code_languages/go.mdx';
import TsLangContent from './actions/claim_stake/code_languages/ts.mdx';

The `claim_stake` action triggers the final step of claiming the withdrawable balance.
This typically is done after some days of waiting for the unstake ("exit") request to be fulfilled.
The claim stake workflow initialization returns a corresponding unsigned transaction that a
consumer can sign and submit to the blockchain. This allows the burning of your exit queue NFT
in exchange for the corresponding ETH.

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/cosmos/overview.mdx -->

---
title: "Overview"
slug: "overview"
---

# Cosmos Overview



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/cosmos/rewards.mdx -->

---
title: "Rewards"
slug: "rewards"
---

# Cosmos Rewards



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/cosmos/staking.mdx -->

---
title: "Staking"
slug: "staking"
---

# Cosmos Staking



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/unstaking.mdx -->

---
title: "Unstake Solana"
sidebar_label: "Unstake"
slug: "unstaking"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './actions/unstake/code_languages/go.mdx';
import TsLangContent from './actions/unstake/code_languages/ts.mdx';

The `unstake` action triggers the withdrawal process for Solana staking. The workflow initialization returns a corresponding
unsigned transaction that users can sign and submit to the Solana network.

More detail on Solana can be found within our [Solana protocol guide](https://www.coinbase.com/en-gb/cloud/discover/protocol-guides/guide-to-solana)

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/overview.mdx -->

---
title: "Overview"
slug: "overview"
---

# Solana Overview



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/rewards.mdx -->

---
title: "Rewards"
slug: "rewards"
---

# Solana Rewards

{/* ## Rewards */}

The Coinbase Staking API exposes historical rewards data for all validators on the Solana mainnet-beta network. 

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ListRewardsGoLangContent from './code-samples/list-rewards/go.mdx';
import ListRewardsTsLangContent from './code-samples/list-rewards/ts.mdx';

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <ListRewardsTsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <ListRewardsGoLangContent />
    </TabItem>
</Tabs>

{/*
## Stakes

The Coinbase Staking API exposes historical staking balances for all validators on the Solana mainnet-beta network.

import ListStakesGoLangContent from './code-samples/list-stakes/go.mdx';
import ListStakesTsLangContent from './code-samples/list-stakes/ts.mdx';

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <ListStakesTsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <ListStakesGoLangContent />
    </TabItem>
</Tabs>
*/}



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/code-samples/list-stakes/ts.mdx -->

```ts
import { * } from 'something'
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/code-samples/list-stakes/go.mdx -->

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/code-samples/list-rewards/ts.mdx -->

### 1. Instantiate your staking client
Import the necessary dependencies and create your staking client.

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);
```

### 2. Declare your variables
Add a sol validator address for which you want to list rewards.

```ts
const address: string = 'beefKGBWeSpHzYBHZXwp5So7wdQGX6mu4ZHCsH3uTar';
```

### 3. List rewards
Call the staking client to list rewards of a validator selected in [step 2](#2-declare-your-variables).

```ts
async function listRewards(): Promise<void> {
  if (address === '') {
    throw new Error('Please set the address variable in this file');
  }

  const filter: string = `address='${address}'`;

  try {
    // List solana rewards
    let resp = await client.Solana.listRewards(filter);

    let count = 0;

    // Loop through rewards array and print each reward
    resp.rewards!.forEach((reward) => {
      count++;
      const marshaledReward = JSON.stringify(reward);

      console.log(`[${count}] Reward details: ${marshaledReward}`);
    });
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Error listing solana rewards: ${error.message}`);
    }
  }
}

listRewards().catch((error) => {
  console.error('Error listing solana rewards: ', error.message);
});
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/code-samples/list-rewards/go.mdx -->

```go
package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	"github.com/coinbase/staking-client-library-go/client/rewards"
	filter "github.com/coinbase/staking-client-library-go/client/rewards/rewardsfilter"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/rewards/v1"
	"google.golang.org/api/iterator"
	"google.golang.org/protobuf/encoding/protojson"
)

/*
 * Run the code with 'go run examples/solana/list-rewards/main.go' to view the rewards for Coinbase Cloud's public validator.
 * Or, to view rewards for any arbitrary validator, simply replace the address below with any validator on the Solana blockchain.
 */

const (
	// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
	apiKeyName    = "your-api-key-name"
	apiPrivateKey = "your-api-private-key"

	// https://solanabeach.io/validator/6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9
	address = "6D2jqw9hyVCpppZexquxa74Fn33rJzzBx38T58VucHx9"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Create a staking client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	// List all rewards for the given address, aggregated by epoch, for epochs that ended in the last 30 days.
	rewardsIter := stakingClient.Rewards.ListRewards(ctx, &api.ListRewardsRequest{
		Parent:   rewards.Solana,
		PageSize: 20,
		Filter: filter.WithAddress().Eq(address).
			And(filter.WithPeriodEndTime().Gte(time.Now().AddDate(0, 0, -30))).
			And(filter.WithPeriodEndTime().Lt(time.Now())).String(),
	})

	// Iterates through the rewards and print them.
	for {
		reward, err := rewardsIter.Next()
		if errors.Is(err, iterator.Done) {
			break
		}

		if err != nil {
			log.Fatalf("error listing rewards: %s", err.Error())
		}

		marshaler := protojson.MarshalOptions{Indent: "\t"}
		marshaled, err := marshaler.Marshal(reward)
		if err != nil {
			log.Fatalf("error marshaling reward: %s", err.Error())
		}

		fmt.Println(string(marshaled))
	}
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/staking.mdx -->

---
title: "Stake Solana"
sidebar_label: "Stake"
slug: "staking"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './actions/stake/code_languages/go.mdx';
import TsLangContent from './actions/stake/code_languages/ts.mdx';

The `stake` action deposits a user's SOL on Coinbase's Solana community validator. The workflow initialization returns a corresponding
unsigned transaction that users can sign and submit to the Solana network.

More detail on Solana can be found within our [Solana protocol guide](https://www.coinbase.com/en-gb/cloud/discover/protocol-guides/guide-to-solana)

:::info
Coinbase Solana Validator Information:

**Validator ID:** `XkCriyrNwS3G4rzAXtG5B1nnvb5Ka1JtCku93VqeKAr`

**Validator vote account address:** `beefKGBWeSpHzYBHZXwp5So7wdQGX6mu4ZHCsH3uTar`


**End user commission fee:** 8%
:::

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/stake/code_languages/ts.mdx -->


The sample code below generates an unsigned Solana staking transaction.

### 1. Instantiate your staking client
Import the necessary dependencies and create your staking client.

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);
```

### 2. Declare your variables
Add the wallet address you intend to stake from, the amount you wish stake and the network.

```ts
const walletAddress: string = '8rMGARtkJY5QygP1mgvBFLsE9JrvXByARJiyNfcSE5Z'; // replace with your wallet address
const amount: string = '1000'; // replace with your amount. For solana it should be >= 0.1 SOL
const network: string = 'devnet'; // replace with your chosen network. We support 'mainnet' or 'devnet'
```


### 3. Generate an unsigned staking transaction 
Call the staking client to generate an unsigned staking transaction using the parameters you defined in step 2.

```ts
async function stakeSolana(): Promise<void> {
    if (walletAddress === '') {
        throw new Error('Please set the walletAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        workflow = await client.solana.stake(network, walletAddress, amount);

        console.log(JSON.stringify(workflow, null, 2));

    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

stakeSolana()
    .then(() => {
        console.log('Done creating SOL staking workflow');
        console.log('Unsigned transaction payload %s', workflow.steps[workflow.currentStepId].txStepOutput.unsignedTx)

    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating SOL staking workflow: ', error.message);
        }
    });

```

### More Examples

For dozens more examples, refer to the [examples folder](https://github.com/coinbase/staking-client-library-ts/tree/main/examples) on GitHub!



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/stake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/stake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_StakeParameters{
						StakeParameters: &api.EthereumKilnStakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
							Amount: &api.Amount{
								Value:    "20",
								Currency: "ETH",
							},
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/unstake/code_languages/ts.mdx -->

The sample code below generates an unsigned Solana unstaking transaction.

### 1. Instantiate your staking client
Import the necessary dependencies and create your staking client.

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);
```
### 2. Declare your variables
Add the wallet address you intend to unstake from, the Solana stake account, the amount you wish stake and the network.

:::info
Solana [stake accounts](https://solana.com/docs/economics/staking/stake-accounts) are automatically created when staking through the Coinbase staking API. To retrieve a users stake account please ....

Your stake amount should be defined in the native unit (lamports).
:::

```ts
const walletAddress: string = '8rMGARtkJY5QygP1mgvBFLsE9JrvXByARJiyNfcSE5Z'; // replace with your wallet address
const stakeAccount: string = '8rMGARtkJY5QygP1mgvBFLsE9JrvXByARJiyNfcSE5Z'; // can also be derived by...
const amount: string = '1000'; // replace with your amount. For solana it should be >= 0.1 SOL
const network: string = 'devnet'; // replace with your chosen network. We support 'mainnet' or 'devnet'
```

### 3. Generate an unsigned unstaking transaction 
Call the staking client to generate an unsigned staking transaction using the parameters you defined in step 2.

```ts
async function unstakeSolana(): Promise<void> {
    if (walletAddress === '') {
        throw new Error('Please set the walletAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        // Create a new eth kiln stake workflow
        workflow = await client.Solana.unstake(network, walletAddress, stakeAccount, amount);

        console.log(JSON.stringify(workflow, null, 2));
    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

unstakeSolana()
    .then(() => {
        console.log('Done creating sol unstaking workflow');
    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating sol unstaking workflow: ', error.message);
        }
    });

```

### More Examples

For dozens more examples, refer to the [examples folder](https://github.com/coinbase/staking-client-library-ts/tree/main/examples) on GitHub!



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/unstake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/unstake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_UnstakeParameters{
						UnstakeParameters: &api.EthereumKilnUnstakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
							Amount: &api.Amount{
								Value:    "20",
								Currency: "ETH",
							},
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/claim_stake/code_languages/ts.mdx -->

```ts
import { StakingClient } from '@coinbase/staking-client-library-ts';
import { Workflow } from '@coinbase/staking-client-library-ts/src/gen/coinbase/staking/orchestration/v1/workflow.pb';

const stakerAddress: string = '0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE'; // replace with your wallet address where you want to claim stake from
const network: string = 'holesky'; // replace with the network you want to claim stake on, e.g. holesky, mainnet etc.

// Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
const apiKeyName: string = 'your-api-key-name';
const apiPrivateKey: string = 'your-api-private-key';

const client = new StakingClient(apiKeyName, apiPrivateKey);

async function claimStakePartialEth(): Promise<void> {
    if (stakerAddress === '') {
        throw new Error('Please set the stakerAddress variable in this file');
    }

    let workflow: Workflow = {} as Workflow;

    try {
        // Create a new eth claim stake workflow.
        // This claims all the claimable eth for the staker address at this time.
        workflow = await client.Ethereum.claimStake(network, stakerAddress);

        console.log(JSON.stringify(workflow, null, 2));
    } catch (error) {
        let errorMessage = '';

        if (error instanceof Error) {
            errorMessage = error.message;
        }
        throw new Error(`Error creating workflow: ${errorMessage}`);
    }
}

claimStakePartialEth()
    .then(() => {
        console.log('Done creating eth staking workflow');
    })
    .catch((error) => {
        if (error instanceof Error) {
            console.error('Error creating eth staking workflow: ', error.message);
        }
    });

```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/claim_stake/code_languages/go.mdx -->

```go
package main

import (
	"context"
	"log"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/coinbase/staking-client-library-go/auth"
	"github.com/coinbase/staking-client-library-go/client"
	"github.com/coinbase/staking-client-library-go/client/options"
	api "github.com/coinbase/staking-client-library-go/gen/go/coinbase/staking/orchestration/v1"
)

var (
  // Set your api key name and private key here. Get your keys from here: https://portal.cdp.coinbase.com/access/api
  apiKeyName    = "your-api-key-name"
  apiPrivateKey = "your-api-private-key"
)

func main() {
	ctx := context.Background()

	// Loads the API key.
	apiKey, err := auth.NewAPIKey(auth.WithAPIKeyName(apiKeyName, apiPrivateKey))
	if err != nil {
		log.Fatalf("error loading API key: %s", err.Error())
	}

	// Creates the Coinbase Staking API client.
	stakingClient, err := client.New(ctx, options.WithAPIKey(apiKey))
	if err != nil {
		log.Fatalf("error instantiating staking client: %s", err.Error())
	}

	req := &api.CreateWorkflowRequest{
		Workflow: &api.Workflow{
			Action: "protocols/ethereum_kiln/networks/holesky/actions/claim_stake",
			StakingParameters: &api.Workflow_EthereumKilnStakingParameters{
				EthereumKilnStakingParameters: &api.EthereumKilnStakingParameters{
					Parameters: &api.EthereumKilnStakingParameters_ClaimStakeParameters{
						ClaimStakeParameters: &api.EthereumKilnClaimStakeParameters{
							StakerAddress: "0xdb816889F2a7362EF242E5a717dfD5B38Ae849FE",
						},
					},
				},
			},
		},
	}

	workflow, err := stakingClient.Orchestration.CreateWorkflow(ctx, req)
	if err != nil {
		log.Fatalf("couldn't create workflow: %s", err.Error())
	}

	marshaled, err := protojson.MarshalOptions{Indent: "  ", Multiline: true}.Marshal(workflow)
	if err != nil {
		log.Fatalf("error marshaling reward: %s", err.Error())
	}

	log.Printf("Workflow created: \n%s", marshaled)
}
```



<!-- File: /Users/tinahe/docs/projects/staking/docs/protocols/solana/actions/claim_stake/claim_stake.mdx -->

The `claim_stake` action triggers the final step of claiming the withdrawable balance.
This typically is done after some days of waiting for the unstake ("exit") request to be fulfilled.
The claim stake workflow initialization returns a corresponding unsigned transaction that a
consumer can sign and submit to the blockchain. This allows the burning of your exit queue NFT
in exchange for the corresponding ETH.

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import GoLangContent from './code_languages/go.mdx';
import TsLangContent from './code_languages/ts.mdx';

<Tabs>
    <TabItem value="typescript" label="Typescript" default>
        <TsLangContent />
    </TabItem>
    <TabItem value="golang" label="Golang">
        <GoLangContent />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/walletlink/docs/android-establishing-a-connection.mdx -->

---
title: "Establishing a connection"
sidebar_label: "Establishing a connection"
slug: "android-establishing-a-connection"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A connection to Coinbase Wallet can be initiated by calling the `initiateHandshake` function provided by the SDK. The function also takes in an optional `initialActions` parameter which apps can use to take certain actions along with the initial handshake request.

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val requestAccount = Web3JsonRPC.RequestAccounts().action()
val handShakeActions = listOf(requestAccount)

client.initiateHandshake(
   initialActions = handShakeActions
) { result: Result<List<ActionResult>>, account: Account? ->
    result.onSuccess { actionResults: List<ActionResult> ->
        actionResults.handleSuccess("Handshake", handShakeActions, account)
    }
    result.onFailure { err ->
        err.handleError("HandShake")
    }
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
// requestAccounts request
ArrayList<Action> actions = new ArrayList<>();
actions.add(
   new Web3JsonRPC.RequestAccounts().action(false)
);

// Initiate handshake
client.initiateHandshake(
   actions,
   (results, account) -> {
      for (ActionResult result : results) {
         if (result instanceof ActionResult.Result) {
            ((ActionResult.Result) result).getValue();
         }

         if (result instanceof ActionResult.Error) {
            ((ActionResult.Error) result).getCode();
            ((ActionResult.Error) result).getMessage();
         }
      }
   },
   error -> {
   }
);
```

</TabItem>
</Tabs>

An example handshake request is provided in the [sample application](https://github.com/MobileWalletProtocol/wallet-mobile-sdk/blob/main/android/example/src/main/java/com/coinbase/android/beta/MainActivity.kt).



<!-- File: /Users/tinahe/docs/projects/walletlink/docs/android-api-reference.mdx -->

---
title: "API Reference"
sidebar_label: "API Reference"
slug: "android-api-reference"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Actions

The `initiateHandshake` and `makeRequest` methods accept a list of actions to perform. An `Action` can be created using the `Web3JsonRPC` class.

Below is a list of supported actions for each method:

| Action | RPC method | initiateHandshake | makeRequest |
| :--- | :--- | :--- | :--- |
| [RequestAccounts](./android-api-reference.mdx#requestaccounts) | [eth_requestAccounts](https://eips.ethereum.org/EIPS/eip-1102) | ✔️ Supported | ✔️ Supported |
| [SignTransaction](./android-api-reference.mdx#signtransaction) | [eth_signTransaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_signtransaction) | ❌ Not supported | ✔️ Supported |
| [SendTransaction](./android-api-reference.mdx#sendtransaction) | [eth_sendTransaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction) | ❌ Not supported | ✔️ Supported |
| - | [eth_sign](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign) | ❌ Not supported | ❌ Not supported |
| [PersonalSign](./android-api-reference.mdx#personalsign) | [personal_sign](https://eips.ethereum.org/EIPS/eip-191) | ✔️ Supported | ✔️ Supported |
| [SignTypedDataV3](./android-api-reference.mdx#signtypeddatav3) | [eth_signTypedData_v3](https://eips.ethereum.org/EIPS/eip-712) | ✔️ Supported | ✔️ Supported |
| [SignTypedDataV4](./android-api-reference.mdx#signtypeddatav4) | [eth_signTypedData_v4](https://eips.ethereum.org/EIPS/eip-712) | ✔️ Supported | ✔️ Supported |
| [SwitchEthereumChain](./android-api-reference.mdx#switchethereumchain) | [wallet_switchEthereumChain](https://eips.ethereum.org/EIPS/eip-3326) | ✔️ Supported | ✔️ Supported |
| [AddEthereumChain](./android-api-reference.mdx#addethereumchain) | [wallet_addEthereumChain](https://eips.ethereum.org/EIPS/eip-3085) | ✔️ Supported | ✔️ Supported |
| [WatchAsset](./android-api-reference.mdx#watchasset) | [wallet_watchAsset](https://eips.ethereum.org/EIPS/eip-747) | ✔️ Supported | ✔️ Supported |

### RequestAccounts

Request that the user provides an account in the form of an Ethereum address.

#### Parameters

None.

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val requestAccounts = Web3JsonRPC.RequestAccounts().action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action requestAccounts = new Web3JsonRPC.RequestAccounts().action(false);
```

</TabItem>
</Tabs>

### PersonalSign

Sign a message by calculating an Ethereum specific signature with: `sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.

Adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious app can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.

See [personal_sign](https://eips.ethereum.org/EIPS/eip-191).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| address | `String` | Address to sign data with. |
| message | `String` | Message data to sign. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val personalSign = Web3JsonRPC.PersonalSign(
   address = "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
   message = "0xdeadbeaf"
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action personalSign = new Web3JsonRPC.PersonalSign(
       "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
       "0xdeadbeaf")
       .action(false);
```

</TabItem>
</Tabs>

### SignTypedDataV3

Sign typed structured data.

See [eth_signTypedData_v3](https://eips.ethereum.org/EIPS/eip-712).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| address | `String` | Address to sign data with. |
| typedDataJson | `String` | Typed data to sign. Structured according to the JSON-Schema specified in [EIP-712](https://eips.ethereum.org/EIPS/eip-712). |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val signTypedDataV3 = Web3JsonRPC.SignTypedDataV3(
   address = "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
   typedDataJson = typedData
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action signTypedDataV3 = new Web3JsonRPC.SignTypedDataV3(
       "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
       typedData)
       .action(false);
```

</TabItem>
</Tabs>

### SignTypedDataV4

Sign typed structured data.

See [eth_signTypedData_v4](https://eips.ethereum.org/EIPS/eip-712).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| address | `String` | Address to sign data with. |
| typedDataJson | `String` | Typed data to sign. Structured according to the JSON-Schema specified in [EIP-712](https://eips.ethereum.org/EIPS/eip-712). |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val signTypedDataV4 = Web3JsonRPC.SignTypedDataV4(
   address = "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
   typedDataJson = typedData
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action signTypedDataV4 = new Web3JsonRPC.SignTypedDataV4(
       "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
       typedData)
       .action(false);
```

</TabItem>
</Tabs>

### SignTransaction

Sign a transaction that can be submitted to the network at a later time.

See [eth_signTransaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_signtransaction).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| fromAddress | `String` | Address the transaction is sent from. |
| toAddress | `String` | **Optional**. Address the transaction is sent to. |
| weiValue | `BigInt` | Value for the transaction, in Wei. |
| data | `String` | Compiled code of a contract or the hash of the invoked method signature and encoded parameters. |
| nonce | `Int` | **Optional**. Nonce of the transaction. Allows for overwriting pending transactions that use an identical nonce. |
| gasPriceInWei | `BigInt` | **Optional**. Gas price for the transaction, in Wei. |
| maxFeePerGas | `BigInt` | **Optional**. Maximum fee per unit of gas for the transaction. |
| maxPriorityFeePerGas | `BigInt` | **Optional**. Maximum priority fee per unit of gas for the transaction. |
| gasLimit | `BigInt` | **Optional**. Gas limit for the transaction. |
| chainId | `String` | Chain ID for the transaction, as an integer string. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val signTransaction = Web3JsonRPC.SignTransaction(
   fromAddress = "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
   toAddress = "0x000000000000000000000000000000000000dEaD",
   weiValue = "10000000000000",
   data = "0x",
   nonce = 1,
   gasPriceInWei = "30000000000",
   maxFeePerGas = "60000000000",
   maxPriorityFeePerGas = "2500000000",
   gasLimit = "1000",
   chainId = "1"
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action signTransaction = new Web3JsonRPC.SignTransaction(
       "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826", // fromAddress
       "0x000000000000000000000000000000000000dEaD", // toAddress
       "10000000000000", // weiValue
       "0x", // data
       1, // nonce
       "30000000000", // gasPriceInWei
       "60000000000", // maxFeePerGas
       "2500000000", // maxPriorityFeePerGas
       "1000", // gasLimit
       "1") // chainId
       .action(false);
```

</TabItem>
</Tabs>

### SendTransaction

Send a transaction, or create a contract if the `data` field contains code.

See [eth_sendTransaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| fromAddress | `String` | Address the transaction is sent from. |
| toAddress | `String` | **Optional**. Address the transaction is sent to. |
| weiValue | `BigInt` | Value for the transaction, in Wei. |
| data | `String` | Compiled code of a contract or the hash of the invoked method signature and encoded parameters. |
| nonce | `Int` | **Optional**. Nonce of the transaction. Allows for overwriting pending transactions that use an identical nonce. |
| gasPriceInWei | `BigInt` | **Optional**. Gas price for the transaction, in Wei. |
| maxFeePerGas | `BigInt` | **Optional**. Maximum fee per unit of gas for the transaction. |
| maxPriorityFeePerGas | `BigInt` | **Optional**. Maximum priority fee per unit of gas for the transaction. |
| gasLimit | `BigInt` | **Optional**. Gas limit for the transaction. |
| chainId | `String` | Chain ID for the transaction, as an integer string. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val sendTransaction = Web3JsonRPC.SendTransaction(
   fromAddress = "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
   toAddress = "0x000000000000000000000000000000000000dEaD",
   weiValue = "10000000000000",
   data = "0x",
   nonce = 1,
   gasPriceInWei = "30000000000",
   maxFeePerGas = "60000000000",
   maxPriorityFeePerGas = "2500000000",
   gasLimit = "1000",
   chainId = "1"
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action sendTransaction = new Web3JsonRPC.SendTransaction(
       "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826", // fromAddress
       "0x000000000000000000000000000000000000dEaD", // toAddress
       "10000000000000", // weiValue
       "0x", // data
       1, // nonce
       "30000000000", // gasPriceInWei
       "60000000000", // maxFeePerGas
       "2500000000", // maxPriorityFeePerGas
       "1000", // gasLimit
       "1") // chainId
       .action(false);
```

</TabItem>
</Tabs>

### SwitchEthereumChain

Switch a wallet’s currently active chain.

See [wallet_switchEthereumChain](https://eips.ethereum.org/EIPS/eip-3326).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| chainId | `String` | ID of the chain to switch to, as an integer string. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val switchEthereumChain = Web3JsonRPC.SwitchEthereumChain(
   chainId = "1666600000"
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action switchEthereumChain = new Web3JsonRPC.SwitchEthereumChain(
       "1666600000") // chainId
       .action(false);
```

</TabItem>
</Tabs>

### AddEthereumChain

Add a chain to a wallet.

See [wallet_addEthereumChain](https://eips.ethereum.org/EIPS/eip-3085).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| chainId | `String` | ID of the chain to add, as an integer string. |
| blockExplorerUrls | `List<String>` | **Optional**. List of block explorer URL strings. |
| chainName | `String` | **Optional**. Name of the chain to add. |
| iconUrls | `List<String>` | **Optional**. List of image icons URL strings. |
| nativeCurrency | [`AddChainNativeCurrency`](./android-api-reference.mdx#addchainnativecurrency) | **Optional**. Data for the chain’s native currency. |
| rpcUrls | `List<String>` | List of RPC URL strings. Defaults to an empty list. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val addEthereumChain = Web3JsonRPC.AddEthereumChain(
   chainId = "1666600000",
   blockExplorerUrls = listOf("https://explorer.harmony.one"),
   chainName = "Harmony Mainnet",
   iconUrls = listOf("https://harmonynews.one/wp-content/uploads/2019/11/slfdjs.png"),
   nativeCurrency = AddChainNativeCurrency("ONE", "ONE", 18)
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action addEthereumChain = new Web3JsonRPC.AddEthereumChain(
       "1666600000", // chainId
       List.of("https://explorer.harmony.one"), // blockExplorerUrls
       "Harmony Mainnet", // chainName
       List.of("https://harmonynews.one/wp-content/uploads/2019/11/slfdjs.png"), // iconUrls
       new AddChainNativeCurrency("ONE", "ONE", 18)) // nativeCurrency
       .action(false);
```

</TabItem>
</Tabs>

### WatchAsset

Add and track a new asset within a wallet.

See [wallet_watchAsset](https://eips.ethereum.org/EIPS/eip-747).

#### Parameters

| Name | Type | Description |
| :--- | :--- | :--- |
| type | `String` | Type of token asset. (i.e. `ERC20`, `ERC721`). |
| options | [`WatchAssetOptions`](./android-api-reference.mdx#watchassetoptions) | Data of the asset to watch (i.e. contract address, name, icon, etc.) |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val watchAsset = Web3JsonRPC.WatchAsset(
   type = "ERC20",
   options = WatchAssetOptions(
      "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
      "WONE",
      18,
      "https://s2.coinmarketcap.com/static/img/coins/64x64/11696.png"
   )
).action()
```

</TabItem>
<TabItem value="java" label="Java">

```java
Action watchAsset = new Web3JsonRPC.WatchAsset(
       "ERC20", // type
       new WatchAssetOptions( // options
               "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a", // address
               "WONE", // symbol
               18, // decimals
               "https://s2.coinmarketcap.com/static/img/coins/64x64/11696.png") // image
       ).action(false);
```

</TabItem>
</Tabs>

## Types

### AddChainNativeCurrency

Defines a native currency to add when making a request to add a new Ethereum chain.

See [AddEthereumChain](./android-api-reference.mdx#addethereumchain).

#### Properties

| Name | Type | Description |
| :--- | :--- | :--- |
| name | `String` | Name of native currency for the chain. |
| symbol | `String` | Symbol of native currency for the chain. |
| decimals | `Int` | Decimals of precision, as an integer. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val nativeCurrency = AddChainNativeCurrency("ONE", "ONE", 18)
```

</TabItem>
<TabItem value="java" label="Java">

```java
AddChainNativeCurrency nativeCurrency = new AddChainNativeCurrency("ONE", "ONE", 18);
```

</TabItem>
</Tabs>

### WatchAssetOptions

Defines options when making a request to watch a new asset.

See [WatchAsset](./android-api-reference.mdx#watchasset).

#### Properties

| Name | Type | Description |
| :--- | :--- | :--- |
| address | `String` | Contract address for the token asset. |
| symbol | `String` | **Optional**. Symbol for the token asset. |
| decimals | `Int` | **Optional**. Decimals of precision, as an integer. |
| image | `String` | **Optional**. Logo image for the token asset. |

#### Example

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val watchAssetOptions = WatchAssetOptions(
      address = "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
      symbol = "WONE",
      decimals = 18,
      image = "https://s2.coinmarketcap.com/static/img/coins/64x64/11696.png"
   )
```

</TabItem>
<TabItem value="java" label="Java">

```java
WatchAssetOptions watchAssetOptions = new WatchAssetOptions(
        "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a", // address
        "WONE", // symbol
        18, // decimals
        "https://s2.coinmarketcap.com/static/img/coins/64x64/11696.png") // image
       );
```

</TabItem>
</Tabs>


<!-- File: /Users/tinahe/docs/projects/walletlink/docs/android-setup.mdx -->

---
title: "Setup"
sidebar_label: "Setup"
slug: "android-setup"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In order for your app to interact with Coinbase Wallet, you must add a [queries element](https://developer.android.com/guide/topics/manifest/queries-element) to your `AndroidManifest.xml` file, specifying the package name for Coinbase Wallet, `org.toshi`.

```xml AndroidManifest.xml
<queries>
      <package android:name="org.toshi" />
</queries>
```

Before the SDK can be used, it needs to be configured with an App Link to your application. This callback URL will be used by the Coinbase Wallet application to navigate back to your application.

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
CoinbaseWalletSDK(
    appContext = applicationContext,
    domain = Uri.parse("https://www.myappxyz.com"),
    openIntent = { intent -> launcher.launch(intent) }
)
```

</TabItem>
<TabItem value="java" label="Java">

```java
new CoinbaseWalletSDK(
    Uri.parse("https://www.myappxyz.com"),
    getApplicationContext(),
    CBW_PACKAGE_NAME,
    intent -> {
        startActivityForResult(intent, CBW_ACTIVITY_RESULT_CODE);
    }
);
```

</TabItem>
</Tabs>

When your application receives a response from Coinbase Wallet via App Links, this URL needs to be handed off to the SDK via the `handleResponse` function.

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
   val uri = result.data?.data ?: return@registerForActivityResult
   client.handleResponse(uri)
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
   super.onActivityResult(requestCode, resultCode, data);

   if (requestCode != CBW_ACTIVITY_RESULT_CODE) {
       return;
   }

   if (data == null) {
       return;
   }

   Uri url = data.getData();
   client.handleResponse(url);
}
```

</TabItem>
</Tabs>

An example is provided in our [sample application](https://github.com/coinbase/wallet-mobile-sdk/blob/master/android/example/src/main/java/com/coinbase/android/beta/ui/MainActivity.kt#L42).


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/trades.mdx -->

---
title: Trades
sidebar_label: Trades
slug: trades
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A trade is the act of converting one [asset](/cdp-sdk/docs/assets) into a different [asset](/cdp-sdk/docs/assets). A
trade is initiated from a [wallet](/cdp-sdk/docs/wallets) or [address](/cdp-sdk/docs/addresses) and the resulting
asset is sent back to the same source.

To trade from one asset to another, ensure that the address contains sufficient ETH to pay for
transaction fees, and sufficient funds of the asset you are trading from.

:::info
Trading is currently only supported on `base-mainnet`, which does not have a faucet. See [USDC on Coinbase Wallet](https://help.coinbase.com/en/wallet/managing-account/usdc-coinbase-wallet) in the Help docs to buy USDC on `base-mainnet`.
:::

Crypto transactions take varying amounts of time&mdash;anywhere from hundreds of milliseconds, to tens of minutes, depending on the blockchain network and wallet set-up. For example, transactions on Bitcoin can take upwards of 30 minutes, while transactions on Base take a second or two.

Once your address has ETH in it, we can call the `trade` function to trade `ETH` for `USDC`:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       **SDK Documentation**

        You can refer to the [Trade class SDK docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_trade.Trade.html) for a full list of supported methods.
        ```typescript
        // Create a wallet on `base-mainnet`
        let wallet = Wallet.create({ networkId: Coinbase.networks.BaseMainnet });

        // Fund the wallet with ETH on `base-mainnet` from an external source.

        // Trade 0.00001 Ether for USDC.
        let trade = await wallet.createTrade({
          amount: 0.00001,
          fromAssetId: Coinbase.assets.Eth,
          toAssetId: Coinbase.assets.Usdc
        });

        // Wait for the trade to settle.
        await trade.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        You can refer to the [Trade class SDK docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Trade) for a full list of supported methods.
        ```ruby
        # Create a wallet on `base-mainnet`
        wallet = Coinbase::Wallet.create(network: Coinbase::Network::BASE_MAINNET)

        # Fund the wallet with ETH on `base-mainnet` from an external source.

        # Trade 0.00001 Ether for USDC.
        trade = wallet.trade(0.00001, :eth, :usdc)

        # Wait for the trade to settle.
        trade.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        **SDK Documentation**

        You can refer to the [Trade class SDK docs](https://coinbase.github.io/cdp-sdk-python/cdp.html#cdp.trade.Trade) for a full list of supported methods.
        ```ruby
        # Create a wallet on `base-mainnet`
        wallet = Wallet.create(network_id="base-mainnet")

        # Fund the wallet with ETH on `base-mainnet` from an external source.

        # Trade 0.00001 Ether for USDC.
        trade = wallet.trade(0.00001, "eth", "usdc")

        # Wait for the trade to settle.
        trade.wait()
        ```
    </TabItem>
</Tabs>

## Querying Trade Status

You can use `status` to query a crypto transaction’s `status`.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        A common case is to check whether the transaction succeeded or failed.
        ```typescript
        let status = TransactionStatus.PENDING;

        while (status === TransactionStatus.PENDING) {
          // Do something here.
          // ....

          // Check the status of the trade.
          status = await trade.getStatus();
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        A common case is to check whether the transaction succeeded or failed after calling `wait!`.
        ```ruby
        while trade.status == Coinbase::Transaction::Status::PENDING
          # Do something here.
          # ....

          sleep 1
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        A common case is to check whether the transaction succeeded or failed after calling `wait`.
        ```python
        while trade.status is Transaction.Status.PENDING:
          # Do something here.
          # ....

          time.sleep(1)
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/requirements.mdx -->

**Node.js 18+**

The Coinbase server-side SDK requires Node.js version 18 or higher and npm version 9.7.2 or higher. To view your currently installed versions of Node.js, run the following from the command-line:

```bash
node -v
npm -v
```

We recommend installing and managing Node.js and npm versions with `nvm`.
See [Installing and Updating](https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating) in the `nvm` README for instructions on how to install `nvm`.

Once `nvm` has been installed, you can install and use the latest versions of Node.js and npm by running the following commands:

```bash
nvm install node # "node" is an alias for the latest version
nvm use node
```


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/reinstantiate_wallet.mdx -->

```typescript
// You should implement the "fetch" method to retrieve the securely persisted data object,
// keyed by the wallet ID.
let fetchedData = await fetch(wallet.getId())

// importedWallet will be equivalent to wallet.
let importedWallet = Wallet.import(fetchedData)
```

If you used the `saveSeed` function to persist a wallet's seed on your local file system, then you can use the `loadSeed` function re-instantiate the wallet.

```typescript
// Get the unhydrated wallet from the server.
const wallet = await Wallet.fetch(wallet.getId());

// You can now load the seed into the wallet from the local file.
wallet.loadSeed(filePath);
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/transfer_fund.mdx -->

```typescript title="index.js"
let anotherWallet = await Wallet.create();
console.log(`Second Wallet successfully created: `, anotherWallet.toString());

const transfer = await wallet.createTransfer({
  amount: 0.00001,
  assetId: Coinbase.assets.Eth,
  destination: anotherWallet,
});

// Wait for the transfer to settle.
await transfer.wait()

// Check if the transfer successfully completed on-chain.
if (transfer.getStatus() === 'complete') {
  console.log(`Transfer successfully completed: `, transfer.toString());
} else {
  console.error('Transfer failed on-chain: ', transfer.toString());
}
```

See [Transfers](/mpc-wallets/docs/transfers) for more information.

You can create your wallet, fund it with testnet tokens and perform your first transfer by running the following command:

```bash
npm start
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/create_wallet.mdx -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

```typescript title="index.js"
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

let coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });

// Create a Wallet
let wallet = await Wallet.create();
console.log(`Wallet successfully created: `, wallet.toString());

// Wallets come with a single default Address, accessible via getDefaultAddress:
let address = await wallet.getDefaultAddress();
console.log(`Default address for the wallet: `, address.toString());
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/fund_wallet.mdx -->

```typescript title="index.js"
const faucetTransaction = await wallet.faucet();
console.log(`Faucet transaction completed successfully: `, faucetTransaction.toString());
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/trade_assets.mdx -->

Refer to `trade.js` for a complete example of trading assets.

```typescript title="trade_assets.js"
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

let coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });

// Create a Wallet on base-mainnet to trade assets with.
let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseMainnet });

// Fund the Wallet's default Address with ETH from an external source.
// Trade 0.00001 ETH to USDC.
let trade = await wallet.createTrade({
  amount: 0.00001,
  fromAssetId: Coinbase.assets.Eth,
  toAssetId: Coinbase.assets.Usdc
});

await trade.wait();

if (trade.getStatus() === 'complete') {
  console.log(`Trade successfully completed: `, trade.toString());
} else {
  console.log(`Trade failed on-chain: `, trade.toString());
}

// Trade the wallet's full balance of USDC to WETH.
let trade2 = await wallet.createTrade({
  amount: wallet.getBalance(Coinbase.assets.Usdc),
  fromAssetId: Coinbase.assets.Usdc,
  toAssetId: Coinbase.assets.Weth,
});

await trade2.wait();

if (trade2.getStatus() === "complete") {
  console.log(`Trade successfully completed: `, trade2.toString());
} else {
  console.log(`Trade failed on-chain: `, trade2.toString());
}
```

See [Trades](/mpc-wallets/docs/trades) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/persist_wallet.mdx -->


```typescript
// Export the data required to re-instantiate the Wallet.
let data = wallet.export();
```

In order to persist the data for the wallet, you will need to implement a store method to store the exported data in a secure location. If you do not store the wallet in a secure location, you will lose access to the wallet, as well as the funds on it.

```typescript
// At this point, you should implement your own "store" method to securely persist.
// the data required to re-instantiate the Wallet at a later time.
await store(data);
```
For more information on wallet persistence, see the [wallet docs](/cdp-sdk/docs/wallets#persisting-a-wallet).

Alternatively, you can use the `saveSeed` function to persist a wallet's seed to a local file. This is a
convenience function purely for testing purposes, and should not be considered a secure method of persisting wallets.

```typescript
// Pick a file to which to save your wallet seed.
let filePath = 'my_seed.json'

// Set encrypt to true to encrypt the wallet seed with your CDP secret API key.
wallet.saveSeed(filePath, true);

console.log(`Seed for wallet ${wallet.getId()} successfully saved to ${filePath}.`);
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/NodeJS/quickstart/installation.mdx -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

#### Clone CDP SDK quickstart template

The CDP SDK provides a [quickstart template](https://github.com/coinbase/coinbase-sdk-nodejs/tree/master/quickstart-template) to get started with the SDK. Clone the repository and navigate to the quickstart template directory:

```bash
git clone git@github.com:coinbase/coinbase-sdk-nodejs.git; cd coinbase-sdk-nodejs/quickstart-template
```

Install the dependencies:
```
npm install
```

The file `index.js` contains the code to perform your first transfer with the CDP SDK. Let's break down the content of this file.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/transfers.mdx -->

---
title: Transfers
sidebar_label: Transfers
slug: transfers
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A transfer is the act of sending an [asset](/cdp-sdk/docs/assets) from one [wallet](/cdp-sdk/docs/wallets) or [address](/cdp-sdk/docs/addresses) to another.

To transfer an asset, ensure that the source contains some ETH (by using a [faucet](/cdp-sdk/docs/wallets.#faucets) if on testnet, for example). This is required because the network uses ETH to pay for transaction fees.

Crypto transactions take varying amounts of time&mdash;anywhere from hundreds of milliseconds, to tens of minutes, depending on the blockchain network and wallet set-up. For example, transactions on Bitcoin can take upwards of 30 minutes, while transactions on Base take a second or two.

Once your source has ETH in it, call the `transfer` function as follows:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       **SDK Documentation**

        You can refer to the [Transfer class SDK docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_transfer.Transfer.html) for a full list of supported methods.
        ```typescript
        // Transfer 0.00001 Ether to the destination address.
        let transfer = await wallet.createTransfer({
          amount: 0.00001,
          assetId: Coinbase.assets.Usdc,
          destination: anotherWallet
        });

        // Wait for the transfer to settle.
        await transfer.wait()
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        You can refer to the [Transfer class SDK docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Transfer) for a full list of supported methods.
        ```ruby
        # Transfer 0.00001 Ether to the destination address.
        transfer = wallet.transfer(0.00001, :eth, another_wallet)

        # Wait for the transfer to settle.
        transfer.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        **SDK Documentation**

        You can refer to the [Transfer class SDK docs](https://coinbase.github.io/cdp-sdk-python/cdp.html#cdp.transfer.Transfer) for a full list of supported methods.
        ```python
        # Transfer 0.00001 Ether to the destination address.
        transfer = wallet.transfer(0.00001, "eth", another_wallet)

        # Wait for the transfer to settle.
        transfer.wait()
        ```
    </TabItem>
</Tabs>

## Transfers of arbitrary ERC20 assets

You can transfer ERC20 assets that are not [assets supported by
symbol](/cdp-sdk/docs/assets#assets-supported-by-symbol) by using the contract address as the asset
ID.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let contractAddress = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
        let balance = await wallet.getBalance(contractAddress)

        // Transfer the full balance of the ERC20 asset to the destination wallet.
        let transfer = await wallet.createTransfer({
          amount: balance,
          assetId: contractAddress,
          destination: anotherWallet
        });

        // Wait for the transfer to settle.
        await transfer.wait()
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        contract_address = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
        balance = wallet.balance(contract_address)

        # Transfer the full balance of the ERC20 asset to the destination wallet.
        transfer = wallet.transfer(balance, contract_address, another_wallet)

        # Wait for the transfer to settle.
        transfer.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        contract_address = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
        balance = wallet.balance(contract_address)

        # Transfer the full balance of the ERC20 asset to the destination wallet.
        transfer = wallet.transfer(balance, contract_address, another_wallet)

        # Wait for the transfer to settle.
        transfer.wait()
        ```
    </TabItem>
</Tabs>

## Gasless Transfers

Coinbase will pay for the gas for transfers of USDC, EURC and cbBTC on Base Mainnet and Base Sepolia!

To initiate a USDC transfer on Base Mainnet with gas fees covered, set the `gasless` flag to true.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
          ```typescript
          import { Wallet, TimeoutError } from '@coinbase/coinbase-sdk';

          // Create a wallet on Base Mainnet
          let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseMainnet });

          // Out-of-Band: Fund the wallet's default address with USDC

          // Create a gasless USDC transfer on Base Mainnet
          try {
            const transfer := await wallet.createTransfer({
              amount: 0.00001,
              assetId: Coinbase.assets.Usdc,
              destination: anotherWallet,
              gasless: true
            });
          } catch (error) {
            console.error(`Error while transferring: `, error);
          }

          // Wait for transfer to land on-chain.
          try {
            await transfer.wait();
          } catch (err) {
            if (err instanceof TimeoutError) {
              console.log("Waiting for transfer timed out");
            } else {
              console.error("Error while waiting for transfer to complete: ", error);
            }
          }

          // Check if transfer successfully completed on-chain
          if (transfer.getStatus() === 'complete') {
            console.log('Transfer completed on-chain: ', transfer.toString());
          } else {
            console.error('Transfer failed on-chain: ', transfer.toString());
          }
          ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
          ```ruby
          # Create a wallet on Base Mainnet
          wallet = Coinbase::Wallet.create(network_id: Coinbase::Network::BASE_MAINNET)

          # Create another wallet on Base Mainnet to transfer funds to.
          another_wallet = Coinbase::Wallet.create(network_id: Coinbase::Network::BASE_MAINNET)

          # Out-of-Band: Fund the wallet's default address with USDC

          # Create a gasless USDC transfer on Base Mainnet
          transfer = wallet.transfer(0.000001, :usdc, another_wallet, gasless: true)

          # Wait for transfer to land on-chain
          begin
            transfer.wait!
          rescue Timeout::Error => e
            puts "Waiting for transfer timed out"
          end

          if transfer.status == Coinbase::Transaction::Status::COMPLETE
            puts "Transfer successfully landed on-chain: #{transfer.transaction_link}"
          else
            puts "Transfer failed on-chain: #{transfer.transaction_link}"
          end
          ```
    </TabItem>
    <TabItem value="Python" label="Python">
          ```python
          # Create a wallet on Base Mainnet
          wallet = Wallet.create(network_id="base-mainnet")

          # Create another wallet on Base Mainnet to transfer funds to.
          another_wallet = Wallet.create(network_id="base-mainnet")

          # Out-of-Band: Fund the wallet's default address with USDC

          # Create a gasless USDC transfer on Base Mainnet
          transfer = wallet.transfer(0.000001, "usdc", another_wallet, gasless=True)

          transfer.wait()

          if transfer.status is Transaction:.Status.COMPLETE:
            print(f"Transfer successfully landed on-chain: {transfer.transaction_link}")
          else:
            print(f"Transfer failed on-chain: {transfer.transaction_link}")
          ```
    </TabItem>
</Tabs>

## Querying Transfer Status

It is possible to query a crypto transaction’s `status`.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        A common case is to check whether the transaction succeeded or failed.
        ```typescript
        let status = TransferStatus.PENDING;

        while (status === TransferStatus.PENDING) {
          // Do something here.
          // ....

          // Check the status of the transfer.
          status = await transfer.getStatus();
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        A common case is to check whether the transaction succeeded or failed after calling `wait!`.
        ```ruby
        while transfer.reload.status == Transfer::Status::PENDING
          # Do something here.
          # ....

          sleep 1
        end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        A common case is to check whether the transaction succeeded or failed after calling `wait`.
        ```python
        while transfer.status is Transfer.Status.PENDING:
          # Do something here.
          # ....

          transfer.reload()
          time.sleep(1)
        ```
    </TabItem>
</Tabs>

## Processing multiple transfers for same address

When creating multiple transfers for the same source address, it is important to create them sequentially instead of all at once. Wait for the previous transfer to have a final state (`COMPLETE` / `FAILED`) before creating a new one. Creating multiple transactions simultaneously can lead to failures due to how nonces are managed by the CDP APIs.

An example of how to process transactions sequentially:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
          ```typescript
          for (let i = 0; i < 5; i++)  {
            try {
              const transfer = await wallet.createTransfer({
                amount: 0.00001,
                assetId: Coinbase.assets.Eth,
                destination: wallet,
              });

              await transfer.wait()
            } catch (error) {
              console.error(`Error while transferring: `, error);
            }
        }
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
          ```ruby
          5.times do
            transfer = wallet.transfer(0.000001, :eth, another_wallet).wait!
            puts transfer.transaction_link
          end
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
          ```python
          for i in range(5):
              transfer = wallet.transfer(0.000001, "eth", another_wallet).wait()
              print(f"{transfer.transaction_link}")
        ```
    </TabItem>
</Tabs>

## Transfer to ENS or Basenames

[ENS](https://app.ens.domains/) names and [Basenames](https://www.base.org/names) are core building blocks that enable anyone to establish their onchain identity by registering
human-readable names for their wallet addresses.
CDP SDK supports ENS or Basename as the destination address in your transfers.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
         ```typescript
        // Transfer 0.00001 Ether to the address that belongs to the Base Name/ENS.
        let transfer := await wallet.createTransfer({
          amount: 0.00001,
          assetId: Coinbase.assets.Usdc,
          destination: "my-ens-name.base.eth",
          gasless: true
        });

        # Wait for the transfer to settle.
        await transfer.wait()
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Transfer 0.00001 Ether to the address that belongs to the Base Name/ENS.
        transfer = wallet.transfer(0.00001, :eth, 'my-ens-name.base.eth')

        # Wait for the transfer to settle.
        transfer.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # Transfer 0.00001 Ether to the address that belongs to the Base Name/ENS.
        transfer = wallet.transfer(0.00001, "eth", "my-ens-name.base.eth")

        # Wait for the transfer to settle.
        transfer.wait()
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/smart-contract-deployments.mdx -->

---
title: Smart Contract Deployments
sidebar_label: Smart Contract Deployments
slug: smart-contract-deployments
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The CDP SDK supports deploying ERC-20s (fungible tokens), ERC-721s (NFTs), and ERC-1155s (MultiTokens). If you’d like to see support for additional contracts or deploying arbitrary smart contracts, contact us in the [CDP Discord](https://discord.com/invite/cdp/).

- **Token Creator**: Allow anyone to create new memecoins and tokens using your platform.
- **Expansive Gaming Ecosystem**: Create autonomous in-game currencies and items.
- **NFT-based Verification for Photos**: Create a camera app that mints an NFT upon photo capture to prove its provenance.
- **Loyalty Programs**: Introduce a loyalty program for your users that can be used across your platform and on others.
- **AI-Generated Game Assets**: Use fungible and non-fungible tokens alongside artificial intelligence to allow users to build their own characters and assets.

## Examples
:::tip
See [supported methods](#Supported-Methods) at the bottom of this page for a list of all the methods supported by each contract type.
:::

### Deploying an ERC-20

[ERC-20 tokens](https://docs.openzeppelin.com/contracts/5.x/erc20) are the most common type of fungible token on Ethereum. Interacting with the contract is done through the [Transfer API](./transfers) for simple transfers, or with the `invokeContract` function for other calls. All [standard ERC-20 functions](https://docs.openzeppelin.com/contracts/5.x/api/token/erc20#ERC20) are supported. Below is an example of how to call a deployed ERC20 contract.

Tokens can be created and interacted with by doing the following:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { SmartContract } from "@coinbase/coinbase-sdk"

        // Create a new wallet (or import an existing one)
        const wallet = await Wallet.create();

        // Ensure the wallet is funded manually or via the base-sepolia faucet:
        // await wallet.faucet();

        // Deploy the token
        const deployedContract: SmartContract = await wallet.deployToken({
            name: "ExampleCoin",
            symbol: "EXAM",
            totalSupply: 100000
        });
        await deployedContract.wait();
        
        // Interact with the deployed contract
        const approveArgs = {
            spender: "0xApprovedSpender",
            value: "10000000",
        };

        const contractInvocation = await wallet.invokeContract({
            contractAddress: deployedContract.getContractAddress(),
            method: "approve",
            args: approveArgs,
        });
        await contractInvocation.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a wallet (or import an existing one)
        wallet = Coinbase::Wallet.create

        # Fund the wallet manually or via `wallet.faucet`

        # Deploy the token
        deployed_contract = wallet.deploy_token(name: "ExampleCoin", symbol: "EXAM", total_supply: 100000)
        deployed_contract.wait!

        # Interact with the deployed contract
        contract_invocation = wallet.invoke_contract(
          contract_address: deployed_contract.contract_address,
          method: 'approve',
          args: { spender: '0xApprovedSpender', value: '10000000' }
        )
        contract_invocation.wait!
        ```
    </TabItem>
        <TabItem value="Python" label="Python">
        ```python
        # Create a wallet (or import an existing one)
        wallet = Wallet.create()

        # Fund the wallet manually or via `wallet.faucet`

        # Deploy the token
        deployed_contract = wallet.deploy_token("ExampleCoin", "EXAM", 100000)
        deployed_contract.wait()

        # Interact with the deployed contract
        invocation = wallet.invoke_contract(
          contract_address=deployed_contract.contract_address, 
          method="approve", 
          args={"spender": "0xApprovedSpender", "value": "10000000"})
        invocation.wait()
        ```
    </TabItem>
</Tabs>

### Deploying an ERC-721

[ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721) is the standard for non-fungible tokens on Ethereum.  The URI is the location of the metadata for the NFT. To properly interact with marketplaces, the URI must be a [valid JSON file](https://docs.opensea.io/docs/metadata-standards).

The creation and interaction process is similar to fungible tokens:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        const nft = await wallet.deployNFT({
            name: "My NFT",
            symbol: "MNFT",
            baseURI: "https://my-nft-base-uri.com/metadata/",
        });
        await nft.wait();

        // Mint 3 token to destinationAddress by calling invokeContract
        const mintTx = await wallet.invokeContract({
            contractAddress: nft.getContractAddress(),
            method: "mint",
            args: {
                to: "0xDestinationAddress",
                quantity: "3",
            },
        });
        await mintTx.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        nft = wallet.deploy_nft(name: "My NFT", symbol: "MNFT", base_uri: "https://my-nft-base-uri.com/metadata/")
        nft.wait!

        # Mint 3 tokens to a destination address
        mint_tx = wallet.invoke_contract(
          contract_address: nft.contract_address,
          method: 'mint',
          args: { to: '0xDestinationAddress', quantity: '3'}
        )

        # Wait for the transaction to complete
        mint_tx.wait!
        ```
    </TabItem>
        <TabItem value="Python" label="Python">
        ```python
        deployed_contract = wallet.deploy_nft("My NFT", "MNFT", "https://my-nft-base-uri.com/metadata/")
        deployed_contract.wait()

        # Interact with the deployed contract
        invocation = wallet.invoke_contract(
          contract_address=deployed_nft.contract_address, 
          method="mint", 
          args={"to": "0xDestinationAddress", "quantity": "3"})
        invocation.wait()
        ```
    </TabItem>
</Tabs>

### Deploying an ERC-1155

[ERC-1155](https://docs.openzeppelin.com/contracts/5.x/erc1155) is the standard for multi-token fungible tokens on Ethereum. Instead of minting one token at a time, you can mint multiple tokens in a single transaction with the same metadata. [This guide](https://github.com/ethereum/ercs/blob/master/ERCS/erc-1155.md#erc-1155-metadata-uri-json-schema) explains how to define the metadata properly.

Two mint methods are supported: `mint` and `mintBatch`. `mint` requires a single `to` address and `mintBatch` requires an array of `to` addresses and an array of `values` of the same length.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        const multiToken = await wallet.deployMultiToken({
          uri: "https://example.com/{id}.json",
        });
        await multiToken.wait();

        const multiTokenAddress = multiToken.getContractAddress();

        // Mint 1 token to destinationAddress by calling invokeContract
        const mintTx = await addr.invokeContract({
          contractAddress: multiTokenAddress,
          method: "mint",
          args: {
            to: "0xDestinationAddress",
            id: "1",
            value: "1",
          },
        });
        await mintTx.wait();
        
        // let's do a mintBatch
        const mintBatchTx = await addr.invokeContract({
          contractAddress: multiTokenAddress,
          method: "mintBatch",
          args: {
            to: "0xDestinationAddress",
            ids: ["1", "2"],
            values: ["5", "10"],
          },
        });
        await mintBatchTx.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        multi_token = wallet.deploy_multi_token(uri: "https://example.com/{id}.json")
        multi_token.wait!

        # Mint 1 token to destinationAddress by calling invoke_contract
        mint_tx = wallet.invoke_contract(
          contract_address: multi_token.contract_address,
          method: 'mint',
          args: { to: '0xDestinationAddress', id: '1', value: '1' }
        )
        mint_tx.wait!

        # let's do a mintBatch
        mint_batch_tx = wallet.invoke_contract(
          contract_address: multi_token.contract_address,
          method: 'mintBatch',
          args: { to: '0xDestinationAddress', ids: ['1', '2'], values: ['5', '10'] }
        )
        mint_batch_tx.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        deployed_contract = wallet.deploy_multi_token("https://example.com/{id}.json")
        deployed_contract.wait()

        # Interact with the deployed contract
        mint_tx = wallet.invoke_contract(
          contract_address=deployed_contract.contract_address, 
          method="mint", 
          args={"to": "0xDestinationAddress", "id": "1", "value": "1"})
        mint_tx.wait()

        # let's do a mintBatch
        mint_batch_tx = wallet.invoke_contract(
          contract_address=deployed_contract.contract_address, 
          method="mintBatch", 
          args={"to": "0xDestinationAddress", "ids": ["1", "2"], "values": ["5", "10"]})
        mint_batch_tx.wait()
        ```
    </TabItem>
</Tabs>

## Supported Methods

### ERC-20 Functions

**Inherits:**
[ERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.0/contracts/token/ERC20/ERC20.sol)

#### constructor

Constructor to initialize the ERC20 token with a name, symbol, and initial supply.
The entire initial supply is assigned to the deployer of the contract.

```solidity
constructor(string memory name, string memory symbol, uint256 amount) ERC20(name, symbol);
```
### ERC-721 Functions
**Inherits:**
[ERC721AQueryable](https://github.com/chiru-labs/ERC721A/blob/main/contracts/extensions/ERC721AQueryable.sol), [Ownable2Step](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.0/contracts/access/Ownable2Step.sol)

#### constructor

Constructor to initialize the token with name, symbol, base URI, and deployer address


```solidity
constructor(string memory name, string memory symbol, string memory baseURI)
    ERC721A(name, symbol)
    Ownable(msg.sender);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`name`|`string`|The name of the token|
|`symbol`|`string`|The symbol of the token|
|`baseURI`|`string`|The base URI for the token metadata|


#### mint

Mint a single token to a specified address

*Only the contract owner can call this function*


```solidity
function mint(address to) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint the token to|


#### mint
Mint a single token to a specified address with data

*Only the contract owner can call this function*


```solidity
function mint(address to, bytes memory data) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint the token to|
|`data`|`bytes`|The data to pass to the minted token|


#### mint

Mint a specified quantity of tokens to a specified address

*Only the contract owner can call this function*


```solidity
function mint(address to, uint8 quantity) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint tokens to|
|`quantity`|`uint8`|The number of tokens to mint|


#### mint

Mint a specified quantity of tokens to a specified address with data

*Only the contract owner can call this function*


```solidity
function mint(address to, uint8 quantity, bytes memory data) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to mint tokens to|
|`quantity`|`uint8`|The number of tokens to mint|
|`data`|`bytes`|The data to pass to the minted tokens|

### ERC-1155 Functions
**Inherits:**
[ERC1155Supply](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.0/contracts/token/ERC1155/extensions/ERC1155Supply.sol), [Ownable2Step](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v5.0/contracts/access/Ownable2Step.sol)

#### constructor

Constructs an ERC1155 token with a URI, owned by the deployer of the contract


```solidity
constructor(string memory uri) ERC1155(uri) Ownable(msg.sender);
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`uri`|`string`|The URI for all the token metadata, should be of the format "https://token-cdn-domain/{id}.json"|


#### mint

Mint a new token which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1


```solidity
function mint(address to, uint256 id, uint256 value) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to receive the minted tokens|
|`id`|`uint256`|The ID of the token to mint|
|`value`|`uint256`|The amount of tokens to mint|


#### mint

Mint a new token which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1


```solidity
function mint(address to, uint256 id, uint256 value, bytes memory data) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to receive the minted tokens|
|`id`|`uint256`|The ID of the token to mint|
|`value`|`uint256`|The amount of tokens to mint|
|`data`|`bytes`|Additional data with no specified format, to be passed to the receiver contract|


#### mintBatch

Mint a batch of new tokens which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1


```solidity
function mintBatch(address to, uint256[] memory ids, uint256[] memory values) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to receive the minted tokens|
|`ids`|`uint256[]`|The IDs of the tokens to mint|
|`values`|`uint256[]`|The amounts of tokens to mint, must be the same length as `ids`|


#### mintBatch

Mint a batch of new tokens which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1


```solidity
function mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external onlyOwner;
```
**Parameters**

|Name|Type|Description|
|----|----|-----------|
|`to`|`address`|The address to receive the minted tokens|
|`ids`|`uint256[]`|The IDs of the tokens to mint|
|`values`|`uint256[]`|The amounts of tokens to mint, must be the same length as `ids`|
|`data`|`bytes`|Additional data with no specified format, to be passed to the receiver contract|



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/wallets.mdx -->

---
title: Wallets
sidebar_label: Wallets
slug: wallets
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

A wallet is a collection of [addresses](./addresses.mdx) on a network. Wallets come with a single default
address. Wallets can hold a balance of one or more assets.

A wallet's assets are controlled via the addresses' private keys, which in turn are derived from a seed.
Think of a seed / private key as the password to a wallet. For more, see [What is a private key?](https://www.coinbase.com/learn/crypto-basics/what-is-a-private-key).

Wallets can be either [Coinbase-Managed](#coinbase-managed-wallets) or
[Developer-Managed](#developer-managed-wallets), based on how the wallet's private keys are managed.

Wallets can create new addresses, list their addresses, list their balances and transfer assets to other addresses or wallets.

Wallets are created on a specific [network](/cdp-sdk/docs/networks). Certain features are only available on certain networks. For example, [faucets](#faucets) are only available on Base Sepolia and [trades](/mpc-wallets/docs/trades) are only available on Base Mainnet.

## Creating a Wallet

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       **SDK Documentation**

        Refer to the [Wallet class SDK docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_wallet.Wallet.html) for a full list of supported methods.

        ```typescript
        let wallet = await Wallet.create();
        ```

        A wallet starts with a single `defaultAddress`. You can also create more addresses in the wallet, and list them:

        ```typescript
        // Get the default_address in the wallet.
        let address = await wallet.getDefaultAddress();
        console.log(`Address: ${address}`);

        // Create another address in the wallet.
        let address2 = await wallet.createAddress();
        console.log(`Address: ${address2}`);

        // List the two addresses in the wallet.
        let addresses = wallet.getAddresses();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        Refer to the [Wallet class SDK docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Wallet) for a full list of supported methods.

        ```ruby
        wallet = Coinbase::Wallet.create
        ```

        A wallet starts with a single `default_address`. You can also create more addresses in the wallet, and list them:

        ```ruby
        # Get the default_address in the wallet.
        address1 = wallet.default_address

        # Create another address in the wallet.
        address2 = wallet.create_address

        # List the two addresses in the wallet.
        wallet.addresses
        ```
    </TabItem>
        <TabItem value="Python" label="Python">
        **SDK Documentation**

        Refer to the [Wallet class SDK docs](https://coinbase.github.io/cdp-sdk-python/cdp.html#cdp.Wallet) for a full list of supported methods.

        ```python
        wallet = Wallet.create()
        ```

        A wallet starts with a single `default_address`. You can also create more addresses in the wallet, and list them:

        ```python
        # Get the default_address in the wallet.
        address1 = wallet.default_address

        # Create another address in the wallet.
        address2 = wallet.create_address()

        # List the two addresses in the wallet.
        wallet.addresses
        ```
    </TabItem>
</Tabs>

By default, wallets are created for Base Sepolia. The CDP SDK also supports creating wallets for Base Mainnet. To do that, pass the network ID as an argument:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       **SDK Documentation**
        ```typescript
        let wallet = Wallet.create({ networkId: Coinbase.networks.BaseMainnet });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        wallet = Coinbase::Wallet.create(network: Coinbase::Network::BASE_MAINNET)
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        wallet = Wallet.create(network_id="base-mainnet")
        ```
    </TabItem>
</Tabs>

## Securing a Wallet
There are [two types of wallets](/mpc-wallet/docs/wallet-types) that can be created using the CDP SDK, depending on how the
private keys are managed: Coinbase-Managed (2-of-2) Wallets and Developer-Managed (1-of-1) Wallets. Developer-Managed wallets are best for rapid testing and prototyping, while Coinbase-Managed wallets are recommended for any production environments.

:::warning Turn on IP Whitelisting in the CDP Portal
IP whitelisting provides another layer of protection for your wallets and prevents an attacker from using your CDP API key outside of your infrastructure. See [API Key Security Best Practices](/get-started/docs/cdp-key-security) on how to enable IP whitelisting on your secret API keys.
:::

:::warning Secure your CDP Secret API Key
- MPC does not safeguard your CDP API keys or account credentials. If your CDP login or API keys are comprimised, funds held in MPC wallets could potentially be at risk. 
- Coinbase recommends that you store your secret API keys in a dedicated solution such as AWS secret manager, Azure key vault, or some other secure storage option. Your CDP account can be used to mint new secret API keys and should be stored securely using a password manager. Always follow the principle of least privilege when deciding who within your organization can access your CDP account funds.  
:::

### Coinbase-Managed Wallets

Coinbase offers a state-of-the-art Multiparty Computation (MPC) wallet solution that splits private keys
into two shares between Coinbase and the developer, ensuring improved security. Even if a developer’s share of the private key is compromised, assets will not be at risk as long as the CDP API keys and account credentials remain secure.

These Coinbase-Managed (2-of-2) Wallets use the [Server-Signer](/mpc-wallet/docs/serversigners),
a deployable component that simplifies key management and provides a secure way to sign transactions.
For production applications requiring maximal security, we recommend using Coinbase-Managed Wallets.

### Developer-Managed Wallets

For Developer-Managed (1-of-1) Wallets,
it is your responsibility as the developer to securely store the data required to re-instantiate your
wallets. For example, you may choose to store this data in an encrypted database. As with any 1-of-1 wallet solution, losing access to the wallet could result in a loss of funds. 

The CDP SDK provides two key pieces of information to persist Developer-Managed (1-of-1) Wallets:

- Seed: a 32-byte hexadecimal string. This seed is used to derive all of the private keys in the wallet and
provides access to spend the assets in the wallet.
- Wallet ID: a string used to identify the wallet.

This information is encapsulated in a wallet's export data, obtained by calling the `export` method:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Export the data required to re-instantiate the wallet. The data contains the seed and the ID of the wallet.
        let data = wallet.export();

        // You should implement the "store" method to securely persist the data object,
        // which is required to re-instantiate the wallet at a later time. For ease of use,
        // the data object is converted to a Hash first.
        await store(data);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Export the data required to re-instantiate the wallet. The data contains the seed and the ID of the wallet.
        data = wallet.export

        # You should implement the "store" method to securely persist the data object,
        # which is required to re-instantiate the wallet at a later time. For ease of use,
        # the data object is converted to a Hash first.
        store(data.to_hash)
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # Export the data required to re-instantiate the wallet. The data contains the seed and the ID of the wallet.
        data = wallet.export_data()

        # You should implement the "store" method to securely persist the data object,
        # which is required to re-instantiate the wallet at a later time. For ease of use,
        # the data object is converted to a dictionary first.
        store(data.to_dict())
        ```
    </TabItem>
</Tabs>

It is your responsibility as the developer to securely store the seeds and wallet IDs required to re-instantiate your wallets.
For example, you may choose to store this data in an encrypted database.



#### Persisting Locally

For convenience, we provide a method that stores the wallet seed to a local file that you specify.

:::danger
This is an insecure method of storing wallet seeds and should only be used for development purposes.
:::

To save your wallet seed, run the following:
<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Pick a file to which to save your wallet seed.
         let filePath = 'my_seed.json';

        // Set encrypt to true to encrypt the wallet seed with your CDP secret API key.
        w.saveSeed(filePath, true);

        console.log(`Seed for wallet ${w.getId()} successfully saved to ${filePath}.`);
        ```

        To encrypt the local wallet data, set `encrypt` to true. Note that your CDP secret API key also serves as the encryption key
        for the seed persisted locally. To re-instantiate wallets with encrypted data, ensure that your SDK is configured with
        the same API key when invoking `saveSeed` and `loadSeed`.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Pick a file to which to save your wallet seed.
        file_path = 'my_seed.json'

        # Set encrypt: true to encrypt the wallet seed with your CDP secret API key.
        wallet.save_seed!(file_path, encrypt: true)

        puts "Seed for wallet #{wallet.id} successfully saved to #{file_path}."
        ```

        To encrypt the local wallet data, set `encrypt` to true. Note that your CDP secret API key also serves as the encryption key
        for the seed persisted locally. To re-instantiate wallets with encrypted data, ensure that your SDK is configured with
        the same API key when invoking `save_seed!` and `load_seed`.
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # Pick a file to which to save your wallet seed.
        file_path = "my_seed.json"

        # Set encrypt=True to encrypt the wallet seed with your CDP secret API key.
        wallet.save_seed(file_path, encrypt=True)

        print(f"Seed for wallet {wallet.id} successfully saved to {file_path}.")
        ```

        To encrypt the local wallet data, set `encrypt` to true. Note that your CDP secret API key also serves as the encryption key
        for the seed persisted locally. To re-instantiate wallets with encrypted data, ensure that your SDK is configured with
        the same API key when invoking `save_seed` and `load_seed`.
    </TabItem>
</Tabs>


#### Re-instantiating a Wallet

The seed and the ID of the wallet are required to re-instantiate a wallet when a new session is started.
This data is encapsulated in the export data of a wallet, which should be securely persisted by the developer.

The following code demonstrates how to import the data required to re-instantiate a wallet.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // You should implement the "fetch" method to retrieve the securely persisted data object,
        // keyed by the wallet ID.
        let fetchedData = await fetch(wallet.getId());


        // importedWallet will be equivalent to wallet.
        let importedWallet = await Wallet.import(fetchedData);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # You should implement the "fetch" method to retrieve the securely persisted data object,
        # keyed by the wallet ID.
        fetched_data = fetch(wallet.id)

        # imported_wallet will be equivalent to wallet.
        imported_wallet = Coinbase::Wallet.import(fetched_data)
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # You should implement the "fetch" method to retrieve the securely persisted data object,
        # keyed by the wallet ID.
        fetched_data = fetch(wallet.id)

        # imported_wallet will be equivalent to wallet.
        imported_wallet = Wallet.import_data(fetched_data)
        ```
    </TabItem>
</Tabs>

##### Hydrating a Wallet

Another method of re-instantiating a wallet is to "hydrate" it. Hydration consists of two parts:

- Fetching the wallet from the server
- Setting the correct seed on the wallet

A wallet that is fetched from the server is at first unhydrated, because only you, the developer, have access to the
wallet's seed, and the wallet is unaware of its own seed. Unhydrated wallets can perform read operations, such as viewing
balances and addresses, but not write operations, such as creating new addresses or transferring funds.

The code below demonstrates the process of fetching an unhydrated wallet, and hydrating it with a seed:
<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Get the unhydrated wallet from the server.
        const fetchedWallet = await Wallet.fetch(wallet.getId());

        // The fact that fetchedWallet is unhydrated is encapsulated by the canSign method.
        // For example, calling fetchedWallet.createAddress() would throw an error.
        console.log(`fetchedWallet is hydrated: ${fetchedWallet.canSign()}`);

        // To hydrate the wallet, set the correct seed on it.
        fetchedWallet.setSeed(fetchedData.seed);

        // The wallet is now hydrated, and can create addresses and sign transactions.
        console.log(`fetchedWallet is hydrated: ${fetchedWallet.canSign()}`);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Get the unhydrated wallet from the server.
        fetched_wallet = Coinbase::Wallet.fetch(wallet.id)

        # The fact that fetched_wallet is unhydrated is encapsulated by the can_sign? method.
        # For example, calling fetched_wallet.create_address would throw an error.
        puts "fetched_wallet is hydrated: #{fetched_wallet.can_sign?}"

        # To hydrate the wallet, set the correct seed on it.
        fetched_wallet.seed = fetched_data.seed

        # The wallet is now hydrated, and can create addresses and sign transactions.
        puts "fetched_wallet is hydrated: #{fetched_wallet.can_sign?}"
        ```
    </TabItem>
</Tabs>

##### Hydrating Locally

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        If you used the `saveSeed` function to persist a wallet's seed to a local file, then you can first fetch the
        unhydrated wallet from the server, and then use the `loadSeed` method to re-instantiate the wallet.

        ```typescript
        // Get the unhydrated wallet from the server.
        const fetchedWallet = await Wallet.fetch(w.getId());

        // You can now load the seed into the wallet from the local file.
        // fetchedWallet will be equivalent to importedWallet.
        await fetchedWallet.loadSeed(filePath);
        ```

        If you set `encrypt` to true when calling `saveSeed`, ensure that your SDK is configured with the same API key
        when calling `loadSeed`.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        If you used the `save_seed!` function to persist a wallet's seed to a local file, then you can first fetch
        the unhydrated wallet from the server, and then use the `load_seed` method to re-instantiate the wallet.

        ```ruby
        # Get the unhydrated wallet from the server.
        fetched_wallet = Coinbase::Wallet.fetch(wallet.id)

        # You can now load the seed into the wallet from the local file.
        # fetched_wallet will be equivalent to imported_wallet.
        fetched_wallet.load_seed(file_path)
        ```

        If you set `encrypt` to true when calling `save_seed!`, ensure that your SDK is configured with the same API
        key when calling `load_seed`.
    </TabItem>
        <TabItem value="Python" label="Python">
        If you used the `save_seed` function to persist a wallet's seed to a local file, then you can first fetch
        the unhydrated wallet from the server, and then use the `load_seed` method to re-instantiate the wallet.

        ```python
        # Get the unhydrated wallet from the server.
        fetched_wallet = Wallet.fetch(wallet.id)

        # You can now load the seed into the wallet from the local file.
        # fetched_wallet will be equivalent to imported_wallet.
        fetched_wallet.load_seed(file_path)
        ```

        If you set `encrypt` to true when calling `save_seed`, ensure that your SDK is configured with the same API
        key when calling `load_seed`.
    </TabItem>
</Tabs>

## Faucets

On Testnets, asset issuers and others provide faucets for developers to easily fund their wallets for testing purposes.

The CDP SDK provide a `faucet` method to fund your wallet with ETH and USDC on Base Sepolia testnet. You are allowed 100 faucet claims per 24-hour window.

Faucet requests can be made at the [wallet](./wallets.mdx) and [address](./addresses.mdx) levels in the CDP SDK.

### ETH faucet on Base Sepolia

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        let faucetTransaction = await wallet.faucet();
        console.log(`Faucet transaction: ${faucetTransaction}`);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        faucet_transaction = wallet.faucet

        puts "Faucet transaction successfully completed: #{faucet_transaction}"

        faucet_transaction.transaction_hash
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        faucet_transaction = wallet.faucet()

        print(f"Faucet transaction successfully completed: {faucet_transaction}")

        faucet_transaction.transaction_hash
        ```
    </TabItem>
</Tabs>

### USDC faucet on Base Sepolia

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        let faucetTransaction = await wallet.faucet(Coinbase.assets.Usdc);
        console.log(`Faucet transaction: ${faucetTransaction}`);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        faucet_transaction = wallet.faucet(asset_id: :usdc)

        puts "Faucet transaction successfully completed: #{faucet_transaction}"

        faucet_transaction.transaction_hash
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        # Create a faucet request that returns a Faucet transaction, which can be used to retrieve the transaction hash.
        faucet_transaction = wallet.faucet(asset_id="usdc")

        print(f"Faucet transaction successfully completed: {faucet_transaction}")

        faucet_transaction.transaction_hash
        ```
    </TabItem>
</Tabs>

Other faucets on Base Sepolia:

- [ETH faucet](https://www.ethereum-ecosystem.com/faucets/base-sepolia)
- [USDC faucet](https://faucet.circle.com/) - specify Base Sepolia as the network

## Retrieving Balances

To view the amount of [assets](/cdp-sdk/docs/assets) held in a wallet, call the following:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let balance = await wallet.listBalances();
        ```

        Or, to obtain the balance of a specific asset, call the following:

        ```typescript
        let balance = await wallet.getBalance(Coinbase.assets.Eth);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        wallet.balances
        ```

        Or, to obtain the balance of a specific asset, call the following:

        ```ruby
        wallet.balance(:eth)
        ```
    </TabItem>
        <TabItem value="Python" label="Python">
        ```python
        wallet.balances()
        ```

        Or, to obtain the balance of a specific asset, call the following:

        ```
        wallet.balance("eth")
        ```
    </TabItem>
</Tabs>

Note that `list` method only returns balances for the top 20 [assets supported by symbol](/cdp-sdk/docs/assets#assets-supported-by-symbol). For other assets, use `get` as follows.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
     ```typescript
     let balance = await wallet.getBalance("0x036CbD53842c5426634e7929541eC2318f3dCF7e")
     ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
    ```ruby
    balance = wallet.balance('0x036CbD53842c5426634e7929541eC2318f3dCF7e')
    ```
    </TabItem>
    <TabItem value="Python" label="Python">
    ```python
    balance = wallet.balance("0x036CbD53842c5426634e7929541eC2318f3dCF7e")
    ```
    </TabItem>
</Tabs>

## Creating webhook

You can create a webhook for the current wallet.

The webhook allow you to receive real-time notifications of wallet activity directly to your application via a specified callback notification URL. 
By creating a webhook, you can monitor events related to all the addresses for a wallet. See [Webhook page](https://docs.cdp.coinbase.com/onchain-data/docs/webhooks) for more details on supported event types, event payload and supported [networks](https://docs.cdp.coinbase.com/onchain-data/docs/networks).

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let webhook = await wallet.createWebhook('https://call_back_uri_for_webhook')
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```
        webhook = wallet.create_webhook(notification_uri: "https://call_back_uri_for_webhook")
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/requirements.mdx -->


**Python 3.10+**

Before using the SDK, ensure that you have the correct version of Python installed and the `pip` package manager. The SDK requires Python 3.10 or higher. You can check your Python version and `pip` installation by running the following code:

```bash
python --version
pip --version
```

If you need to upgrade your Python version, you can download and install the latest version of Python from the [official Python website](https://www.python.org/downloads/). For `pip`, refer to the [official pip documentation](https://pip.pypa.io/en/stable/installation/) for installation instructions.


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/reinstantiate_wallet.mdx -->


```python
# You should implement the "fetch" method to retrieve the securely persisted data object,
# keyed by the wallet ID.
fetched_data = fetch(wallet1.id)

# wallet1 will be equivalent to wallet.
wallet1 = Wallet.import_data(fetched_data)
```

If you used the `save_seed` function to persist a wallet's seed on your local file system, then you can use the `load_seed` function re-instantiate the wallet.

```python
# Get the unhydrated wallet from the server.
wallet3 = Wallet.fetch(wallet.id)

# You can now load the seed into the wallet from the local file.
wallet3.load_seed(filePath)
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/transfer_fund.mdx -->


```python
# Create a new wallet wallet3 to transfer funds to.
another_wallet = Wallet.create()

print(f"Wallet successfully created: {another_wallet}")

transfer = wallet.transfer(0.00001, "eth", another_wallet).wait()

print(f"Transfer successfully completed: {transfer}")
```

See [Transfers](/mpc-wallets/docs/transfers) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/create_wallet.mdx -->


```python
api_key_name = "Copy your secret API key name here."
api_key_private_key = "Copy your secret API key's private key here."

Cdp.configure(api_key_name, api_key_private_key)

print("CDP SDK has been successfully configured with CDP API key.")
```

Another way to initialize the SDK is by sourcing the API key from the JSON file that contains your secret API key, downloaded from the CDP portal.

```python
Cdp.configure_from_json("~/Downloads/cdp_api_key.json")

print("CDP SDK has been successfully configured from JSON file.")
```

Now create a wallet. Wallets are created with a single default address.

```python
# Create a wallet with one address by default.
wallet = Wallet.create()
```

Wallets come with a single default address, accessible via `default_address`:

```python
# A wallet has a default address.
address = wallet.default_address
```


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/fund_wallet.mdx -->


```python
# Fund the wallet with a faucet transaction.
faucet_tx = wallet1.faucet()

print(f"Faucet transaction successfully completed: {faucet_tx}")
```


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/trade_assets.mdx -->


```python
# Create a wallet on `base-mainnet` to trade assets with.
wallet = Wallet.create(network_id="base-mainnet")

print("Wallet successfully created: {wallet}")

# Fund wallet's default address with ETH from an external source.

# Trade 0.00001 ETH to USDC
trade = wallet.trade(0.00001, "eth", "usdc").wait()

if trade.status is Transaction.Status.COMPLETE:
  print(f"Trade successfully completed: {trade}")
else:
  print(f"Trade failed on-chain: {trade}")

# Trade the wallet's full balance of USDC to WETH
trade2 = wallet.trade(wallet.balance("usdc"), "usdc", "weth").wait()

if trade2.status is Transaction.Status.COMPLETE:
  print(f"Second trade successfully completed: {trade2}")
else:
  print(f"Second trade failed on-chain: {trade}")
```

See [Trades](/mpc-wallets/docs/trades) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/persist_wallet.mdx -->


```python
# Export the data required to re-instantiate the wallet.
data = wallet1.export_data()
```

To persist the data for a wallet, you must implement a `store` method to store the exported data in a secure location. If you do not store the wallet in a secure location, you will lose access to the wallet, as well as the funds on it.

```python
# You should implement the "store" method to securely persist the data object,
# which is required to re-instantiate the wallet at a later time. For ease of use,
# the data object is converted to a dictionary first.
store(data.to_dict())
```

For more information on wallet persistence, see [wallet docs](/cdp-sdk/docs/wallets#persisting-a-wallet).

Alternatively, you can use the `save_seed` function to persist a wallet's seed to a local file. This is a
convenience function for testing purposes, and should not be considered a secure method of persisting wallets.

```python
# Pick a file to which to save your wallet seed.
file_path = "my_seed.json"

# Set encrypt: true to encrypt the wallet seed with your CDP secret API key.
wallet1.save_seed(file_path, encrypt=True)

print(f"Seed for wallet {wallet1.id} successfully saved to {file_path}.")
```


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Python/quickstart/installation.mdx -->

**Onchain Payment Replit Template**
There is a [Replit template](https://replit.com/@CoinbaseDev/Python-Onchain-Payments?v=1#README.md) for enabling automated mass payments using the CDP SDK in Python.

Run the following from the command line:

```bash
pip install cdp-sdk
```

**For `python` REPL**

Use the Python Standard REPL (`python`) to leverage Python's built-in REPL and quickly explore the functionality of our SDK.

Run the following from the command line:

```bash
python
```

After running `python`, import the module:

```python
from cdp import *
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/serversigners.mdx -->

---
title: Server-Signer
sidebar_label: Server-Signers
slug: serversigners
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import createStack from '../assets/images/create_cloud_formation_stack.png';
import configureStack from '../assets/images/configure_cloud_formation_stack.png'
import waitStack from '../assets/images/wait_stack_creation.png'
import completeCreationStack from '../assets/images/complete_stack_creation.png'
import signerArchitecture from '../assets/images/signer_architecture.png'
import disableAutoRotation from '../assets/images/disable_auto_rotation.png'

## Overview

The Coinbase Server-Signer simplifies key management with a no-code setup on your cloud provider. You can host your Server-Signer on AWS with a quick 10-minute setup.

The wallets created with Server-Signer are Multi-Party Computation (MPC) wallets, leveraging advanced cryptographic techniques for enhanced usability and security. MPC wallets split private keys into two shares, one held by Coinbase and the other by the developer, ensuring two security domains protect your wallets.

The Server-Signer manages your key share and collaborates with Coinbase to sign transactions using advanced cryptography. It is designed to be secure, scalable, and resilient and provides the following capabilities:

- **Key Generation**: The Server-Signer generates private keys for the wallets you create using the CDP SDK. The keys are securely generated through a multi-party computation (MPC) protocol. One keyshare is stored in the developer's AWS account and the other keyshare with Coinbase.
- **Key Signing**: The Server-Signer connects to CDP backend to facilitate transaction signing. It only signs transactions that you, as a developer, create using the CDP SDK.
- **Backup**: Key materials are backed-up by AWS with the Aurora DB backup policies.
- **Security**: Private keys created by Server-Signer are always split between Coinbase servers and your own Server-Signer instance. No single party ever holds a full private key, meaning a signature requires cooperation between both parties. This provides security even if one's systems are compromised.

The Server-Signer operates on a shared security model between Coinbase, the developer and their cloud provider, AWS.

:::danger secure your aws account
Coinbase cannot guarantee the security of the Server-Signer deployment as this is not a hosted solution. You, the developer are responsible for securing your AWS account where Server-Signer is deployed, and performing upgrades on your system, etc.
:::

The Server-Signer is currently supported only on AWS. You can easily deploy it using [AWS CloudFormation](https://console.aws.amazon.com/cloudformation) with just a few clicks. Once deployed, the Server-Signer continuously monitors the CDP backend for any new actions related to your CDP Project.

It performs two types of operations:
- **Distributed key generation** for wallets within your project.
- **Creating a signature for a transaction** that is pending broadcast for wallets in your project.

<img src={signerArchitecture} alt="Server-Signer Architecture" width="800" />

## Deploy Server-Signer on AWS

### Step 1: Create CDP Secret API key and AWS SSH KeyPair

****CDP Secret API Key****

Download a Secret API key from the [Coinbase Developer Platform](https://portal.cdp.coinbase.com/access/api). See [CDP API Key Management](/get-started/docs/cdp-keys) for detailed steps. This key is used by your Server-Signer to authenticate against CDP backend services.

:::info
Only one Server-Signer can be associated with a CDP Project.
:::

****SSH Keypair for AWS****

Create an SSH KeyPair on your AWS account for debugging purposes following the instructions in the AWS doc, [Step 1: Create EC2 SSH Key Pair](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html). The SSH key is required for accessing the EC2 instance to see the logs and for debugging.

### Step 2: Create a new stack

1. Go to [CloudFormation stack](https://console.aws.amazon.com/cloudformation) on your AWS Console.
2. Click on the **Create stack** button.
3. Select "Choose an existing template" option.
4. Select "Amazon S3 URL" as your template source.
5. Paste the URL https://cdp-server-signer-public.s3.amazonaws.com/templates/0.0.12/server-signer.yaml in the **Amazon S3 URL** field.
6. Click **Next** on this page.

<br />

> Configuration example
<img src={createStack} alt="Creating a CloudFormation stack for Server-Signer" width="800" style={{ border: '1px solid lightgrey' }} />

<br />

### Step 3: Specify stack details

1. Fill in the following parameters in the CloudFormation stack:
   - **Stack name**: Enter a unique stack name to identify your stack.
   - **CDPAPIKeyName**: Enter the name of your downloaded CDP secret API key. This corresponds to the `name` field in the JSON file.
   - **CDPAPIKeyPrivateKey**: Enter the CDP secret API key itself. This corresponds to the `privateKey` field in the JSON file.
   - **ImageID**: Enter the optional AMI ID if you prefer to use a different AMI. The default AMI used will be the Amazon Linux 2 AMI in your region.
   - **SSHIPRange**: Configure the IP range from which you want to SSH to your Server-Signer.
   - **SSHKeyName**: Select the EC2 key pair you created in step 1.
   - **UseMPCServerSigner:** Set this to true.

:::caution SSH IP Range
By default, the Server-Signer allows SSH access from any IP, provided it has the right SSH key. Use `SSHIPRange` to restrict this to a specific IP range for security reasons.
:::

<br />

> CloudFormation stack details example
<img src={configureStack} alt="Specify CloudFormation stack details" width="800" style={{ border: '1px solid lightgrey' }} />

<br />
2. Click **Next** on this page.

### Step 4: Configure stack options

1. Under "Stack failure options", select the "Delete all newly created resources" option.
2. Click **Next** on this page.

### Step 5: Review and create stack

1. Check **I acknowledge that AWS CloudFormation might create IAM resources**.
2. Click **Submit** on this page.

### Step 6: Wait for the stack to be created

<br />

> Example of the Stack creation in progress
<img src={waitStack} alt="Configure CloudFormation stack" width="800" style={{ border: '1px solid lightgrey' }} />

<br />

Within ~10 minutes, your stack will be created. You will see `CREATE_COMPLETE` status for the stack as shown below.

<br />
> Example of the completed stack
<img src={completeCreationStack} alt="Successful deployment of Server-Signer" width="800" style={{ border: '1px solid lightgrey' }} />

<br />

The stack creates the following resources created for your Server-Signer:
- **EC2 instance** that hosts the Server-Signer.
- **Aurora DB** that stores the encrypted MPC key share and other metadata for your Wallets.
- **Symmetric AWS KMS key** that performs encryption operations for the MPC protocol.
- **Asymmetric AWS KMS key** that is used as identity key for the Server-Signer.
- **Security groups and IAM roles** for the functioning of the Server-Signer.

### Step 7: Disable auto-rotation of RDS password

The RDS cluster is created with auto-rotation enabled by default for the database password. However, the stack does not account for the default 7-day rotation policy, and it is necessary to disable it. To disable the rotation policy, follow the steps below:

- Go to AWS Secrets Manager [here](https://us-east-1.console.aws.amazon.com/secretsmanager/listsecrets?region=us-east-1&search=all%3Drds).
- Find the secret associated with primary RDS DB cluster for your CloudFormation stack.
- Go to rotation tab, click on `Edit rotation` and disable `Automatic Rotation`

<br />
> Disable auto-rotation of RDS password
<img src={disableAutoRotation} alt="Disable Auto-rotation of RDS password" width="800" style={{ border: '1px solid lightgrey' }} />

<br />

The Server-Signer is now ready to be used with the CDP SDK. To make the Server-Signer perform its actions, invoke the methods in CDP SDK.

## Use CDP SDK to create MPC Wallets with Server-Signer

### Initialize the CDP SDK

Follow the [quickstart](/mpc-wallet/docs/quickstart) to get an overview of the CDP SDK. To initialize the CDP SDK, use a CDP secret API key that is created for the same project as the Server-Signer. This is important because Server-Signers are scoped to the specific project they are created for and can only create wallets within that project.

:::caution
Server-Signers are created for a specific CDP project. Ensure that the CDP secret API key used to initialize the SDK
is for the same project.
:::

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        const coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        Coinbase.configure_from_json('~/Downloads/cdp_api_key.json')
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
        ```python
        Cdp.configure_from_json("~/Downloads/cdp_api_key.json")
        ```
    </TabItem>
</Tabs>

### Configure CDP SDK to use Server-Signer

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        Coinbase.useServerSigner = true;
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        Coinbase.configuration.use_server_signer = true
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
        ```python
        Cdp.use_server_signer = True
        ```
    </TabItem>
</Tabs>

### Verify that your CDP project has a Server-Signer assigned
<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
            import { ServerSigner } from "@coinbase/coinbase-sdk";
            let serverSigner = await ServerSigner.getDefault();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
            signer = Coinbase::ServerSigner.default
        ```
    </TabItem>
</Tabs>

If you do not see a Server-Signer for your project, ensure the deployment of the Server-Signer was successful and follow the [troubleshooting guide](#troubleshooting-the-server-signer).

From this point forward, all wallets created using the CDP SDK in the current session are managed by the Server-Signer.

### Create a wallet using Server-Signer

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseSepolia });
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        wallet = Coinbase::Wallet.create(network: Coinbase::Network::BASE_SEPOLIA)
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
        ```python
        wallet = Wallet.create("base-sepolia")
        ```
    </TabItem>
</Tabs>

Wallet creation will take a few seconds because the transaction is orchestrated using the Server-Signer.

### Sign a transaction using Server-Signer

Transfers, and other write verbs, require the Server-Signer's participation. Transactions for wallets backed by a Server-Signer will be automatically signed.
Refer to the [Transfers](/mpc-wallets/docs/transfers) section for more details on how to create a transfer.

## Troubleshooting the Server-Signer

### Accessing the Server-Signer logs on CloudWatch

Go to CloudWatch log group for your ServerSigner [here](https://console.aws.amazon.com/cloudwatch/home?region=us-west-2#logsV2:log-groups/log-group/%2Fvar%2Flog%2Fserver-signer.log).
Click on log stream and you will see the logs for your Server-Signer.

### Server-Signer not participating in wallet creation / signing as expected

If your wallet creation / signing times out, it indicates the Server-Signer is down. Check the logs of your Server-Signer to see what went wrong. If you do not see logs, check if the process is running in the instance:

#### SSH to the EC2
Use the SSH key created in Step 1 for this. Follow the instructions [here](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/connect-linux-inst-ssh.html).
```bash
ssh -i /path/my-key-pair.pem ubuntu@{PUBLIC_IP_OF_YOUR_EC2_INSTANCE}
```

#### Restart the process if required

Check the status of the service with the following command:
```bash
systemctl status cdp-signer.service

# You should see an active service like
## cdp-signer.service - Coinbase Developer Platform Signer Service
###     Loaded: loaded (/etc/systemd/system/cdp-signer.service; disabled; vendor preset: enabled)
###     Active: active (running)
```

If you do not see the process running, restart the system service with the following command:
```bash
sudo systemctl start cdp-signer.service
```

If the issue is not resolved with above steps, reach us out on discord at [Coinbase Developers Discord](https://discord.gg/cdp) for help.

## Updating the Server-Signer binary to latest version

When a new version of Server-Signer is released, the existing binary in the CloudFormation stack can be updated to the latest version with the following steps:

### SSH to the instance

```bash
ssh -i /path/my-key-pair.pem ubuntu@{PUBLIC_IP_OF_YOUR_EC2_INSTANCE}
```

### Run the following script to update the Server-Signer binary

```bash
set -e
SERVICE_NAME="cdp-signer"
# Update the below URL with the latest version of the Server-Signer binary.
SERVER_SIGNER_BINARY_URL="https://api.cdp.coinbase.com/server-signer/assets/0.0.13/cdp-signer.deb.zip"
TEMP_DIR="/tmp/new-binary"
mkdir -p $TEMP_DIR && cd $TEMP_DIR
curl -o $TEMP_DIR/new-binary.zip $SERVER_SIGNER_BINARY_URL
unzip -o $TEMP_DIR/new-binary.zip
sudo dpkg -i $TEMP_DIR/cdp-signer_*_amd64.deb
sudo systemctl start $SERVICE_NAME
echo "Binary updated and service restarted successfully."
```

The binary is updated now and can be verified by creating a new wallet or signing with an existing one.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/supported-solidity-types.mdx -->

---
title: Solidity Types Supported in CDP SDK
sidebar_label: Supported Solidity Types
slug: supported-solidity-types
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The following table explains how the CDP SDK handles different Solidity types. For support with other Solidity types, contact us on the [CDP Discord](https://discord.gg/Ext5Xf4tZa).

| Solidity Type | Parameter Argument | Example |
|----------------|---------------------|-----------------|
| int8, int16, int32, int64, int128, int256 | string | `"-42"` |
| uint8, uint16, uint32, uint64, uint128, uint256 | string | `"123456"` |
| function | hex-encoded string (4-byte array) | `"0xa9059cbb"` |
| bool | boolean | `true` |
| bytes | hex-encoded string | `"0x1234abcd"` |
| fixed bytes (e.g., bytes32) | hex-encoded string (fixed length) | `"0x000000000000000000000000a0b82847ab218b36c1d19d4a2e9eb0ce3606eb48"` |
| string | string | `"Hello, World!"` |
| address | hex-encoded string | `"0xBe9895146f7AF43049ca1c1AE358B0541Ea49704"` |
| arrays | array with elements following type rules | `["1", "2", "3"]` |
| tuple | array of tuple fields | `["John Doe", "25", "0xBe9895146f7AF43049ca1c1AE358B0541Ea49704"]` |


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/welcome.mdx -->

---
title: Welcome
sidebar_label: Welcome
slug: welcome
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Coinbase MPC Wallets provide programmatic blockchain access through easy-to-use APIs. This solution enables developers to create secure wallets and automate onchain actions with minimal code, focusing on product innovation rather than complex wallet infrastructure management.

## Designed for Developers

Unlike most wallets designed for end-users, MPC wallets are built specifically for developer needs:

- **Simplicity**: Automate common blockchain interactions with powerful, scalable, and straightforward API calls including [Trades](./trades.mdx), [Transfers](./transfers.mdx), [Staking](https://docs.cdp.coinbase.com/staking/docs/welcome), and [Onchain Interactions](./smart-contract-interactions). Our SDKs support NodeJS, Ruby, Python, and Go.
- **Enhanced Security**: Utilize Coinbase's best-in-class security and advanced Multi-Party Computation (MPC) for robust private key protection on 2-of-2 [Coinbase-Managed Wallets](https://docs.cdp.coinbase.com/mpc-wallet/docs/wallets/#coinbase-managed-wallets). See [Securing a Wallet](/mpc-wallet/docs/wallets#securing-a-wallet) to learn more. 
- **Multi-Network Support**: 
  - Primary support for Base, where developers benefit from a rich suite of Coinbase developer tools.
  - Additional support for Ethereum, Arbitrum, and Polygon, with more networks coming soon.
- **Gasless sends for USDC, EURC & cbBTC**: Send USDC, EURC and cbBTC without paying gas fees on Base Mainnet.


## Custom Security Options

[Multi-Party Computation](https://www.coinbase.com/learn/wallet/what-is-a-multi-party-computation-mpc-wallet) (MPC) is a cryptographic technique that splits a private key into multiple shards, eliminating single points of failure.

MPC Wallets support different levels of security that meet your needs:

1. **[Developer-Managed Wallet](https://docs.cdp.coinbase.com/mpc-wallet/docs/wallets/#developer-managed-wallets) (1-of-1)**
   - Quick wallet creation with self-managed keys
   - Ideal for rapid development and testing
   - Lighter security using traditional full private keys

2. **[Coinbase-Managed Wallet](https://docs.cdp.coinbase.com/mpc-wallet/docs/wallets/#coinbase-managed-wallets) (2-of-2)**
   - Shared key management with Coinbase
   - Splits private key into multiple shards, eliminating single points of failure
   - Recommended for production environments where funds are at risk 

:::note
Additional custody and key management models are planned for future releases, along with key backup and recovery.
:::

## Solutions You Can Build

- **[Automated One-to-Many Payments](/learn/docs/mass-payments)**: Send to millions of recipients with a few lines of code.
- **[Onchain AI Agents](/learn/docs/ai-wallets)**: Integrate financial capabilities into AI systems.
- **Global Payment Solutions**: Implement fast, free USDC transfers in existing applications.
- **In-Game Economies**: Streamline in-game asset and transaction handling.
- **Fintech Innovation**: Incorporate crypto functionalities to traditional financial products.

:::tip
The MPC Wallet pairs perfectly with our self-custodial, user-facing [Smart Wallet](https://www.smartwallet.dev/why). Together, you get the benefit of programmatic developer actions and a seamless user onboarding experience. To see the differences between the two solutions, see our [Wallet Comparison](/cdp-apis/docs/wallet-comparison).
:::

## Start Building Today

Join our [MPC Wallet Discord](https://discord.gg/Ext5Xf4tZa) to:
- Access FAQs
- Schedule project discussions
- Connect with other developers

We welcome your feedback and suggestions for improvement.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/assets.mdx -->

---
title: Assets
sidebar_label: Assets
slug: assets
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

An asset is a representation of value on a blockchain network. Common types of assets include (fungible) tokens and NFTs (non-fungible tokens). CDP APIs support certain popular assets by their symbols and the vast majority by their contract addresses.

### Assets supported by symbol

The CDP APIs support the following assets on the Base Sepolia & Mainnet networks to be identified by their symbols.

| Asset | Type | Base-Mainnet | Base-Sepolia | Description |
| ---- | ---- | ----------- | ---------------------| ----------- |
| **Ether**, also known as **ETH** | native | :white_check_mark: | :white_check_mark: | This is the native token of many networks that run on the [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/), including Base. ETH is used to pay for transactions on the network, and the network provides native APIs to send, receive, and otherwise interact with ETH.|
|  **USDC**  | ERC&#8209;20  | :white_check_mark: | :white_check_mark: | [backed 1:1 by a U.S. Dollar](https://www.circle.com/en/usdc). |
|  **WETH**  | ERC-20  | :white_check_mark: | :white_check_mark: | [backed 1:1 by ETH](https://basescan.org/token/0x4200000000000000000000000000000000000006). |
| **DAI** | ERC-20  | :white_check_mark: | :x: |  [Dai Stablecoin](https://basescan.org/token/0x50c5725949a6f0c72e6c4a641f24049a917db0cb) on Base-Mainnet. |
| **RETH** | ERC-20  | :white_check_mark: | :x: |	[Rocket Pool ETH](https://basescan.org/token/0xb6fe221fe9eef5aba221c348ba20a1bf5e73624c) on Base-Mainnet. |
| **BRETT** | ERC-20  | :white_check_mark: | :x: |	[Brett](https://basescan.org/token/0x532f27101965dd16442e59d40670faf5ebb142e4) on Base-Mainnet. |
| **W** | ERC-20  | :white_check_mark: | :x: |	[Wormhole Token](https://basescan.org/token/0xb0ffa8000886e57f86dd5264b9582b2ad87b2b91) on Base-Mainnet. |
| **CBETH** | ERC-20  | :white_check_mark: | :x: |	[Coinbase Wrapped Ether](https://basescan.org/token/0x2ae3f1ec7f1f5012cfeab0185bfc7aa3cf0dec22) on Base-Mainnet. |
| **AXL** | ERC-20  | :white_check_mark: | :x: |	[Axelar](https://basescan.org/token/0x23ee2343b892b1bb63503a4fabc840e0e2c6810f) on Base-Mainnet. |
| **IOTX** | ERC-20  | :white_check_mark: | :x: |	[IoTeX](https://basescan.org/token/0xbcbaf311cec8a4eac0430193a528d9ff27ae38c1) on Base-Mainnet. |
| **PRIME** | ERC-20  | :white_check_mark: | :x: |	[Prime](https://basescan.org/token/0xfa980ced6895ac314e7de34ef1bfae90a5add21b) on Base-Mainnet. |
| **AERO** | ERC-20  | :white_check_mark: | :x: |	[Aerodrome](https://basescan.org/token/0x940181a94a35a4569e4529a3cdfb74e38fd98631) on Base-Mainnet. |
| **RSR** | ERC-20  | :white_check_mark: | :x: |	[Reserve Rights](https://basescan.org/token/0xab36452dbac151be02b16ca17d8919826072f64a) on Base-Mainnet. |
| **MOG** | ERC-20  | :white_check_mark: | :x: |	[Mog Coin](https://basescan.org/token/0x2da56acb9ea78330f947bd57c54119debda7af71) on Base-Mainnet. |
| **TBTC** | ERC-20  | :white_check_mark: | :x: |	[Base tBTC v2](https://basescan.org/token/0x236aa50979d5f3de3bd1eeb40e81137f22ab794b) on Base-Mainnet. |
| **NPC** | ERC-20  | :white_check_mark: | :x: |	[Non-Playable Coin](https://basescan.org/token/0x236aa50979d5f3de3bd1eeb40e81137f22ab794b) on Base-Mainnet. |
| **YFI** | ERC-20  | :white_check_mark: | :x: |	[Yearn Finance](https://basescan.org/token/0x9eaf8c1e34f05a589eda6bafdf391cf6ad3cb239) on Base-Mainnet. |

In addition to Base, CDP APIs also support **ETH** & **USDC** on Ethereum Mainnet, **MATIC** & **USDC** on Polygon Mainnet and **ARB** & **USDC** on Arbitrum Mainnet.

### Assets supported by contract address

Besides the assets listed in the above table, CDP APIs support all other ERC20 tokens using their respective contract addresses.

#### Transfer an ERC20 from a wallet with contract address

The following example demonstrates how to create a transfer for USDC on Base-Sepolia using its contract address. Use [Circle faucet](https://faucet.circle.com/) to fund your wallet.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
     ```typescript
     let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseSepolia });

     const transfer = await wallet.createTransfer({
       amount: 0.0001,
       assetId: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
       destination: anotherWallet,
     });

     // Wait for the transfer to complete.
     await transfer.wait();
     ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
    ```ruby
    wallet = Coinbase::Wallet.create(network: Coinbase::Networks::BASE_SEPOLIA)

    wallet.transfer(0.0001, '0x036CbD53842c5426634e7929541eC2318f3dCF7e', another_wallet).wait!
    ```
    </TabItem>
	<TabItem value="Python" label="Python">
    ```python
    wallet = Wallet.create("base-sepolia")

    wallet.transfer(0.0001, "0x036CbD53842c5426634e7929541eC2318f3dCF7e", another_wallet).wait()
    ```
    </TabItem>
</Tabs>


#### Trade an ERC20 in a wallet with contract address

The following example demonstrates how to create a trade for USDC on Base-Mainnet using its contract address. Remember to fund your wallet with USDC to complete the trade.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
     ```typescript
     let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseMainnet });

     // Out-of-band: Fund the wallet.

     // Create trade from ETH to `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`.
     let trade = await wallet.createTrade({
       amount: 0.00001,
       fromAssetId: Coinbase.assets.Eth,
       toAssetId: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
     });

     // Wait for the trade to complete.
     await trade.wait();
     ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
    ```ruby
    wallet = Coinbase::Wallet.create(network: Coinbase::Network::BASE_MAINNET)

    # Out-of-band: Fund the wallet.

    # Create trade from ETH to `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`.
    trade = wallet.trade(0.0001, :eth, '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913')

    # Wait for the trade to complete.
    trade.wait!
    ```
    </TabItem>
	<TabItem value="Python" label="Python">
    ```python
    wallet = Wallet.create("base-mainnet")

    # Out-of-band: Fund the wallet.

    # Create trade from ETH to `0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`.
    trade = wallet.trade(0.0001, "eth", "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913")

    # Wait for the trade to complete.
    trade.wait()
    ```
    </TabItem>
</Tabs>

## Fetch balances for assets

### Fetch balance for assets identified by symbol

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
     ```typescript
     let balance = await wallet.getBalance(Coinbase.assets.Eth)
     ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
    ```ruby
    balance = wallet.balance(:eth)
    ```
    </TabItem>
	<TabItem value="Python" label="Python">
    ```python
    balance = wallet.balance("eth")
    ```
    </TabItem>
</Tabs>

### Fetch balance for assets identified by contract address

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
     ```typescript
     let balance = await wallet.getBalance("0x036CbD53842c5426634e7929541eC2318f3dCF7e")
     ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
    ```ruby
    balance = wallet.balance('0x036CbD53842c5426634e7929541eC2318f3dCF7e')
    ```
    </TabItem>
	<TabItem value="Python" label="Python">
    ```python
    balance = wallet.balance("0x036CbD53842c5426634e7929541eC2318f3dCF7e")
    ```
    </TabItem>
</Tabs>

## Denominations of ETH

ETH provides 18 places of decimal precision. The smallest amount of sendable ETH is 10<sup>-18</sup>, also known as a Wei.

Commonly used denominations of ETH:

| Denomination | Amount in Wei       | Description                                                                    |
| ------------ | ------------------- | ------------------------------------------------------------------------------ |
| Wei          | 1 Wei               | Smallest denomination of ETH                                                   |
| Gwei         | 10<sup>9</sup> Wei  | Denomination of ETH commonly used for gas (i.e., transaction fee) calculations |
| Ether / ETH  | 10<sup>18</sup> Wei | Largest denomination of ETH, commonly used for trading                         |

The SDK supports transfers in denominations of Wei, Gwei, and ETH.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        **SDK Documentation**

        You can refer to the [Asset class SDK docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_asset.Asset.html) for a full list of supported methods.

        In Node.js, asset IDs are accessed through the assets property of the Coinbase class.

        - ETH's asset ID is `Coinbase.assets.Eth`
        - USDC's asset ID is `Coinbase.assets.Usdc`
        - WETH's asset ID is `Coinbase.assets.Weth`
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**

        You can refer to the [Asset class SDK docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Asset) for a full list of supported methods.

        In Ruby, asset IDs are symbols that resemble tickers:

        - ETH's asset ID is `:eth`
        - USDC's asset ID is `:usdc`
        - WETH's asset ID is `:weth`
    </TabItem>
	<TabItem value="Python" label="Python">
		**SDK Documentation**

        You can refer to the [Asset class SDK docs](https://coinbase.github.io/cdp-sdk-python/cdp.html#cdp.asset.Asset) for a full list of supported methods.

        In Python, asset IDs are strings that resemble tickers:

        - ETH's asset ID is `"eth"`
        - USDC's asset ID is `"usdc"`
        - WETH's asset ID is `"weth"`
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/smart-contract-interactions.mdx -->

---
title: Smart Contract Interactions
sidebar_label: Smart Contract Interactions
slug: smart-contract-interactions
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The CDP SDK's MPC Wallets support smart contract [writes](#smart-contract-writes), [reads](#smart-contract-reads), [smart contract token deployments](#smart-contract-deployment), and [message signing](#message-signing). This allows developers to unlock a wide range of onchain activities while abstracting complexity from end-users.

## Example Use Cases
- **Telegram bots for anything:** Beyond swapping and sending, developers can create Telegram bots for any smart contract functionality.
- **Multi-step smart contract interactions:** Create complex, programmatic DeFi applications that abstract difficult steps from your user. Truly programmatic money legos.

## Smart Contract Writes
Smart contracts live on a blockchain and programmatically enforce and execute the terms of an agreement. Integrating smart contracts with MPC Wallets enables:
- Complex, multi-step operations triggered by a single user action.
- Offchain actions with onchain verification and execution.
- Limitless interactions with any onchain app or protocol.

## Examples

### Invoking (Calling) a Contract

We natively support the following standard contract interfaces, without you providing an ABI:
- [ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20) (fungible tokens)
- [ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721) (NFTs)
- [ERC-1155](https://docs.openzeppelin.com/contracts/3.x/erc1155) (Multi token standard)

However, any other contracts require providing the ABI. If you are interested in cached ABIs for more common smart contracts, reach out to us on the [CDP Discord](https://discord.gg/Ext5Xf4tZa).

A contract [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) (Application Binary Interface) is the way to interact with a smart contract, both externally and contract-to-contract. It is a file defining the various methods and parameters of the contract.

The SDK also supports payable transactions, which are transactions that send ETH to the contract. See the [Basename Registration](/mpc-wallet/docs/basename-registration) guide for an example of a payable transaction.

### Transfer an ERC-721 NFT

Here's an example of using `invokeContract` to transfer an ERC-721 NFT:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";
        import os from "os";

        const coinbase = Coinbase.configureFromJson({ filePath: `${os.homedir()}/Downloads/cdp_api_key.json`, useServerSigner: true });

        const wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumMainnet });

        // Since this is an ERC-721 NFT, there's no need to define the ABI
        const transferFromArgs = {
          from: "0xFrom",
          to: "0xmyEthereumAddress",
          tokenId: "1000",
        };

        const contractInvocation = await wallet.invokeContract({
          contractAddress: "0xYourNFTContractAddress",
          method: "transferFrom",
          args: transferFromArgs,
        });

        // Wait for the contract invocation transaction to land on-chain.
        await contractInvocation.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Since this is an ERC-721 NFT, there's no need to define the ABI
        invocation = wallet.invoke_contract(
          contract_address: '0xYourNFTContractAddress',
          method: 'transferFrom',
          args: { from: '0xFrom', to: '0xmyEthereumAddress', tokenId: '1000' }
        ).wait!
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
        ```python
        # Since this is an ERC-721 NFT, there's no need to define the ABI
        invocation = wallet.invoke_contract(
          contract_address="0xYourNFTContractAddress",
          method="transferFrom",
          args={"from": "0xFrom", "to": "0xmyEthereumAddress", "tokenId": "1000"}
        ).wait()
        ```
    </TabItem>
</Tabs>

### Invoking an arbitrary smart contract

This is an example of using `invokeContract` on an arbitrary contract, where the ABI must be explicitly provided.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Define the ABI of the contract function you want to interact with
        const abi = [
          {
            name: "transfer",
            type: "function",
            inputs: [
              { name: "to", type: "address" },
              { name: "value", type: "uint256" },
            ],
            outputs: [{ name: "", type: "uint256" }],
            stateMutability: "nonpayable",
          },
        ];

        const transferArgs = {
          to: "0xmyEthereumAddress",
          value: "100",
        };

        const contractInvocation = await wallet.invokeContract({
          contractAddress: "0xYourContractAddress",
          method: "transfer",
          args: transferArgs,
          abi,
        });

        // Wait for the contract invocation transaction to land on-chain.
        await contractInvocation.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        abi = [
          {
            inputs: [
              {internalType: 'address', name: 'to', type: 'address'},
              {internalType: 'uint256', name: 'value', type: 'uint256'}
            ],
            name: 'transfer',
            outputs: [{internalType: 'uint256', name: '', type: 'uint256'}],
            stateMutability: 'nonpayable',
            type: 'function'
          }
        ]

        invocation = wallet.invoke_contract(
          contract_address: '0xYourContract',
          abi: abi,
          method: 'transfer',
          args: { to: '0xRecipient', value: '1000' }
        )

        invocation.wait!
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        abi = [
          {
            "inputs": [
              {"internalType": "address", "name": "to", "type": "address"},
              {"internalType": "uint256", "name": "value", "type": "uint256"}
            ],
            "name": "transfer",
            "outputs": [{"internalType": "uint256", "name": '', "type": "uint256"}],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ]

        invocation = wallet.invoke_contract(
          contract_address="0xYourContract",
          abi=abi,
          method="transfer",
          args={"to": "0xRecipient", "value": "1000"}
        )

        invocation.wait()
        ```
    </TabItem>
</Tabs>

## Smart Contract Reads
Smart contract support being queried and returning state data without explicitly modifying their state. Readable functions are useful for retrieving current contract state, calculating values, or checking conditions before performing transactions. 

Including an ABI is optional, but without it, the CDP SDK will not be able to determine the return type of the function, and the return value will not be parsed. With an ABI, Node.js types are inferred and can be used directly. In Python, the SDK will automatically convert to the expected type at runtime.

### Examples
Here's an example of reading from a smart contract using the CDP SDK:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        import { Coinbase, readContract } from "@coinbase/coinbase-sdk";

	// balance is automatically of type bigint
	const balance = await readContract({
		networkId: "base-mainnet",
		abi: erc20Abi,
		contractAddress: USDC_BASE_MAINNET_ADDRESS as 0x${string},
		method: "balanceOf",
	args: { account: "0xF977814e90dA44bFA03b6295A0616a897441aceC" },
	});

	console.log(balance);

	// balance is of type unknown, so as bigint is needed
	const balance = await readContract({
		networkId: "base-mainnet",
		contractAddress: USDC_BASE_MAINNET_ADDRESS as 0x${string},
		method: "balanceOf",
		args: { account: "0xF977814e90dA44bFA03b6295A0616a897441aceC" },
	}) as bigint;
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        from cdp.smart_contract import SmartContract

        ABI = [    
            {
                "type": "function",
                "name": "pureUint16",
                "inputs": [],
                "outputs": [{"name": "", "type": "uint16"}],
                "stateMutability": "pure",
            }
        ]

        CONTRACT_ADDRESS = "0x0B54409D1B1dd1438eDF7729CDAea3E331Ae12ED"
        NETWORK_ID = "base-sepolia"

        uint16 = SmartContract.read(
            NETWORK_ID,
            CONTRACT_ADDRESS,
            "pureUint16",
            ABI,
        )
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/addresses.mdx -->

---
title: Addresses
sidebar_label: Addresses
slug: addresses
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

An address is a user-controlled account on a blockchain network. An address can hold a balance of one or more assets, and can be used to send or receive crypto.

An address is backed by a [private key](https://help.coinbase.com/en/coinbase/getting-started/crypto-education/glossary/private-key), which provides access to spend the assets in the address. Addresses can list their balances and support various verbs depending on the type of address.

## Address Types

Depending on how the associated private key is managed, addresses can be classified into two types, [wallet](#wallet-addresses) and [external](#external-addresses).

### Wallet Addresses

Wallet addresses belong to developer custodied wallets. See [Creating a Wallet](./wallets.mdx#creating-a-wallet) section. The private keys for these addresses are managed by the CDP SDK. Wallet addresses support all verbs that CDP SDK supports.

### External Addresses

External addresses do not belong to CDP Wallets. The CDP SDK can be used to interact with these addresses; but because the SDK does not manage private keys for them, all signing operations are done off-platform. External addresses only support [retrieving balances](./wallets.mdx#retrieving-balances), staking verbs, and funding with testnet tokens with the [faucet](./wallets.mdx#faucet). 

<Tabs groupId="programming-language"> 
    <TabItem value="Typescript" label="Typescript" default>
       **SDK Documentation**
       You can refer to the [Address class SDK docs](https://coinbase.github.io/coinbase-sdk-nodejs/classes/coinbase_address.Address.html) for a full list of supported methods.
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        **SDK Documentation**
        You can refer to the [Address class SDK docs](https://www.rubydoc.info/gems/coinbase-sdk/Coinbase/Address) for a full list of supported methods.
    </TabItem>
    <TabItem value="Python" label="Python">
        **SDK Documentation**
        You can refer to the [Address class SDK docs](https://coinbase.github.io/cdp-sdk-python/cdp.html#cdp.address.Address) for a full list of supported methods.
    </TabItem>
</Tabs>

## Creating Wallet Addresses

Wallet addresses belong to a [wallet](./wallets.mdx):

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let address = await wallet.createAddress();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        address = wallet.create_address
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        address = wallet.create_address()
        ```
    </TabItem>
</Tabs>


A wallet comes with a single address by default, accessible via `default_address`.

## Creating External Addresses

To create an External Address object, provide the address string and the network:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let externalAddress = new ExternalAddress("base-sepolia", "YOUR_WALLET_ADDRESS");
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        external_address = Coinbase::ExternalAddress.new(:base_sepolia, "YOUR_WALLET_ADDRESS")
        ```
 </TabItem>
</Tabs>

## Viewing Address IDs

To view the hexadecimal string that actually represents your address, use the `address_id` property:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let addressId = address.getId();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        address_id = address.id
        ```
    </TabItem>
    <TabItem value="Python" label="Python">
        ```python
        address_id = address.address_id
        ```
    </TabItem>
</Tabs>

## Listing Address historical balances for an asset

To view the historical balances of [assets](/cdp-sdk/docs/assets) of an address, call the following:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let resp = await address.listHistoricalBalances(Coinbase.assets.Usdc);
		let historicalBalances = resp.data;
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        historicalBalances = address.historical_balances(:usdc)
        ```
 </TabItem>
     <TabItem value="Python" label="Python">
        ```python
        historical_balances = address.historical_balances("usdc")
        ```
    </TabItem>
</Tabs>

## Listing Address transactions

To view all transactions for a specific address in the blockchain, you can use the following code snippet:

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        let resp = await address.listTransactions();
		let transactions = resp.data;
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        transactions = address.transactions
        ```
 </TabItem>
     <TabItem value="Python" label="Python">
        ```python
        transactions = address.transactions()
        ```
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/wallet-types.mdx -->

---
title: Wallet Types
sidebar_label: Wallet Types
slug: wallet-types
---

There are two types of wallets that can be created using the CDP SDK, depending on how the
 private keys are managed: Coinbase-Managed (2-of-2) Wallets and Developer-Managed (1-of-1) Wallets.

Looking for more information on the differences between Smart Wallet and MPC Wallet? See our [Wallet Comparison](/cdp-apis/docs/wallet-comparison).

 Use the following table to understand the differences between Coinbase-Managed Wallets and Developer-Managed Wallets:

| Feature              | Coinbase-Managed Wallets                   | Developer-Managed Wallets                |
| -------------------- | :----------------------------------------- | :--------------------------------------- |
| Custody model        | Developer custodied                        | Developer custodied                      |
| Key management       | Secured by Coinbase and the developer      | Secured by the developer                 |
| Key structure        | 2-of-2                                     | 1-of-1                                   |
| Key export           | Cannot be exported                         | Can be exported via CDP SDK              |
| Key storage          | Stored securely in developer's AWS account | Stored by the developer                  |
| Developer Experience | Use Coinbase Server-Signer                 | Developer implements private key storage | 
| Setup time           | 10 minutes to provision infrastructure     | A few seconds to set up the SDK          |

## Coinbase-Managed (2-of-2) Wallets

The CDP SDK offers Coinbased-Managed 2-of-2 Wallets, leveraging advanced cryptographic techniques
for enhanced usability and security.

These multiparty computation (MPC) wallets split private keys into two shares between Coinbase and 
the developer, ensuring improved security.

To use Coinbase-Managed (2-of-2) Wallets, set up your [Server-Signer](/mpc-wallet/docs/serversigners).

:::warning Secure your CDP Secret API Key
- MPC does not safeguard your CDP API keys or account credentials. If your CDP login or API keys are comprimised, funds held in MPC wallets could potentially be at risk. 
- Coinbase recommends that you store your secret API keys in a dedicated solution such as AWS secret manager, Azure key vault, or some other secure storage option. Your CDP account can be used to mint new API keys and should be stored securely using a password manager. Always follow the principle of least privilege when deciding who within your organization can access your CDP account funds.  
:::

## Developer-Managed (1-of-1)  Wallets

Developer-Managed wallets are 1-of-1 wallets for which the developer manages the private keys.
These wallets are not protected by Coinbase, and a compromised or lost private key could result in loss of funds. You can export the private key for such wallets through the CDP SDK. Secure the exported private keys from CDP SDK using a strong encryption algorithm (e.g., AES-256) before persisting in a database. Ensure you create cloud / offline backups of your encrypted data store.

See [Developer-Managed Wallets](./wallets.mdx#developer-managed-wallets) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/message-signing.mdx -->

---
title: Message Signing
sidebar_label: Message Signing
slug: message-signing
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Signing is a cryptographic action that lets a user prove ownership of an address without exposing their private key or initiating an onchain transaction. When a user signs a message, the signed message:
- Demonstrates control of the address.
- Can be used to approve a particular action or set of actions.
- Is a verifiable piece of cryptographic data that can be used onchain or offchain.

In existing apps, signatures are used to authorize transfers of particular assets, prove ownership of an address to sign into an app, and vote in Decentralized Autonomous Organizations (DAOs).

## Example Use Cases
- **Identity/Sign-on with MPC:** Use MPC wallets to sign into applications or prove ownership of a wallet.
- **Multi-signature MPC Wallets:** Have multiple parties sign partial messages, which are then combined to create a valid transaction or decrypt information.
- **Scalable, high-frequency interactions:** Have games or trading apps use signatures to verify actions and submit batch updates to the blockchain.


## Examples

### Signing a Payload
You can sign an arbitrary string using the [EIP-191](https://eips.ethereum.org/EIPS/eip-191) standard.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       [**SDK Documentation**](https://docs.cdp.coinbase.com/cdp-sdk/docs/welcome)

        ```typescript
        // EIP-191 Message signing of hashed payload.
        const message: string = hashMesssage("hello world")

        let payloadSignature: PayloadSignature = await wallet.createPayloadSignature(message);
        payloadSignature = await payloadSignature.wait();
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        We don’t have the hashing methods in ruby yet so the developer will need to provide the valid hex-encoded hashed payload as the unsigned_payload. The [Ethereum for Ruby library](https://github.com/q9f/eth.rb) has dedicated support for EIP-712 and EIP-191 hashing.
        ```ruby
        wallet = Coinbase::Wallet.create

        payload_signature = wallet.sign_payload(unsigned_payload: '0x58f51af4cb4775cebe5853f0bf1e984927415e889a3d55ae6d243aeec46ffd10').wait!
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
       [**SDK Documentation**](https://docs.cdp.coinbase.com/cdp-sdk/docs/welcome)

        ```python
        # EIP-191 Message signing of hashed payload.
        message_hash = hash_messsage("hello world")

        payload_signature = wallet.sign_payload(message_hash).wait()
        ```
    </TabItem>
</Tabs>


### Signing Typed Structured Data
[EIP-712](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) is the standard for signing typed structured data, which improves the readability of messages and helps prevent signing opaque, potentially malicious messages. Ruby support will be added soon.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
       [**SDK Documentation**](https://docs.cdp.coinbase.com/cdp-sdk/docs/welcome)

        ```typescript
        // EIP-712 Typed Data Message
        // Define the EIP-712 typed data structure
        const domain = {
          name: "MyDapp",
          version: "1",
          chainId: 1,
          verifyingContract: "0xYourContractAddress",
        };

        const types = {
          MyType: [
            { name: "sender", type: "address" },
            { name: "amount", type: "uint256" },
          ],
        };

        const typedDataMessage = {
          sender: "0xSenderAddress",
          amount: 1000,
        };

        const typedDataMessage = hashTypedData({
          domains,
          types,
          primaryType: "MyType",
          typedDataMessage,
        });

        let payloadSignature: PayloadSignature = await wallet.createPayloadSignature(typedDataMessage);
        payloadSignature = await payloadSignature.wait();
        ```
    </TabItem>
	<TabItem value="Python" label="Python">
       [**SDK Documentation**](https://docs.cdp.coinbase.com/cdp-sdk/docs/welcome)

        ```python
        # EIP-712 Typed Data Message
		typed_data_message = {
			"types": {
				"MyType": [
					{"name": "sender", "type": "address"},
					{"name": "amount", "type": "uint256"}
				]
			},
			"primaryType": "MyType",
			"domain": {
				"name": "MyDapp",
				"version": "1",
				"chainId": 1,
				"verifyingContract": "0xYourContractAddress"
			},
			"message": {
				"sender": "0xSenderAddress",
				"amount": 1000
			}
		}
		
		typed_data_message_hash = hash_typed_data_message(typed_data_message)

        payload_signature = wallet.sign_payload(typed_data_message_hash).wait()
        ```
    </TabItem>
</Tabs>




<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/quickstart.mdx -->

---
title: Quickstart
sidebar_label: Quickstart
slug: quickstart
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TypescriptRequirements from './NodeJS/quickstart/requirements.mdx';
import RubyRequirements from './Ruby/quickstart/requirements.mdx';
import PythonRequirements from './Python/quickstart/requirements.mdx';
import TypescriptInstallation from './NodeJS/quickstart/installation.mdx';
import RubyInstallation from './Ruby/quickstart/installation.mdx';
import PythonInstallation from './Python/quickstart/installation.mdx';
import TypescriptCreateWallet from './NodeJS/quickstart/create_wallet.mdx';
import RubyCreateWallet from './Ruby/quickstart/create_wallet.mdx';
import PythonCreateWallet from './Python/quickstart/create_wallet.mdx';
import TypescriptFundWallet from './NodeJS/quickstart/fund_wallet.mdx';
import RubyFundWallet from './Ruby/quickstart/fund_wallet.mdx';
import PythonFundWallet from './Python/quickstart/fund_wallet.mdx';
import TypescriptPersistWallet from './NodeJS/quickstart/persist_wallet.mdx';
import RubyPersistWallet from './Ruby/quickstart/persist_wallet.mdx';
import PythonPersistWallet from './Python/quickstart/persist_wallet.mdx';
import TypescriptTransferFund from './NodeJS/quickstart/transfer_fund.mdx';
import RubyTransferFund from './Ruby/quickstart/transfer_fund.mdx';
import PythonTransferFund from './Python/quickstart/transfer_fund.mdx';
import TypescriptTradeAssets from './NodeJS/quickstart/trade_assets.mdx';
import RubyTradeAssets from './Ruby/quickstart/trade_assets.mdx';
import PythonTradeAssets from './Python/quickstart/trade_assets.mdx';

The CDP SDK allows you to create wallets and send funds onchain within minutes. 
In this quickstart, you will learn how to create a wallet, fund it with testnet ETH,
transfer funds between wallets, and trade assets.

:::tip
See [Securing a Wallet](/mpc-wallet/docs/wallets#securing-a-wallet) to learn how to protect your wallets. 
:::

## What You'll Learn

- How to install the CDP SDK
- How to create a [Developer-Managed Wallet](/mpc-wallet/docs/wallets#developer-managed-wallets) and view its default address
- How to fund your wallet with testnet ETH
- How to transfer funds between wallets
- How to trade assets in a wallet

## Requirements

:::info
Make sure that your developer environment satisfies all of the requirements before proceeding through the quickstart.
:::

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptRequirements />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyRequirements />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonRequirements />
    </TabItem>
</Tabs>

## Installation

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptInstallation />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyInstallation />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonInstallation />
    </TabItem>
</Tabs>

## Creating a Wallet

To start, [create a CDP Secret API key](https://portal.cdp.coinbase.com/access/api).
Then, initialize the CDP SDK by passing your downloaded API key file,
and create a Developer-Managed Wallet:

:::tip
This quickstart creates wallets on Base Sepolia testnet. You can create wallets across various [EVM networks](/coinbase-sdk/docs/networks), including Base, Ethereum L1, and Polygon.
:::

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptCreateWallet />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyCreateWallet />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonCreateWallet />
    </TabItem>
</Tabs>

:::caution
In a production environment, we recommend turning on [IP Whitelisting](/get-started/docs/cdp-key-security) and using the [2-of-2 Coinbase-Managed Wallet](/mpc-wallet/docs/wallets#coinbase-managed-wallets) for additional security.
:::

The wallet created should be persisted to avoid losing access to it. Refer to [Persisting a wallet](./wallets#persisting-a-wallet) section for more information.

## Funding a Wallet

Wallets do not have funds on them to start. For Base Sepolia testnet, we provide a faucet method to fund your wallet with
testnet ETH.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptFundWallet />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyFundWallet />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonFundWallet />
    </TabItem>
</Tabs>

## Transferring Funds

Now that your faucet transaction has successfully completed, you can send the funds in your wallet to another wallet.
The code below creates another wallet, and sends testnet ETH from the first wallet to the second:

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptTransferFund />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyTransferFund />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonTransferFund />
    </TabItem>
</Tabs>

## Trading Assets

On `base-mainnet` you can trade between different assets from your wallet. Since trading is only supported on mainnet wallets, wallet should be funded with real assets before trading. The code below creates a wallet and trades some ETH to USDC and then all of the USDC to WETH:

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptTradeAssets />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyTradeAssets />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonTradeAssets />
    </TabItem>
</Tabs>

:::danger warning
The Developer-Managed Wallets created in the above quickstart are not persisted.
We recommend [Coinbase-Managed Wallets](./wallets.mdx#coinbase-managed-wallets) in production environments.
:::



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/fund-mpc-wallet.mdx -->

---
title: Fund MPC Wallets
sidebar_label: Fund MPC Wallets
slug: fund-mpc-wallets
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

As your application scales, you will need to send funds to your MPC wallets. This guide will walk you through the process of funding your MPC wallets.

There are 2 ways to move crypto to your MPC wallets:
1. Send crypto directly to the MPC wallets from an external wallet.
2. Use Coinbase products (retail & exchange) to onboard funds to your MPC wallets.

## Send crypto to the MPC Wallets from an external wallet

You can send crypto to the MPC Wallets from an external wallet. To do this, get the deposit address of the MPC Wallets by calling the `getDefaultAddress` API.

<Tabs groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        ```typescript
        // Get the default_address in the wallet, which will be the deposit address.
        let address = await wallet.getDefaultAddress();
        console.log(`Deposit Address: ${address}`);
        ```
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        ```ruby
        # Get the default_address in the wallet, which will be the deposit address.
        address = wallet.default_address
        puts "Deposit Address: #{address}"
        ```
    </TabItem>
</Tabs>

Once you have the deposit address, you can send crypto to the deposit address from an external wallet.

## Use Coinbase products to move funds to your MPC Wallets

Another way to move funds to your MPC Wallets is to use Coinbase products.

### Sign up on Coinbase

The first step in using Coinbase products to move funds to your MPC Wallets is to create a [Coinbase](https://coinbase.com) account.

If you are a solo developer working on hobby projects, create a Coinbase retail account for individuals via https://www.coinbase.com.

If you are a business, sign up on [Coinbase Exchange](https://www.coinbase.com/exchange). The onboarding process will involve answering questions about yourself (and your business, if applicable) required by regulations.
If you need assistance in business onboarding, reach out to us on [discord](https://discord.gg/cdp) via #mpc-wallet channel.

### Send funds from Coinbase Retail / Exchange to MPC Wallet

Once you have onboarded to Retail / Exchange, you can buy crypto with payment methods of your choice on these platforms.

- Supported payment methods on Coinbase Exchange can be found [here](https://help.coinbase.com/en/exchange/trading-and-funding/adding-a-payment-method).
- Supported payment methods on Coinbase Retail can be found [here](https://help.coinbase.com/en/coinbase/getting-started/add-a-payment-method/add-and-verify-pm-namerica-latam#available-payment-methods-by-country).

You can then move the funds to your MPC Wallets with the code snippets below.

#### Move funds from Retail to MPC Wallet via Coinbase App APIs

:::tip Use Retail APIs only for withdrawals to Ethereum Mainnet.
The below code snippet only supports withdrawals to Ethereum Mainnet. If you want to withdraw to L2 networks with Retail APIs,
reach out to us on [discord](https://discord.gg/Ext5Xf4tZa).
:::

<details>
    <summary><b>Expand to see code snippet to move funds from retail to MPC Wallets</b></summary>
     <Tabs>
        <TabItem value="typescript" label="TypeScript">
```typescript
const axios = require('axios');
const jwt = require('jsonwebtoken');

const cdpApiKeyName=""; // Replace with your API key name.
const cdpApiKeySecret=""; // Replace with your API key secret.

interface AccountResponse {
    data: RetailAccount[];
}

interface RetailAccount {
    id: string;
    name: string;
    primary: boolean;
    type: string;
    balance: {
        amount: string;
        currency: string;
    };
    created_at: string;
    updated_at: string;
    resource: string;
    resource_path: string;
    currency: {
        asset_id: string;
        code: string;
        color: string;
        exponent: number;
        name: string;
        slug: string;
        type: string;
        rewards: any;
    };
    allow_deposits: boolean;
    allow_withdrawals: boolean;
}

interface SendRequest {
    type: string;
    to: string;
    amount: string;
    currency: string;
}

interface SendResponse {
    data: {
        id: string;
        type: string;
        status: string;
        amount: {
            amount: string;
            currency: string;
        };
        native_amount: {
            amount: string;
            currency: string;
        };
        description: any;
        created_at: string;
        updated_at: string;
        resource: string;
        resource_path: string;
        network: {
            status: string;
            hash: string;
            name: string;
        };
        to: {
            resource: string;
            address: string;
        };
        details: {
            title: string;
            subtitle: string;
        };
    };
}

class RetailHTTPClient {
    private client: typeof axios;
    private url: string;

    constructor(url: string) {
        this.client = axios;
        this.url = url;
    }

    async request(method: string, urlPattern: string, content: any, responseContent: any): Promise<any> {
        const url = `${this.url}${urlPattern}`;
        let reqBody: string | undefined;
        if (content) {
            reqBody = JSON.stringify(content);
        }

        const uri = `${method} api.coinbase.com${urlPattern}`;
        const jwtToken = await buildJWT(uri);

        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${jwtToken}`
        };

        try {
            const response = await this.client({
                method,
                url,
                data: reqBody,
                headers
            });

            if (responseContent) {
                return response.data;
            }

            return response;
        } catch (error) {
            console.error('Error in request:', error);
            throw error;
        }
    }
}

interface APIKeyClaims {
    sub: string;
    iss: string;
    nbf: number;
    exp: number;
    uri: string;
}

async function buildJWT(uri: string): Promise<string> {
    const privateKey = cdpApiKeySecret.replace(/\\n/g, '\n');

    const claims: APIKeyClaims = {
        sub: cdpApiKeyName,
        iss: 'cdp',
        nbf: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 120,
        uri: uri
    };

    const options = {
        algorithm: 'ES256',
        header: { kid: cdpApiKeyName }
    };

    return new Promise((resolve, reject) => {
        jwt.sign(claims, privateKey, options, (err, token) => {
            if (err) reject(err);
            else resolve(token as string);
        });
    });
}

async function main() {
    const uri = "https://api.coinbase.com";
    const client = new RetailHTTPClient(uri);

    try {
        const accountResp = await client.request('GET', '/api/v2/accounts', null, {}) as AccountResponse;

        let accountID = '';
        for (const account of accountResp.data) {
            if (account.currency.name === 'Ethereum') {
                console.log('Ethereum account found', account);
                accountID = account.id;
                break;
            }
        }

        if (!accountID) {
            throw new Error('Ethereum account not found');
        }

        const sendPath = `/v2/accounts/${accountID}/transactions`;
        const sendRequest: SendRequest = {
            type: 'send',
            to: '0xMPCWalletAddress', // Replace with your wallet address retrieved from wallet.getDefaultAddress()
            amount: '0.0001',
            currency: 'ETH'
        };

        const sendResp = await client.request('POST', sendPath, sendRequest, {}) as SendResponse;
        console.log('Send response:', sendResp);
    } catch (error) {
        console.error('Error in requesting to Coinbase Retail APIs:', error);
    }
}

main();

```
    </TabItem>
  </Tabs>
</details>

#### Move funds from Exchange to MPC Wallets via Exchange API

<details>
    <summary><b>Expand to see code snippet to move funds from exchange to MPC Wallets</b></summary>
        <Tabs>
            <TabItem value="typescript" label="TypeScript">
```TypeScript
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import * as crypto from 'crypto';

interface WithdrawalRequest {
    profile?: string;
    amount: string;
    currency: string;
    crypto_address: string;
    network?: string;
}

interface Account {
    id: string;
    balance: string;
    holds: string;
    available: string;
    currency: string;
}

interface WithdrawalResponse {
    id: string;
    amount: string;
    currency: string;
    fee: number;
    subtotal: number;
    network: string;
}

class HTTPClient {
    private client: AxiosInstance;
    private apiKey: string;
    private secret: string;
    private password: string;
    private url: string;

    constructor(url: string, key: string, secret: string, passphrase: string) {
        this.client = axios.create();
        this.apiKey = key;
        this.secret = secret;
        this.password = passphrase;
        this.url = url;
    }

    async request<T>(method: string, urlPattern: string, content: any): Promise<T> {
        const url = `${this.url}${urlPattern}`;
        let reqBody: string | undefined;
        if (content) {
            reqBody = JSON.stringify(content);
        }

        const [signature, timestamp] = await this.generateSignatureHeaders(method, urlPattern, reqBody || '');

        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
            'cb-access-key': this.apiKey,
            'cb-access-sign': signature,
            'cb-access-timestamp': timestamp,
            'cb-access-passphrase': this.password
        };

        const config: AxiosRequestConfig = {
            method: method as any,
            url,
            data: reqBody,
            headers
        };

        try {
            const response: AxiosResponse<T> = await this.client(config);
            return response.data;
        } catch (error) {
            console.error('Error in request:', error);
            throw error;
        }
    }

    private async generateSignatureHeaders(method: string, path: string, body: string): Promise<[string, string]> {
        const timestamp = Math.floor(Date.now() / 1000).toString();
        const message = timestamp + method + path + body;
        const signature = await this.generateSignature(message);
        return [signature, timestamp];
    }

    private async generateSignature(message: string): Promise<string> {
        const key = Buffer.from(this.secret, 'base64');
        const hmac = crypto.createHmac('sha256', key);
        hmac.update(message);
        return hmac.digest('base64');
    }
}

async function main() {
    const passphrase = ""; // Replace with exchange API credentials.
    const secret = "";
    const key = "";
    const url = "https://api.exchange.coinbase.com";

    const client = new HTTPClient(url, key, secret, passphrase);

    try {
        const accounts = await client.request<Account[]>('GET', "/accounts", null);

        // Validate there is a USDC account.
        for (const account of accounts) {
            if (account.currency !== "USDC") {
                continue;
            }
            console.log(`ID: ${account.id}, Balance: ${account.balance}, Holds: ${account.holds}, Available: ${account.available}, Currency: ${account.currency}`);
        }

        const withdrawalPattern = "/withdrawals/crypto";
        const withdrawalRequest: WithdrawalRequest = {
            amount: "1",
            currency: "USDC",
            network: "base",
            crypto_address: "0xMPCWalletAddress", // Replace with your wallet address retrieved from wallet.getDefaultAddress()
        };

        const withdrawalResp = await client.request<WithdrawalResponse>('POST', withdrawalPattern, withdrawalRequest);
        console.log("Withdrawal response: ", withdrawalResp);
    } catch (error) {
        console.error('Error in requesting to Exchange APIs:', error);
    }
}

main();
```
        </TabItem>
    </Tabs>
</details>


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/networks.mdx -->

---
title: Networks
sidebar_label: Networks
slug: networks
---

A Network is a blockchain where onchain actions are executed.
For example, wallets and addresses are created on a specific network.

## Capabilities

The CDP SDK has different capabilities on different networks.
The following table shows the capabilities of the SDK on different networks:

| Concept               |    Base-Sepolia    |    Base-Mainnet    |  Ethereum-Holesky  |  Ethereum-Mainnet  |  Polygon-Mainnet   | Arbitrum-Mainnet     |   Solana-Devnet    |   Solana-Mainnet   |
|-----------------------|:------------------:|:------------------:|:------------------:|:------------------:|:------------------:|:--------------------:|:------------------:|:------------------:|
| Developer Wallets     | :white_check_mark: | :white_check_mark: |        :x:         | :white_check_mark: | :white_check_mark: |  :white_check_mark:  |        :x:         |        :x:         |
| End-User Wallets      | :white_check_mark: | :white_check_mark: | :white_check_mark: | :white_check_mark: | :white_check_mark: |  :white_check_mark:  | :white_check_mark: | :white_check_mark: |
| Addresses             | :white_check_mark: | :white_check_mark: |        :x:         | :white_check_mark: | :white_check_mark: |  :white_check_mark:  |        :x:         |        :x:         |
| Send                  | :white_check_mark: | :white_check_mark: |        :x:         | :white_check_mark: | :white_check_mark: |  :white_check_mark:  |        :x:         |        :x:         |
| Trade                 |        :x:         | :white_check_mark: |        :x:         | :white_check_mark: | :white_check_mark: |  :white_check_mark:  |        :x:         |        :x:         |
| Stake                 |        :x:         |        :x:         | :white_check_mark: | :white_check_mark: |        :x:         |         :x:          | :white_check_mark: | :white_check_mark: |
| Faucet                | :white_check_mark: |        :x:         | :white_check_mark: |        :x:         |        :x:         |         :x:          |        :x:         |        :x:         |
| Server-Signer         | :white_check_mark: | :white_check_mark: |        :x:         | :white_check_mark: | :white_check_mark: |  :white_check_mark:  |        :x:         |        :x:         |
| Webhooks              | :white_check_mark: | :white_check_mark: |        :x:         |        :x:         |        :x:         |         :x:          |        :x:         |        :x:         |
| Smart Contract Events |        :x:         | :white_check_mark: |        :x:         | :white_check_mark: |        :x:         |         :x:          |        :x:         |        :x:         |

## Testnet vs Mainnet

The CDP SDK supports both testnets and mainnets. 

- Testnets are for building and testing applications. Funds are not real, and you can get test currencies from a faucet. 
- Mainnet is where the funds, contracts and applications are real. 

Wallets, assets, etc, cannot be moved from testnet to mainnet (or vice versa).



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/hackathon-guide.mdx -->

---
title: "ETHGlobal SF Hackathon Guide"
sidebar_label: "ETHGlobal SF Hackathon Guide"
displayed_sidebar: "docs"
slug: "hackathon-guide"
---

Building using the CDP SDK for ETHGlobal SF? Don't worry, we've got you covered – here are all of the resources you need to get started, including advice for AI tooling, apps we'd love to see built, and advice from former ETHGlobal winners.

### TL;DR

We recommend starting with one of our [Replit templates](https://replit.com/@CoinbaseDev) or creating your own using the Replit Agent, and using Cursor as your IDE by following the [connection instructions](https://docs.replit.com/replit-workspace/ssh#connecting-to-your-repl). To see your wallets in a clean user interface, we recommend the [command center Vercel template](https://vercel.com/templates/next.js/wallet-dashboard-with-coinbase-developer-platform).

Find us at the venue wearing blue CDP builder shirts if you have any questions, feedback, or want to jam through your idea! 

After the hackathon, be sure to follow up with us and apply for our [grant](https://www.coinbase.com/developer-platform/discover/launches/builder-grants-round2)!

## Getting Started

The best way to get up and running quickly is to check out our [quickstart guide](https://docs.cdp.coinbase.com/mpc-wallet/docs/quickstart) or [demo apps](https://www.cdpsdk.xyz/). If you have any questions, please find us at the venue and we're more than happy to offer support.

## AI Tooling

The AI programming renaissance may just be getting started, but the available tools are already offering massive efficiency improvements over traditional IDEs and programming software. 

### Replit

[Replit](https://replit.com/) is a cloud-based coding platform that streamlines the process of setting up, building, sharing, and deploying projects. It allows developers to code in a Google Docs-like environment, and pre-built templates provide a great starting point for building a website, app, or game. Its new AI Agent can assist with the code development process and work with several files at once, making the programming process feel like a one-on-one conversation. 

We've partnered with Replit to create [CDP SDK templates](https://replit.com/@CoinbaseDev) for you to use as a starting point for your projects. The [cdp-sdk python package](https://pypi.org/project/cdp-sdk/) is indexed and searchable in the Replit dependency tool. 

### Cursor

[Cursor](https://www.cursor.com/) is an AI-powered code editor that makes the programming experience feel like magic. Built as a fork of VS Code, it boasts powerful features like AI code completion, natural language editing, and codebase understanding. Cursor Pro is free for the first two weeks after signup, and offers more powerful models.

We recommend starting your project on Replit and using [this guide](https://docs.replit.com/replit-workspace/ssh#connecting-to-your-repl) to open your project in Cursor.

### CDP SDK Explainer for LLMs

We've created a document that you can easily copy and paste into your LLM of choice to give more context on how the CDP SDK works and significantly improve the accuracy of your AI-generated code. It is available for both [NodeJS](https://gist.github.com/murrlincoln/ddec9c548db57882ccb5096e1c40974d) and [Python](https://gist.github.com/murrlincoln/6dff98088128fc1c4c8aaa1ee04de754).

In Cursor, we recommend including this document as a [.cursorrules](https://docs.cursor.com/context/rules-for-ai) file in the root of your project. 

## Hackathon App Ideas
In addition to the ideas below, we're excited by anything at the intersection of crypto and AI! Think outside the box - what can you do with autonomous agents? What becomes possible with a programmatic wallet that couldn't be done before?
### Gaming

- [AI Town](https://www.convex.dev/ai-town) with onchain interactions
- Infinitely-generating smart contract game
- Take existing games and use zkTLS/Reclaim protocol to add betting or some financial aspect
- Similarly, escrow contract for two people to play a game. An example is a card game where the dealer/fund holder is an MPC Wallet.
- Dynamically-generating token economy 
- Bot that pays you if you win a game against it

### Infrastructure

- Components that can be easily put into existing apps and websites, like onchain composable leaderboards, auctions/shopping experiences
- Something creating a [hyperstructure](https://jacob.energy/hyperstructures.html) on Base. Examples include a free-free LP pool, NFT marketplace, identity system, or voting infrastructure
- Create something using the 402 'payment required' HTTP standard and onchain payments
- DeFi autopilot - automatically reallocates funds in a smart contract vault to the highest-yielding strategy
- Create a voice-based wallet - the easiest wallet to use of all time. MPC Wallet API as agent
- Chatbot or Twitter bot that does a token deployment for you based on what you tell it

### Payments
- Automated payroll system using MPC wallets for secure, scheduled payments to employees
- Subscription management platform that handles recurring payments using smart contracts
- Peer-to-peer payment app with social features, leveraging MPC wallets for enhanced security
- Expense sharing app for groups (e.g., roommates, trips) with automatic settlement using MPC wallets
- Cross-border remittance service using stablecoins and MPC wallets for lower fees and faster transfers
- Decentralized escrow service for freelancers and clients, ensuring fair payment upon project completion
- Loyalty points program that tokenizes rewards and allows for seamless redemption across multiple merchants

### Tokenization

- Token deployment manager
- One-click DeFi ecosystem (create the LP pool, permissionless lending, etc)
- NFT to Ink - When an MPC wallet receives an NFT, use webhooks to recognize that and trigger a printer to print an image of it at the same time that the MPC Wallet burns it
- Personal NFT Shopper - Shows a personalized gallery of digital art NFTs you're likely to want based on the ones you already own, and enables you to buy them. The app itself has an MPC wallet where you can tip or pay a finder's fee
- RWA Tokenization



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/requirements.mdx -->


**Ruby 3.2**

Coinbase recommends using Ruby 3.2 or newer for the SDK. The sdk requires Ruby 2.7. To view your currently installed version of Ruby, run
the following from the command-line:

```bash
ruby -v
```

We recommend installing and managing Ruby versions with `rbenv`.
See [Using Package Managers](https://github.com/rbenv/rbenv?tab=readme-ov-file#homebrew) in the rbenv README for instructions on how to install `rbenv`.

Once `rbenv` has been installed, you can install and use the latest stable Ruby release by running the following commands:

```bash
rbenv install 3.3.1
rbenv global 3.3.1
```

**Rbsecp256k1 Gem**

The CDP SDK depends on the `rbsecp256k1` gem, which requires certain dependencies to be installed on your system. Follow the instructions provided [here](https://github.com/etscrivner/rbsecp256k1?tab=readme-ov-file#requirements) to meet these requirements:

- MacOS

On MacOS, run the following command:

```bash
brew install automake openssl libtool pkg-config gmp libffi
```

- Linux

On Linux, run the following command:

```
sudo apt-get install build-essential automake pkg-config libtool \
  libffi-dev libssl-dev libgmp-dev python3-dev
```

:::info
If you installed `libsecp256k1` but the gem cannot find it, run `ldconfig` to update your library load paths.
:::



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/reinstantiate_wallet.mdx -->


```ruby
# You should implement the "fetch" method to retrieve the securely persisted data object,
# keyed by the wallet ID.
fetched_data = fetch(wallet1.id)

# wallet1 will be equivalent to wallet.
wallet1 = Coinbase::Wallet.import(fetched_data)
```

If you used the `save_seed!` function to persist a wallet's seed on your local file system, then you can use the `load_seed` function re-instantiate the wallet.

```ruby
# Get the unhydrated wallet from the server.
wallet3 = Coinbase::Wallet.fetch(wallet1.id)

# You can now load the seed into the wallet from the local file.
wallet3.load_seed(filePath)
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/transfer_fund.mdx -->


```ruby
# Create a new wallet wallet2 to transfer funds to.
another_wallet = Coinbase::Wallet.create

puts "Wallet successfully created: #{another_wallet}"

transfer = wallet.transfer(0.00001, :eth, another_wallet).wait!

puts "Transfer successfully completed: #{transfer}"
```

See [Transfers](/mpc-wallets/docs/transfers) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/create_wallet.mdx -->


```ruby
api_key_name = "Copy your API key name here."
# Ensure that you are using double-quotes here.
api_key_private_key = "Copy your API key's private key here."

Coinbase.configure do |config|
  config.api_key_name = api_key_name
  config.api_key_private_key = api_key_private_key

  # Configure the default network for the SDK to use.
  # If not set, it will default to `:base_sepolia`.
  config.default_network = :base_mainnet
end

puts "CDP SDK has been successfully configured with CDP API key."
```

Another way to initialize the SDK is by sourcing the secret API key from the JSON file that contains your API key, downloaded from the CDP portal.

```ruby
Coinbase.configure_from_json('~/Downloads/cdp_api_key.json')

puts "CDP SDK has been successfully configured from JSON file."
```

This will allow you to [authenticate](/coinbase-sdk/docs/authentication) with the CDP APIs.

Now, we can create a wallet on the default network. Wallets are created with a single default address.

```ruby
# Create a wallet on the default network
wallet = Coinbase::Wallet.create
```

Wallets come with a single default address, accessible via `default_address`:

```ruby
# A wallet has a default address.
address = wallet.default_address
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/fund_wallet.mdx -->


```ruby
# Fund the wallet with a faucet transaction.
faucet_tx = wallet1.faucet

puts "Faucet transaction successfully completed: #{faucet_tx}"
```


<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/trade_assets.mdx -->

```ruby
# Create a wallet on `base-mainnet` to trade assets with.
wallet = Coinbase::Wallet.create(network: Coinbase::Network::BASE_MAINNET)

puts "Wallet successfully created: #{wallet}"

# Fund wallet's default address with ETH from an external source.

# Trade 0.00001 ETH to USDC
trade = wallet.trade(0.00001, :eth, :usdc).wait!

if trade.status == Coinbase::Transaction::Status::COMPLETE
  puts "Trade successfully completed: #{trade}"
else
  puts "Trade failed on-chain: #{trade}"
end

# Trade the wallet's full balance of USDC to WETH
trade2 = wallet.trade(wallet.balance(:usdc), :usdc, :weth).wait!

if trade2.status == Coinbase::Transaction::Status::COMPLETE
  puts "Second trade successfully completed: #{trade2}"
else
  puts "Second trade failed on-chain: #{trade}"
end
```

See [Trades](/mpc-wallets/docs/trades) for more information.



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/persist_wallet.mdx -->


```ruby
# Export the data required to re-instantiate the wallet.
data = wallet1.export
```

To persist the data for a wallet, you must implement a `store` method to store the exported data in a secure location. If you do not store the wallet in a secure location, you will lose access to the wallet, as well as the funds on it.

```ruby
# You should implement the "store" method to securely persist the data object,
# which is required to re-instantiate the wallet at a later time. For ease of use,
# the data object is converted to a Hash first.
store(data.to_hash)
```

For more information on wallet persistence, see [wallet docs](/cdp-sdk/docs/wallets#persisting-a-wallet).

Alternatively, you can use the `save_seed` function to persist a wallet's seed to a local file. This is a
convenience function for testing purposes, and should not be considered a secure method of persisting wallets.

```ruby
# Pick a file to which to save your wallet seed.
file_path = 'my_seed.json'

# Set encrypt: true to encrypt the wallet seed with your CDP secret API key.
wallet1.save_seed!(file_path, encrypt: true)

puts "Seed for wallet #{wallet1.id} successfully saved to #{file_path}."
```



<!-- File: /Users/tinahe/docs/projects/mpc-wallet/docs/Ruby/quickstart/installation.mdx -->


There are two ways of installing the CDP SDK: for use with the Interactive Ruby Shell, or for use
in a Ruby project (e.g. Ruby on Rails).

**For `irb`**

Use the Interactive Ruby Shell (`irb`) to leverage Ruby's built-in REPL and quickly explore the functionality of our SDK.

Run the following from the command line:

```bash
gem install coinbase-sdk
```

After running `irb`, require the Gem:

```ruby
require 'coinbase'
```

**For Ruby on Rails**

Alternatively, if you want to install your CDP SDK gem to your Ruby on Rails project, add the following line to your Gemfile:

```ruby
gem 'coinbase-sdk'
```

Or if you are using a Gemspec:

```ruby
Gem::Specification.new do |spec|
  spec.add_runtime_dependency 'coinbase-sdk'
end
```

Then run:

```bash
bundle install
```

**OpenSSL Gem**

The CDP SDK relies on the `openssl` gem for certain cryptographic operations. If you encounter issues installing the CDP SDK, ensure that OpenSSL 3+ is installed, and that the version used by Ruby matches the version required by the gem.

If you encounter an error like this:

```bash
error: incomplete definition of type 'struct evp_md_ctx_st'
    pkey = EVP_PKEY_CTX_get0_pkey(EVP_MD_CTX_get_pkey_ctx(ctx));
```

re-install the openssl gem with the following command:

```bash
gem install openssl -- --with-openssl-dir=$(brew --prefix openssl@3)
```




<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-orgs.mdx -->

---
title: "Organizations"
sidebar_label: "Organizations"
slug: "cdp-orgs"
description: "Manage organizations in Coinbase Developer Platform"
---

## What's an Organization?

An **Organization** organizes people and projects together in one place. An organization can have multiple users & projects. A user can also be part of multiple organizations. Currently a user can only create one organization themselve.

:::info
Multi-org creation will be added in future releases.
:::

{/* <!-- ## Creating an Organization

When a new user signs up, an organization is automatically created and the user is added to it as the sole owner.

## Renaming an Organization

If you are the owner of the you can rename your organization in Settings.

1. Click **Settings** on the left side navigation
2. Click on your organization name under the **Organiztion** tab
3. Edit the name and click **Save** --> */}

## Inviting Users to an Organization

In the **Access** tab on the left side navigation under **Team**, you’ll find an **Invite Member** button.

A few things to note:

- Only **Owner** and **Admin** types can invite new members. **User** types cannot see the "Invite Member" button.
{/* <!-- - You can only invite members who are not already signed up for CDP (because we currently only support one organization per user). --> */}
- You can add as many members to your organization as needed.
- When inviting a new member, you can select what role type to invite them into.
- Invitees receive an email with a link enabling them to signup (if they have not already) and automatically join your organization.
- On this same page, you can cancel an invitation before it’s been accepted, and you can remove members from your organization after they’ve been added.

## Viewing Membership

In the **Team** tab on the left side navigation, you can also view all the members of your organization.

In this view, new members can be added and existing ones can be removed or have their permissions changed.

<img src={require('../assets/images/cdp-access-orgs.jpg').default} width="600" alt="Organization tab in Coinbase Developer Platform." />

## Roles & Permissions

Each user role is assigned different permissions. See [Organization and permissions](https://portal.cdp.coinbase.com/access/permissions) in the Help docs for more information.

{/* <!-- | Role Name | Owner | Admin | User |
| ----------- | ----------- | ----------- | ----------- |
| Edit organization name   |   •     |         |        |
| View projects   |    •    |    •     |    •    |
| Create, update & delete projects   |   •     |   •      |        |
| Invite team members   |    •    |    •     |        |
| Manage user privileges  |     •   |    •     |        |
| Remove admin   |   •     |        |        |
| Remove user  |    •    |   •      |        |
| Update billing info  |    •    |    •     |        | --> */}

{/* <!-- <img src={require('../assets/images/cdp-roles-permissions-table.png').default} width="600" alt="This table shows default permissions available for each role." /> --> */}



<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-projects.mdx -->

---
title: "Projects"
sidebar_label: "Projects"
slug: "cdp-projects"
description: "Manage projects in Coinbase Developer Platform"
---

**Projects** act as containers where you can setup API keys, track metrics, and use any CDP products. All users start with a default project.


## Creating a Project

1. Click on the Project dropdown on the lefthand panel of the CDP dashboard.

2. Click **Create new project** at the bottom of the dropdown.
   <img src={require('../assets/images/cdp-projects-create-dashboard.png').default} width="600" alt="Project creation via Dashboard tab." />


## Renaming a Project

1. Click the **Settings** tab.

2. Under "Project name" click **Edit**.

3. Rename your project and click **Save**.

   <img src={require('../assets/images/cdp-projects-rename.jpg').default} width="600" alt="To rename a project, select the project and click Manage." />


## Deleting a Project

1. Click the **Settings** tab.
2. Click **Delete** and type in the project name to confirm deletion.


<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-postman.mdx -->

---
title: "Postman Files"
sidebar_label: "Postman Files"
slug: "postman-files"
hide_table_of_contents: false
---

The following Postman collection and environment files are available for download. 

- <a href="/downloads/getting-started/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> (Required for all Collections) 
- <a href="/downloads/getting-started/coinbase_advanced_trading.postman_collection.json" download target="blank">Coinbase Advanced Trade Postman Collection</a>
- <a href="/downloads/getting-started/coinbase_app.postman_collection.json.json" download target="blank">Coinbase App Postman Collection</a>
- <a href="/downloads/getting-started/cdp_sdk_collection.postman_collection.json" download target="blank">CDP SDK Collection</a>


## Coinbase Developer Platform Collection

### Step 1: Download Postman

If don't have Postman installed, download and install [Postman](https://www.postman.com/downloads/) from their website.

### Step 2: Download and Import Files

1. **Download Collection:**
    - Download the relevant collection from above 

2. **Import Collection into Postman:**
    - Open Postman.
    - Click on **Import** in the upper left corner.
    <img src={require('../assets/images/cdp-postman-import.png').default} width="500" alt="" />
    - Select the downloaded JSON file and import it.

### Step 3: Configure Environment Variables

Once the files are imported, you need to configure your environment variables.

1. **Download Postman Environemnt:**
   - <a href="/downloads/advanced-trade/coinbase_developer_platform.postman_environment.json" download target="blank">Coinbase Developer Platform Postman Environment</a> 
2. **Import Environment into Postman:**
    - Open Postman.
    - Click on the same **Import** button in the upper left corner.
    - Select the downloaded JSON file and import it.

3. **Select the Environment:**
   - In Postman, click on the environment dropdown near the top right of the screen and select "Coinbase Developer Platform Postman Environment".
    <img src={require('../assets/images/cdp-postman-env-2.png').default} width="500" alt="" />
   - Or by using the **Environments** tab on the left bar - Make sure the correct environment is selected by checking the check mark to the 
right of the environment name in Postman.
   <img src={require('../assets/images/cdp-postman-env.png').default} width="500" alt="" />

4. **Set Up Variables:**
   - Click the Environments tab under My Workspace on the left of the screen
   - Select the "Coinbase Developer Platform Postman Environment".
   - Configure the following variables: <br /><br />

   | Variable     | Current value                                                                             |
   | ------------ | ----------------------------------------------------------------------------------------- |
   | `name`       | `"organizations/{ORG_ID}/apiKeys/{KEY_ID}"` (Include quotes)                              |
   | `privateKey` | `"-----BEGIN EC PRIVATE KEY-----\{KEY}\n-----END EC PRIVATE KEY-----\n"` (Include quotes) |

   :::note
   Ensure that the values are entered exactly as shown, including the quotes.
   :::

### Step 4: Authenticate and Test Endpoints

1. **Send Requests:**
   - Navigate to the "Collections" tab in Postman.
   - Expand the "Coinbase Developer Platform Postman Collection".
   - Select any request and click **Send** to test the endpoint.

2. **Check Responses:**
    - Ensure that the responses are as expected.
    - If you encounter any issues, refer to the detailed response messages to understand the problem.






<!-- File: /Users/tinahe/docs/projects/get-started/docs/overview.mdx -->

---
title: "Get Started - Overview"
hide_title: true
sidebar_label: "Overview"
hide_table_of_contents: true
slug: "overview"
---

import GetStartedOverview from "@site/src/components/GetStarted/Overview";

import { Divider } from "@cbhq/cds-web/layout/Divider";
import { TextBody, TextHeadline, TextTitle2 } from "@cbhq/cds-web/typography";
import { Box } from "@cbhq/cds-web/layout/Box";

import QuickstartSection from "@site/src/components/QuickstartSection";
import ProductHeader from "@site/src/components/ProductHeader";

<Box maxWidth={808}>
  <ProductHeader
    title="Get started"
    subtitle="Learn about our CDP APIs and Product APIs"
  />
</Box>

<Divider spacingVertical={5} />

<GetStartedOverview />



<!-- File: /Users/tinahe/docs/projects/get-started/docs/use-sdks.mdx -->

---
title: "Get Started - Use SDKs"
hide_title: true
sidebar_label: "Use SDKs"
hide_table_of_contents: true
slug: "use-sdks"
---

import GetStartedUseSDKs  from "@site/src/components/GetStarted/UseSDKs"
import { Divider } from "@cbhq/cds-web/layout/Divider";
import { TextBody, TextHeadline, TextTitle2 } from "@cbhq/cds-web/typography";
import { Box } from "@cbhq/cds-web/layout/Box";
import ProductHeader from "@site/src/components/ProductHeader";

<Box maxWidth={808}>
  <ProductHeader
    title="Use our SDKs"
    subtitle="To use CDP APIs, learn about our SDKs and get started with your API key"
  />
</Box>

<Divider spacingVertical={5} />

<GetStartedUseSDKs />



<!-- File: /Users/tinahe/docs/projects/get-started/docs/jwt-auth.mdx -->

---
title: "JWT Authentication"
sidebar_label: "JWT Authentication"
slug: "jwt-authentication"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


A JSON Web Token (JWT) is a a secure method of authenticating API calls used by Coinbase Developer Platform.
They combine encryption and access management in a single token, offering a robust security layer compared to traditional API keys.

### Generating a JWT

Regardless of which [code snippet](#code-samples) you use, follow these steps:

1. Replace `key name` and `key secret` with your key name and private key. `key secret` is a multi-line key and newlines must be preserved to properly parse the key. Do this on one line with `\n` escaped newlines, or with a multi-line string.
1. Run the generation script that prints the command `export JWT=...`.
1. Run the generated command to save your JWT. 

  :::caution
  Your JWT expires after 2 minutes, after which all requests are unauthenticated.
  :::

### Code samples

The easiest way to generate a JWT is to use the built-in functions in our SDKs. See the relevant product docs like
[Advanced Trade SDK](/advanced-trade/docs/rest-api-auth), or  [CDP SDK](/cdp-sdk/docs/authentication), 
for examples.
Otherwise, use the code samples below to generate/export a JWT and make an authenticated request.


<Tabs>
<TabItem value="python" label="Python">

1. Install dependencies PyJWT and cryptography.
```
pip install PyJWT
pip install cryptography
    ```
2. In the console, run: `python main.py` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to the environment with `export JWT=$(node main.py)`.

```python
import jwt
from cryptography.hazmat.primitives import serialization
import time
import secrets

key_name     = "organizations/{org_id}/apiKeys/{key_id}"
key_secret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt():
    private_key_bytes = key_secret.encode('utf-8')
    private_key = serialization.load_pem_private_key(private_key_bytes, password=None)

    jwt_payload = {
        'sub': key_name,
        'iss': "cdp",
        'nbf': int(time.time()),
        'exp': int(time.time()) + 120,
    }

    jwt_token = jwt.encode(
        jwt_payload,
        private_key,
        algorithm='ES256',
        headers={'kid': key_name, 'nonce': secrets.token_hex()},
    )

    return jwt_token

def main():
    jwt_token = build_jwt()

    print(f"export JWT={jwt_token}")

if __name__ == "__main__":
    main()

```

</TabItem>
<TabItem value="javascript" label="JavaScript">

1. Install jsonwebtoken.
```
npm install jsonwebtoken
```
2. In the console, run: `node main.js` (or whatever your file name is).
3. Set JWT to that output, or export the JWT to environment with `export JWT=$(node main.js)`.

```javascript
const { sign } = require('jsonwebtoken');
const crypto = require('crypto');

const key_name       = 'organizations/{org_id}/apiKeys/{key_id}';
const key_secret = '-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n';

const algorithm = 'ES256';

const token = sign(
        {
           iss: 'cdp',
           nbf: Math.floor(Date.now() / 1000),
           exp: Math.floor(Date.now() / 1000) + 120,
           sub: key_name,
        },
        key_secret,
        {
           algorithm,
           header: {
              kid: key_name,
              nonce: crypto.randomBytes(16).toString('hex'),
           },
        }
);
console.log('export JWT=' + token);
```

</TabItem>

<TabItem value="typescript" label="TypeScript">
1. Install the JSON Web Token and TypeScript dependencies:

```bash
npm install jsonwebtoken
npm install @types/jsonwebtoken
npm install -g typescript
```

2. Create a TypeScript file named `main.ts` and add the following code:

```typescript
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';

const keyName = 'organizations/{org_id}/apiKeys/{key_id}';
const keySecret = `-----BEGIN EC PRIVATE KEY-----
YOUR PRIVATE KEY
-----END EC PRIVATE KEY-----`;
const algorithm = 'ES256';


const generateJWT = (): string => {
    const payload = {
    iss: 'cdp',
    nbf: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + 120,
    sub: keyName,
    };

    const header = {
    alg: algorithm,
    kid: keyName,
    nonce: crypto.randomBytes(16).toString('hex'),
    };

    return jwt.sign(payload, keySecret, { algorithm, header });
};

const main = () => {
    const token = generateJWT();
    console.log(token);
};

main();
```

3. Compile the TypeScript file to JavaScript:

```bash
tsc main.ts
```

    This will generate a `main.js` file.

4. Run the generated JavaScript file:

```bash
node main.js
```

5. Set the JWT to the output, or export the JWT to the environment with:

```bash
export JWT=$(node main.js)
```

</TabItem>

<TabItem value="go" label="Go">

1. Create a new directory and generate a Go file called `main.go`.
2. Paste the Go snippet below into `main.go`.
3. Run `go mod init jwt-generator` and `go mod tidy` to generate `go.mod` and `go.sum` and manage your dependencies.
4. In the console, run: go run `main.go`.
5. Set your JWT with that output, or export the JWT to environment with `export JWT=$(node main.go)`.

<br />
```go
package main

import (
    "crypto/rand"
    "crypto/x509"
    "encoding/pem"
    "fmt"
    "math"
    "math/big"
    "time"

    log "github.com/sirupsen/logrus"
    "gopkg.in/go-jose/go-jose.v2"
    "gopkg.in/go-jose/go-jose.v2/jwt"
)

const (
    keyName     = "organizations/{org_id}/apiKeys/{key_id}"
    keySecret   = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"
)

type APIKeyClaims struct {
    *jwt.Claims
}

func buildJWT() (string, error) {
    block, _ := pem.Decode([]byte(keySecret))
    if block == nil {
        return "", fmt.Errorf("jwt: Could not decode private key")
    }

    key, err := x509.ParseECPrivateKey(block.Bytes)
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    sig, err := jose.NewSigner(
        jose.SigningKey{Algorithm: jose.ES256, Key: key},
        (&jose.SignerOptions{NonceSource: nonceSource{}}).WithType("JWT").WithHeader("kid", keyName),
    )
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }

    cl := &APIKeyClaims{
        Claims: &jwt.Claims{
            Subject:   keyName,
            Issuer:    "cdp",
            NotBefore: jwt.NewNumericDate(time.Now()),
            Expiry:    jwt.NewNumericDate(time.Now().Add(2 * time.Minute)),
        },
    }
    jwtString, err := jwt.Signed(sig).Claims(cl).CompactSerialize()
    if err != nil {
        return "", fmt.Errorf("jwt: %w", err)
    }
    return jwtString, nil
}

var max = big.NewInt(math.MaxInt64)

type nonceSource struct{}

func (n nonceSource) Nonce() (string, error) {
    r, err := rand.Int(rand.Reader, max)
    if err != nil {
        return "", err
    }
    return r.String(), nil
}

func main() {
    jwt, err := buildJWT()

    if err != nil {
        log.Errorf("error building jwt: %v", err)
    }
    fmt.Println("export JWT=" + jwt)
}
```

</TabItem>
<TabItem value="Ruby" label="Ruby">

1. Install dependencies `JWT` and `OpenSSL`.

```
gem install JWT
gem install OpenSSL
```

2. In the console, run: `ruby main.rb` (or whatever your file name is).
3. Set the JWT to that output, or export the JWT to the environment with `export JWT=$(ruby main.rb)`.

<br />

```ruby
require 'jwt'
require 'openssl'
require 'time'
require 'securerandom'

Key_name = "organizations/{org_id}/apiKeys/{key_id}"
Key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n"

def build_jwt()
    header = {
      typ: 'JWT',
      kid: Key_name,
      nonce: SecureRandom.hex(16)
    }

    claims = {
      sub: Key_name,
      iss: 'cdp',
      aud: ['cdp_service'],
      nbf: Time.now.to_i,
      exp: Time.now.to_i + 120, # Expiration time: 2 minute from now.
    }

    private_key = OpenSSL::PKey::read(Key_secret)
    JWT.encode(claims, private_key, 'ES256', header)
  end


token = build_jwt()
puts token
```

</TabItem>
<TabItem value="php" label="PHP">

1. Add PHP dependencies with Composer (for JWT and environment variable management):

```
composer require firebase/php-jwt
composer require vlucas/phpdotenv
```

2. Run `generate_jwt.php` (or a filename of your choice).

3. Output the JWT to the command line and use a shell script to export it:

```
export JWT=$(php generate_jwt.php)
```

<br />


```php
<?php
require 'vendor/autoload.php';
use Firebase\JWT\JWT;
use \Dotenv\Dotenv;

// Load environment variables
$dotenv = Dotenv::createImmutable(__DIR__);
$dotenv->load();

function buildJwt() {
    $keyName = $_ENV['NAME'];
    $keySecret = str_replace('\\n', "\n", $_ENV['PRIVATE_KEY']);

    $privateKeyResource = openssl_pkey_get_private($keySecret);
    if (!$privateKeyResource) {
        throw new Exception('Private key is not valid');
    }
    $time = time();
    $nonce = bin2hex(random_bytes(16));  // Generate a 32-character hexadecimal nonce
    $jwtPayload = [
        'sub' => $keyName,
        'iss' => 'cdp',
        'nbf' => $time,
        'exp' => $time + 120,  // Token valid for 120 seconds from now
    ];
    $headers = [
        'typ' => 'JWT',
        'alg' => 'ES256',
        'kid' => $keyName,  // Key ID header for JWT
        'nonce' => $nonce  // Nonce included in headers for added security
    ];
    $jwtToken = JWT::encode($jwtPayload, $privateKeyResource, 'ES256', $keyName, $headers);
    return $jwtToken;
}
```

</TabItem>
<TabItem value="java" label="Java">

1. Add Java Dependencies to your project's Maven or Gradle configuration:

```
nimbus-jose-jwt (version 9.39), bcpkix-jdk18on (version 1.78), and java-dotenv (version 5.2.2)
```

2. Compile your Java application to generates a JWT, for example:

```
mvn compile
```

3. Capture and export the JWT output from your Java application to an environment variable:

```
export JWT=$(mvn exec:java -Dexec.mainClass=Main)
```

<br />


```java
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;
import java.security.interfaces.ECPrivateKey;
import java.util.Map;
import java.util.HashMap;
import java.time.Instant;
import java.util.Base64;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.io.StringReader;
import java.security.PrivateKey;
import java.security.Security;
import io.github.cdimascio.dotenv.Dotenv;

public class Main {
    public static void main(String[] args) throws Exception {
        // Register BouncyCastle as a security providerx
        Security.addProvider(new BouncyCastleProvider());

        // Load environment variables
        Dotenv dotenv = Dotenv.load();
        String privateKeyPEM = dotenv.get("PRIVATE_KEY").replace("\\n", "\n");
        String name = dotenv.get("NAME");

        // create header object
        Map<String, Object> header = new HashMap<>();
        header.put("alg", "ES256");
        header.put("typ", "JWT");
        header.put("kid", name);
        header.put("nonce", String.valueOf(Instant.now().getEpochSecond()));

        // create data object
        Map<String, Object> data = new HashMap<>();
        data.put("iss", "cdp");
        data.put("nbf", Instant.now().getEpochSecond());
        data.put("exp", Instant.now().getEpochSecond() + 120);
        data.put("sub", name);

        // Load private key
        PEMParser pemParser = new PEMParser(new StringReader(privateKeyPEM));
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider("BC");
        Object object = pemParser.readObject();
        PrivateKey privateKey;

        if (object instanceof PrivateKey) {
            privateKey = (PrivateKey) object;
        } else if (object instanceof org.bouncycastle.openssl.PEMKeyPair) {
            privateKey = converter.getPrivateKey(((org.bouncycastle.openssl.PEMKeyPair) object).getPrivateKeyInfo());
        } else {
            throw new Exception("Unexpected private key format");
        }
        pemParser.close();

        // Convert to ECPrivateKey
        KeyFactory keyFactory = KeyFactory.getInstance("EC");
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());
        ECPrivateKey ecPrivateKey = (ECPrivateKey) keyFactory.generatePrivate(keySpec);

        // create JWT
        JWTClaimsSet.Builder claimsSetBuilder = new JWTClaimsSet.Builder();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            claimsSetBuilder.claim(entry.getKey(), entry.getValue());
        }
        JWTClaimsSet claimsSet = claimsSetBuilder.build();

        JWSHeader jwsHeader = new JWSHeader.Builder(JWSAlgorithm.ES256).customParams(header).build();
        SignedJWT signedJWT = new SignedJWT(jwsHeader, claimsSet);

        JWSSigner signer = new ECDSASigner(ecPrivateKey);
        signedJWT.sign(signer);

        String sJWT = signedJWT.serialize();
        System.out.println(sJWT);
    }
}
```

</TabItem>
<TabItem value="cpp" label="C++">

1. Install C++ project dependencies like so:

```
apt-get update
apt-get install libcurlpp-dev libssl-dev
git clone https://github.com/Thalhammer/jwt-cpp
cd jwt-cpp
mkdir build && cd build
cmake ..
make
make install
```

2. After you've saved your code to a file name, for example main.cpp, compile the program:

```
g++ main.cpp -o myapp -lcurlpp -lcurl -lssl -lcrypto -I/usr/local/include -L/usr/local/lib -ljwt -std=c++17
```

3. Capture and export the JWT output from your C++ application to an environment variable:

```
export JWT=$(./myapp)
```

<br />


```cpp
#include <iostream>
#include <sstream>
#include <string>
#include <curlpp/cURLpp.hpp>
#include <curlpp/Easy.hpp>
#include <curlpp/Options.hpp>
#include <jwt-cpp/jwt.h>
#include <openssl/evp.h>
#include <openssl/ec.h>
#include <openssl/pem.h>
#include <openssl/rand.h>

std::string create_jwt() {
    // Set request parameters
    std::string key_name = "organizations/{org_id}/apiKeys/{key_id}";
    std::string key_secret = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

    // Generate a random nonce
    unsigned char nonce_raw[16];
    RAND_bytes(nonce_raw, sizeof(nonce_raw));
    std::string nonce(reinterpret_cast<char*>(nonce_raw), sizeof(nonce_raw));

    // Create JWT token
    auto token = jwt::create()
        .set_subject(key_name)
        .set_issuer("cdp")
        .set_not_before(std::chrono::system_clock::now())
        .set_expires_at(std::chrono::system_clock::now() + std::chrono::seconds{120})
        .set_header_claim("kid", jwt::claim(key_name))
        .set_header_claim("nonce", jwt::claim(nonce))
        .sign(jwt::algorithm::es256(key_name, key_secret));

    return token;
};

int main() {
    try {
        std::string token = create_jwt();
        std::cout << "Generated JWT Token: " << token << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
};
```

</TabItem>
<TabItem value="dotnet" label="C#">

1. Create a new console project by running the following command:

```
dotnet new console
```

2. Open the Program.cs file in a text editor or IDE (e.g., Visual Studio Code, Visual Studio, or any text editor). Replace the contents of Program.cs with the provided bellow in the Code Snippet.


3.  Install C# project dependencies like so:

```
dotnet add package Microsoft.IdentityModel.Tokens
dotnet add package System.IdentityModel.Tokens.Jwt
dotnet add package Jose-JWT
```

4.  Build the project by running the following command:

```
dotnet build
```

5.  Run the project by running the following command:

```
dotnet run
```

<br />


```dotnet
// Environment is .NET 6.0 C#

using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;
using Jose;

namespace JwtTest {
    internal class Program {

        static Random random = new Random();

        static void Main(string[] args) {

            string name = "organizations/{org_id}/apiKeys/{key_id}";
            string cbPrivateKey = "-----BEGIN EC PRIVATE KEY-----\nYOUR PRIVATE KEY\n-----END EC PRIVATE KEY-----\n";

            string key = parseKey(cbPrivateKey);
            string token = generateToken(name, key);

            Console.WriteLine($"Token is valid? {isTokenValid(token, name, key)}");

        }


        static string generateToken(string name, string secret) {
             var privateKeyBytes = Convert.FromBase64String(secret); // Assuming PEM is base64 encoded
             using var key = ECDsa.Create();
             key.ImportECPrivateKey(privateKeyBytes, out _);

             var payload = new Dictionary<string, object>
             {
                 { "sub", name },
                 { "iss", "coinbase-cloud" },
                 { "nbf", Convert.ToInt64((DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
                 { "exp", Convert.ToInt64((DateTime.UtcNow.AddMinutes(1) - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds) },
             };

             var extraHeaders = new Dictionary<string, object>
             {
                 { "kid", name },
                 // add nonce to prevent replay attacks with a random 10 digit number
                 { "nonce", randomHex(10) },
                 { "typ", "JWT"}
             };

             var encodedToken = JWT.Encode(payload, key, JwsAlgorithm.ES256, extraHeaders);

            // print token
            Console.WriteLine(encodedToken);
            return encodedToken;
        }

        static bool isTokenValid(string token, string tokenId, string secret) {
            if (token == null)
                return false;

            var key = ECDsa.Create();
            key?.ImportECPrivateKey(Convert.FromBase64String(secret), out _);

            var securityKey = new ECDsaSecurityKey(key) { KeyId = tokenId };

            try {
                var tokenHandler = new JwtSecurityTokenHandler();
                tokenHandler.ValidateToken(token, new TokenValidationParameters {
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = securityKey,
                    ValidateIssuer = false,
                    ValidateAudience = false,
                    ClockSkew = TimeSpan.Zero
                }, out var validatedToken);

                return true;
            } catch {
                return false;
            }
        }

        static string parseKey(string key) {
            List<string> keyLines = new List<string>();
            keyLines.AddRange(key.Split('\n', StringSplitOptions.RemoveEmptyEntries));

            keyLines.RemoveAt(0);
            keyLines.RemoveAt(keyLines.Count - 1);

            return String.Join("", keyLines);
        }


        static string randomHex(int digits) {
            byte[] buffer = new byte[digits / 2];
            random.NextBytes(buffer);
            string result = String.Concat(buffer.Select(x => x.ToString("X2")).ToArray());
            if (digits % 2 == 0)
                return result;
            return result + random.Next(16).ToString("X");
        }

    }
}
```
</TabItem>
</Tabs>

---

## Learn More about JWTs
JWTs are a secure method of authenticating API calls, especially crucial for platforms handling sensitive financial information. They combine encryption and access management in a single token, offering a robust security layer compared to traditional API keys.


At Coinbase, upholding our motto "The most trusted name in Crypto" means ensuring the utmost security in every aspect of our operations. As digital threats evolve, so must our methods of safeguarding user data. This is why we employ JSON Web Tokens (JWTs) for API authentication—a format that not only verifies identity but also encrypts critical information within a secure token framework.

### What is a JSON Web Token (JWT)?
A JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. At Coinbase, JWTs encapsulate the claims in a JSON object that can be digitally signed or encrypted. Each JWT consists of three parts: the Header, the Payload, and the Signature. We’ll dive deeper into each of these below.

<img src={require('../assets/images/cdp-jwt.png').default} width="600" alt="" />

### The Anatomy of a JWT
Understanding the structure of a JSON Web Token (JWT) is key to leveraging its full potential for secure API interactions. A JWT consists of three distinct parts:
- **Header**: This section declares the type of the token, JWT, and the algorithm used for the signature, such as ES256 in Coinbase’s case, which are critical for ensuring the security and integrity of the token.
- **Payload**: Containing claims such as the user’s identity, role, and token expiration time. At Coinbase, this data is crucial for enabling not just authentication but also for ensuring that each transaction aligns with our user’s privileges and security requirements.
- **Signature**: The final component is a cryptographic signature that verifies that the token comes from a trusted source and has not been altered. This ensures that the transaction is both secure and verifiable.
This structure not only ensures compliance with rigorous security standards but also supports transparent and trustworthy transactions across our platform.

### Why Use JWTs for API Authentication?
In the realm of financial transactions, where security cannot be compromised, JWTs offer a sophisticated method for authenticating API calls that goes beyond traditional approaches. At Coinbase, our commitment to being "The most trusted name in Crypto" necessitates a framework that not only enhances security but also efficiently handles the scale and complexity of modern financial systems.

JWTs excel in this environment due to several key features:

- **Improved Security Features**: JWTs provide a robust mechanism for ensuring data integrity and authenticity. By using advanced algorithms for signatures, each token is secured against tampering, crucial for protecting sensitive financial data.
- **Stateless Nature**: Unlike session-based authentication, JWTs do not require server-side storage to verify each request. This statelessness enables our systems to scale dynamically without the overhead of session management, critical in handling high volumes of transactions seamlessly.
- **Detailed Control Over User Permissions and Token Expiration**: JWTs contain detailed claims that specify user roles and access privileges, allowing for fine-grained access control. Furthermore, token expiration is explicitly managed within the JWT, ensuring that permissions are timely and securely revoked when necessary.

These features make JWTs an integral part of our security strategy, ensuring that every API interaction remains secure, scalable, and aligned with our stringent security standards.

:::info

When dealing with APIs across different environments or with multiple endpoints, it’s wise to extract and verify each component of the URI:
    1. **HTTP Method**: Ensure it matches the requirements (e.g., GET, POST).
    2. **Host**: Check if it corresponds to the correct API server (e.g., api.coinbase.com, api.developer.coinbase.com).
    3. **Endpoint Path**: Verify the path that corresponds to the specific API functionality you need (e.g., /api/v3/brokerage/accounts).
:::


### Common Pitfalls and How to Avoid Them

- **Dynamic Parameters**: Passing the HTTP method, and the correctly formatted URL domain and URL path. This would require the variables assigned to these parameters to be dynamic in nature and to be set, at runtime to the API endpoint being queried. 
- **Token Expiration**: manage the token expiration to a timeframe which makes sense for your use-case (ie. adding more time for latency if using a proxy.) For reference, our samples all set the expiration to 120 seconds, or 2 minutes.
- **Format and Import API Keys**: keep original key formatting and import both the name and private key appropriately into the JWT creation file. If running into authentication issues after following all the above steps, consider adding debugging to see what the actual private key and key name resolve to at runtime.

#### Further JWT related reading:
- [Official JWT documentation](https://datatracker.ietf.org/doc/html/rfc7519)
- [JWT.io](http://JWT.io) debugging tool



<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-curl.mdx -->

---
title: "CDP cURL"
sidebar_label: "CDP cURL"
slug: "cdpcurl"
---

[CDP cURL](https://github.com/coinbase/cdpcurl) is a command line tool that allows you to make HTTP requests to all Coinbase API endpoints that leverage CDP API keys.

### How to use CDP cURL

1. Install [cdpcurl](https://github.com/coinbase/cdpcurl) by running:

```bash
brew tap coinbase/cdpcurl
brew install cdpcurl
```
    
    Or Install via Go
```bash
go install github.com/coinbase/cdpcurl@latest
```



2. Use cdpcurl through the command line by passing in the filepath to your CDP API Key JSON file

### Examples 
#### Get account balance of BTC with Sign In With Coinbase API

```
cdpcurl -k ~/Downloads/cdp_api_key.json 'https://api.coinbase.com/v2/accounts/BTC'
```

#### Get the latest price of BTC with Advanced Trading API

```
cdpcurl -k ~/Downloads/cdp_api_key.json 'https://api.coinbase.com/api/v3/brokerage/products/BTC-USDC'
```

#### Create a wallet on Base Sepolia with CDP SDK

```
cdpcurl -k ~/Downloads/cdp_api_key.json -X POST -d '{"wallet": {"network_id": "base-sepolia"}}' 'https://api.developer.coinbase.com/platform/v1/wallets'
```


#### Create an OnRamp user token
```
cdpcurl -X POST 'https://api.developer.coinbase.com/onramp/v1/token' \
-k /tmp/cdp_api_key.json \
-d '{"addresses": [{"address":"0x750EF1D7a0b4Ab1c97B7A623D7917CcEb5ea779C", "blockchains": ["ethereum"]}]}'
```







<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-key-security.mdx -->

---
title: "API Key Security Best Practices"
sidebar_label: "Security Best Practices"
slug: "cdp-key-security"
description: "Best practices to ensure maximum API key security"
---

When using API keys in the Coinbase Developer Portal, it is crucial that you take the necessary steps to securely protect your CDP API keys. Publicly exposing your credentials could result in your account being compromised and / or a loss of funds. 

Here are some best practices you can follow to keep your CDP API keys secure.

### 1. Never embed keys directly in code

Embedding API keys in code increases the risk of accidentally exposing your keys to the public. For example, if you need to share your code, you may forget to remove the keys in your code. Instead, store your keys in environment variables or in files outside of your application source tree.

### 2. Never store keys inside your application's source tree

If you’re storing API keys in files, keep the files outside your application source tree to ensure your keys don’t end up in your source code control system (e.g., GitHub).

### 3. Restrict keys to sources that need them

Restricting your keys to only the sources that need them, reduces impact of a compromised API Key. With the allowlist feature, you can specify IPs or CIDRs that ensure API requests signed with your keys are only honored from the origins (or IPs) that you define.

Steps

1. Click **API keys** on the left side navigation bar.
2. Navigate to the API key you’d like to edit and click **Manage**.
3. Click **Edit Key** and expand **API restrictions**.
4. Add an IP or CIDR under **IP allowlist** and save the changes.

<img src={require('../assets/images/cdp-key-security-allowlist.jpg').default} width="600" alt="" />

### 4. Restrict signatures to certain APIs

If you have multiple APIs enabled in your project, you should restrict usage of certain signatures (JWT tokens) to specific APIs to minimize the risk of replay attacks. You can do so by attaching the API request path as part of the signing body so that the signature can only be used for that specific API.

### 5. Delete unnecessary keys

If you no longer need any API keys, make sure to delete them to minimize your exposure to attack.

Steps

1. Click **API keys** on the left side navigation bar.
2. Navigate to the API key you’d like to edit and click **Manage**.
3. Click **Delete Key**.
4. Copy and paste the the ID associated with the key and click **Delete Key** to confirm.

<img src={require('../assets/images/cdp-key-security-delete.jpg').default} width="600" alt="" />

### 6. Rotate keys periodically

Rotating your keys reduces the risks associated with the same key being compromised. Coinbase Developer uses **asymmetric cryptography** meaning that you will need to create new keys and delete the old keys to get the rotation done.



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/NodeJS/list_webhooks.mdx -->

```typescript
// Return a list of webhooks
let resp = await Webhook.list();
let webhooks = resp.data;

// Get the first webhook from the list of webhooks
let webhook = webhooks[0]

// Iterate over all webhooks created
for (const wh in webhooks) {
    console.log(wh.toString());
}
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/NodeJS/delete_webhook.mdx -->

To delete the webhook, you need to retrieve it first.

```typescript
// Obtain the webhook to be deleted
let webhooks = await Webhook.list();
webhook = webhooks[0];
```

Then you can call the delete method to remove it.

```typescript
await webhook.delete();
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/NodeJS/create_webhook.mdx -->

```typescript
import { Coinbase } from "@coinbase/coinbase-sdk";
Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });
```

This will allow you to [authenticate](/coinbase-sdk/docs/authentication) with the Platform APIs.

### Listening to specific events

You can create a webhook to track these [event types on chain](/get-started/docs/webhooks/event-types).

```typescript
// Import Webhook
import { Webhook } from "@coinbase/coinbase-sdk";

// be sure to update the uri to your webhook url
//
// signature_header is an optional field, it is used for x-webhook-signature header on callbacks
// When your service receives a webhook callback, it needs to verify that the callback originated from Coinbase and has not been tampered with by any third parties.
// The signature_header field allows you to specify a custom signature that will be included in the x-webhook-signature HTTP header of each callback request sent by Coinbase.
let webhook = await Webhook.create({
  networkId: "base-mainnet",
  notificationUri: "https://example.com/callback",
  eventType: "erc20_transfer",
  eventFilters: [{ contract_address: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913" }],
  signatureHeader: "optional-signature-string",
});

console.log(`Webhook successfully created: `, webhook.toString());
```

### Listening to all events for a specific address

To listen to all events for a specific address (e.g., your wallet address),
you can set `from_address` or `to_address` filters in the `event_filters` parameter.
This configuration ensures that you receive callbacks for any ERC-20 token transfer
where the specified address is either the sender or receiver.
:::info
Requesting both `from` AND `to` addresses retrieves all addresses sent from and to your own addresses.
You can configure this with one webhook. To request either `from` OR `to` addresses requires two separate webhooks.
:::

```typescript
// Import Webhook
import { Webhook } from "@coinbase/coinbase-sdk";

let webhook = await Webhook.create({
  networkId: "base-mainnet",
  notificationUri: "https://example.com/callback",
  eventType: "erc20_transfer",
  eventFilters: [
    { from_address: '0xYourAddressHere' }, // Filter events where the specified address is the sender
    { to_address: '0xYourAddressHere' }    // Filter events where the specified address is the receiver
  ],
  signatureHeader: "optional-signature-string",
);

console.log(`Webhook successfully created: `, webhook.toString());
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/NodeJS/update_webhook.mdx -->

To update the notification URI, you need to get access to the webhook first.

```typescript
// Obtain the webhook to be updated
let webhooks = await Webhook.list();
webhook = webhooks[0];
```

Then you can call the update method to update the notification URI.

```typescript
webhook.update('http://example.com/callback2');
```

To modify addresses the webhook listens to, we can use the `eventTypeFilter` parameter. Note that this is a PUT not a PATCH, i.e. we will need to provide all the addresses we want to listen to, as a replacement. Below is an example of how we can append the new address to existing addresses.
```typescript
const etf = webhook.getEventTypeFilter();
const addr: string[] = [...etf?.addresses || []];
addr.push('0x22A766d4464616471b8D3a07DF0B7aFD8Ca3151D');
webhook.update({eventTypeFilter: {addresses: addr}});
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/overview.mdx -->

---
title: Webhooks
sidebar_label: Overview
slug: overview
---

A webhook is a way for one application to deliver data to another application in real-time when a specific event occurs.
Webhooks are typically used to notify external systems of events in real-time, allowing them to react immediately.
This is particularly useful for integrating different services or automating workflows.

## Quickstart

You will need a Notification URL to create a Webhook. If you don't already have a URL,
you can follow [these instructions](https://github.com/coinbase/coinbase-sdk-nodejs/tree/master/quickstart-template/webhook)
to set up a Webhook App for receiving notification events. Once configured, you can use the URL to create a webhook and playaround it.

Here's a [quickstart example](https://github.com/coinbase/coinbase-sdk-nodejs/blob/master/quickstart-template/webhook-wallet-transfer.js) 
that does the transfer and receive events for the transfer.

## Configurations

You can configure webhooks using either the [CDP Portal](/get-started/docs/webhooks/cdp-portal) 
or the [CDP SDK](/get-started/docs/webhooks/cdp-sdk).

### CDP Portal

The CDP Portal provides a user-friendly interface for setting up and managing your webhooks.
Here, you can specify the event types you're interested in, the endpoint URL where you want to receive the data, and any custom headers or security settings required.

### CDP SDK

The CDP SDK allows for programmatic configuration of webhooks.
It offers a flexible API for subscribing to event types, managing webhook endpoints, and handling security concerns.
This is particularly useful for developers looking to integrate webhooks directly into their applications.

### Event Types

You can find the list of event types [here](/get-started/docs/webhooks/event-types).

## Security Tips

For all webhook events, the payload includes a `webhookId`,
which identifies the specific webhook that triggered the event and confirms its origin from Coinbase.

To locate your webhook UUID, navigate to the [portal](https://portal.cdp.coinbase.com/products/webhooks) and view the webhook configuration details.



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Python/list_webhooks.mdx -->

```python
import cdp
gen1 = cdp.Webhook.list() # returns a generator

wh1 = next(gen1)
print(wh1)
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Python/delete_webhook.mdx -->

To delete the webhook, you need to retrieve it first.

```python
import cdp
gen1 = cdp.Webhook.list() # returns a generator

wh1 = next(gen1)
```

Then you can call the delete method to remove it.

```python
wh1.delete()
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Python/create_webhook.mdx -->

```python
import json
import cdp

api_key_file_path = '/your/path/to/cdp_api_key.json'

with open(api_key_file_path, 'r') as file:
    api_key_data = json.load(file)
    api_key_name = api_key_data.get('name')
    api_key_private_key = api_key_data.get('privateKey')

cdp.Cdp.configure(api_key_name, api_key_private_key) # auth
```

This will allow you to [authenticate](/coinbase-sdk/docs/authentication) with the Platform APIs.

### Listening to specific events

You can create a webhook to track these [event types on chain](/get-started/docs/webhooks/event-types).

```python
from cdp.client.models.webhook import WebhookEventType
from cdp.client.models.webhook import WebhookEventFilter

wh1 = Webhook.create(
    notification_uri="https://your-app.com/callback",
    event_type=WebhookEventType.ERC20_TRANSFER,
    event_filters=[WebhookEventFilter(from_address="0x1234...")]
)
print(wh1)
```

### Listening to all events for a specific address

To listen to all events for a specific address (e.g., your wallet address), simply create it on your wallet with a notification URI.
```python
import cdp

wallet1 = Wallet.create()
wh1 = wallet1.create_webhook("https://your-app.com/callback")
print(wh1)
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Python/update_webhook.mdx -->

To update the notification URI, you need to get access to the webhook first.

```python
import cdp
gen1 = cdp.Webhook.list()
wh1 = next(gen1)
```

Then you can call the update method to update the notification URI.

```python
wh1.update(notification_uri='https://your-new-app.com/callback')
```

To modify addresses the webhook listens to, we can use the `eventTypeFilter` parameter. Note that this is a PUT not a PATCH, i.e. we will need to provide all the addresses we want to listen to, as a replacement. Below is an example of how we can append the new address to existing addresses.
```python
from cdp.client.models.webhook_wallet_activity_filter import WebhookWalletActivityFilter
wallet_activity_filter = WebhookWalletActivityFilter(
    addresses= wh1.event_type_filter.addresses + ["0xNewAddress"]
)

event_type_filter = WebhookEventTypeFilter(actual_instance=wallet_activity_filter)
wh1.update(event_type_filter=event_type_filter)



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/discord-bot-demo.mdx -->

---
title: Listening for on-chain transfers with Webhooks
sidebar_label: Discord Bot Demo
slug: discord-bot-demo
---

With webhooks, you can receive real-time updates for events happening on-chain. 
You can set up filters to receive updates only on what matters to your use case. 
Check the [event types](https://docs.cdp.coinbase.com/get-started/docs/webhooks/event-types) supported. 
CDP will push notifications to your webhook endpoint via a POST request with a JSON payload containing the on-chain event data.


## Key Benefits

- Reduce implementation costs: no need to implement a solution from scratch.
- Reliability: you'll always receive a transaction update.
- Easy to integrate: configurable through the CDP Portal interface or our SDKs.


## Example Use Cases

- Bot integrations - you can get the webhook data received and integrate with any tool you want for creating a bot - discord, slack, X (twitter), etc.
- Wallet tracking - you can track the events happening on your customers wallets, so you track their transfers.
- Execute custom actions when a transaction happens on-chain.


## What you'll learn on this guide

In this solution, we're going to integrate with Discord, so every notification you receive from our webhooks will be posted to Discord.

- Create wallets using coinbase SDK
- Setup a webhook listening for transfers happening between those two wallets
- Setup Discord Webhook Bot
- Post a message to Discord whenever you receive that notification on your webhook


## Prerequisites

Before you get started, please follow this [guide](https://docs.cdp.coinbase.com/cdp-sdk/docs/installation) to install CDP SDK.

You'll need:

- A [CDP API Key](https://portal.cdp.coinbase.com/access/api).
- Node.js [environment setup](https://nodejs.org/en/download/package-manager).
- A [Discord account](https://support.discord.com/hc/en-us/articles/360033931551-Getting-Started).


## Setting up Discord to post messages 

Before creating the CDP Webhook, let's first setup the discord bot we're going to use to post the data received from CDP Webhook. 
For this use case, there's no need to create a custom Discord bot. Let's just create a [Discord Webhook](https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks), where 
we can post a message to a channel only doing a **POST** request.

1. First go to a Discord channel where you're admin (or you can also create your [own server](https://support.discord.com/hc/en-us/articles/204849977-How-do-I-create-a-server)) and click on **Edit channel**.

<img src={require('../../assets/images/cdp-webhooks-discord-step-1.png').default} width="400" alt="." />

2. Then, click on **Integrations** on the left menu.

<img src={require('../../assets/images/cdp-webhooks-discord-step-2.png').default} width="500" alt="." />

3. After that, on the Webhooks card, click on **Create Webhook**.

<img src={require('../../assets/images/cdp-webhooks-discord-step-3.png').default} width="500" alt="." />

4. Now, you can change the bot name and channel that your Discord Webhook Bot will post to by clicking on it.

<img src={require('../../assets/images/cdp-webhooks-discord-step-4.1.png').default} width="500" alt="." />

<img src={require('../../assets/images/cdp-webhooks-discord-step-4.2.png').default} width="500" alt="." />

5. On the same page click on `Copy Webhook URL` and keep this URL that we'll need on the next step.

<img src={require('../../assets/images/cdp-webhooks-discord-step-5.png').default} width="500" alt="." />

6. Test it out, remember to replace `DISCORD_WEBHOOK_URL` with the one you’ve copied from Discord.

```
curl -X POST DISCORD_WEBHOOK_URL \
-H 'Content-Type: application/json' \
-d '{"content":"Hello CDP Webhook"}'
```

7. Check your discord channel for the message.

<img src={require('../../assets/images/cdp-webhooks-discord-step-7.png').default} width="400" alt="." />


## Create a https server to receive webhooks updates

:::note
If you wanna skip the step-by-step tutorial, you can clone the [node.js SDK repo on github](https://github.com/coinbase/coinbase-sdk-nodejs) and check [this folder](https://github.com/coinbase/coinbase-sdk-nodejs/tree/master/quickstart-template/discord_tutorial), which contains the code of this tutorial.

You can follow that folder's README on instructions on how to run it.
:::

You need to set up a https server to receive the api calls made by CDP webhooks. 
In this example we're going to use node.js and express to create a server. 

Start by creating an empty folder and then set up your node.js project using npm with the following command (remember to setup your [Node.js environment](#prerequisites)):

```
npm init -y; npm pkg set type="module";
```

Then, create `app.js` file inside the same folder:

```
touch app.js
```

Let's now install the project dependencies:

```
npm install axios express
``` 

Once installed you’ll see it in your **package.json** file:

```json title="package.json"
{
  ...
  "dependencies": {
    "axios": "^1.7.7",
    "express": "^4.21.1"
  }
  ...
}
```


Paste below code into the `app.js` file from the example project and replace the `PUT_YOUR_DISCORD_URL_HERE` with the URL you copied from the last step.


```JavaScript title="app.js"
import express from 'express'
import axios from 'axios'

const app = express();
app.use(express.json());

app.post("/", (req, res) => {
  const data = req.body;
  const discordWebhookUrl = 'PUT_YOUR_DISCORD_URL_HERE'

  let messageContent = 'A new ' + data.eventType + ' event was received from the webhook: \n```'
  messageContent += JSON.stringify(data, null, 2)
  messageContent += '```\n'
  messageContent += `Data received at ${new Date().toLocaleString("en-US")}`

  const postData = {
    content: messageContent,
  }
  axios.post(discordWebhookUrl, postData).then(() => console.log('Successfully called discord.')).catch(console.log);

  res.sendStatus(200);
});


const PORT = 3000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

```

Then start the webhook app for listening for webhook events and forwarding it to the discord server. 

```
node app.js
```

Note that your server will be listening on your localhost port 3000.

<img src={require('../../assets/images/cdp-webhooks-discord-server-3000.png').default} width="500" alt="." />

Now, since your server is listening on localhost, you need to make it accessible from the internet. 
You can use tools like [Pinggy](https://pinggy.io/) and [Ngrok](https://ngrok.com/our-product/secure-tunnels) to set up this tunneling. 
What these services do is create a secure tunnel from your localhost to their server and expose your server running on localhost:3000 through a public address they'll provide. 

In this example, let's use Pinggy to expose port 3000 from your localhost, run the following command in a new terminal:

```
ssh -p 443 -R0:localhost:3000 -L4300:localhost:4300 a.pinggy.io
```

After running the command, you'll see an output similar to below:

<img src={require('../../assets/images/cdp-webhooks-discord-pinggy.png').default} width="700" alt="." />

The HTTPS URL you see on the above output is the one you should use when creating your CDP Webhook on the next step.


## Creating Wallets and Webhooks

On the same folder you created your app above, let's now use coinbase SDK to do a transfer between two wallets and a webhook listening for that transfer.

Let's install the coinbase SDK as a dependency:

:::note

Make sure that these are installed in the same folder as your app.js folder.

:::

```
npm install @coinbase/coinbase-sdk
```

Once installed you’ll see it in your **package.json** file:

```json title="package.json"
{
  ...
  "dependencies": {
    "@coinbase/coinbase-sdk": "^0.9.1",
    "axios": "^1.7.7",
    "express": "^4.21.1"
  }
  ...
}
```

After you installed the SDK, lets create a new file on the project:

```
touch webhook-transfer.js
```

Then, the first thing you'll need is to create a [CDP API key](https://portal.cdp.coinbase.com/access/api). 

You can now copy below code and paste into the empty file we just created: 


```JavaScript title="webhook-transfer.js"
import { Coinbase, Webhook, Wallet } from "@coinbase/coinbase-sdk";

// Change this to the path of your API key file downloaded from CDP portal.
Coinbase.configureFromJson({ filePath: "~/Downloads/cdp_api_key.json" });

const webhookNotificationUri = 'YOUR_NOTIFICATION_URL'


//You should now, create a couple of wallets:
let myWallet = await Wallet.create();
let anotherWallet = await Wallet.create();

// After you created the wallet, let's add some USDC funds to it:
await myWallet.faucet(Coinbase.assets.Usdc);

// Now use below code to get wallets addresses so we can use it for adding it to the webhook filter.
let myWalletAddress = await myWallet.getDefaultAddress();
let anotherWalletAddress = await anotherWallet.getDefaultAddress();
const myWalletAddressId = myWalletAddress.getId();
const anotherWalletAddressId = anotherWalletAddress.getId();

await Webhook.create({
  networkId: Coinbase.networks.BaseSepolia,
  notificationUri: webhookNotificationUri,
  eventType: 'erc20_transfer',
  eventFilters: [{
    from_address: myWalletAddressId,
    to_address: anotherWalletAddressId,
  }],
});

// Sometimes funds take a few seconds to be available on the wallet, so let's wait 3 secs
await sleep(3000)

// For testing this above example, let's now create a transfer between both wallets we created:
// Create transfer from myWallet to anotherWallet
const transfer = await myWallet.createTransfer({
  amount: 0.0001,
  assetId: Coinbase.assets.Usdc,
  destination: anotherWallet,
  gasless: true, // for USDC, you can add gasless flag, so you don't need to add ETH funds for paying for gas fees
});

// Wait for the transfer to complete or fail on-chain
await transfer.wait({
  intervalSeconds: 1, // check for transfer completion each 1 second
  timeoutSeconds: 30, // keep checking for 30 seconds
});
console.log('Transfer was successful: ', transfer.toString());


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

:::note

Make sure your [API key](https://portal.cdp.coinbase.com/access/api) downloaded matches the path on the code you just copied:
`Coinbase.configureFromJson({ filePath: "~/Downloads/cdp_api_key.json" });`

:::


:::note

Don't forget to replace `YOUR_NOTIFICATION_URL` with the Pinggy (or similar) URL you got on the previous step. Make sure you copy the HTTPS url (webhook notification URL only supports HTTPS).

:::

What the above code does is to create two wallets, a webhook to listen, add some funds to the wallet and then do a transfer between the two wallets, so we can see the webhook working.

Now let's run the above script with the command:

```
node webhook-transfer.js
```

This is one example of webhook payload that will be sent to your server for a transfer like we just did above:

```json
{
  "blockHash": "0xe6e5e8dc73b72454110eb9c14e9a813512062df15f18a706e5c19e9d05ac8745",
  "blockNumber": "16708604",
  "blockTime": "2024-10-17T17:18:16.000Z",
  "contractAddress": "0x036cbd53842c5426634e7929541ec2318f3dcf7e",
  "eventType": "erc20_transfer",
  "from": "0xaa3e1c49f90e5a1773820d12d261b86926628dcf",
  "logIndex": "85",
  "network": "base-sepolia",
  "to": "0x959e68c68c74c1824e5484dc2075a9b7ce237689",
  "transactionHash": "0x7f4226de92f5a3b5980f764d520896159e9115533d9b228737fe1f3725c9ce61",
  "transactionIndex": "38",
  "value": "100",
  "webhookId": "671146d07e7aa61a83279862"
}
```

Note that it may take a few seconds to a couple minutes for the transaction to be reflected, but after you receive that payload on your express https server, you should be able to see the message posted on Discord like below:

<img src={require('../../assets/images/cdp-webhooks-discord-message-posted.png').default} width="700" alt="." />

All notifications received on your webhook will now be posted to your discord channel!



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/event-types.mdx -->

---
title: Webhook Event Types
sidebar_label: Event Types
slug: event-types
---

## Event Types

The following table shows the supported webhook event types that you will receive:

| Event Types                    |    Event Type Labels          | Description                                                                                                    |
|--------------------------------|-------------------------------|----------------------------------------------------------------------------------------------------------------|
| **ERC20 Transfers**            |    `erc20_transfer`           | This event is triggered when an ERC20 token transfer occurs on the blockchain.                                 |
| **ERC721 Transfers**           |    `erc721_transfer`          | This event is triggered when an ERC721 token (NFT) is transferred.                                             |
| **ERC1155 Transfers Single**   |    `erc1155_transfer_single`  | This event is triggered when an ERC1155 token is transferred.                                                  |
| **ERC1155 Transfers Batch**    |    `erc1155_transfer_batch`   | This event is triggered when ERC1155 tokens are transferred in batch.                                          |
| **Transactions**               |    `transaction`              | This event is triggered when a native blockchain token is transferred.                                         |

If you're interested in tracking additional event types, 
please reach out to us on [Discord](https://discord.gg/zR8FKSsxxX) for assistance.

Note that configuration event types may be different from the event types that you will receive.

Special configuration event types are:

| Configuration Event Types      |    Event Type Labels          | Description                                                                                                                |
|--------------------------------|-------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| **Wallet Activity**            |    `wallet_activity`          | This event is triggered when any of the transfer type events (e.g. ERC20, ERC721, Native) occurs on the blockchain.        |
| **Smart Contract Activity**    |    `smart_contract_activity`  | (coming soon) This event is triggered when any of the smart contract type events occurs from the smart contract address.   |

### ERC20 Transfers

#### Sample Event

```
{
    "webhookId": "66b2ac80e8abf9381a162137",
    "eventType": "erc20_transfer",
    "network": "base-mainnet",
    "blockHash": "0x60036a0f0454582f60cab6f98990cdcca519b87dd63d5ec01724ce2337129abc",
    "blockNumber": "18452087",
    "blockTime": "2024-08-15T03:45:21.000Z",
    "transactionHash": "0x7f7bc473ee2b94792f033f4d12d0d4d057dab0b5b4f32cd058ad95ee652af948",
    "transactionIndex": "16",
    "logIndex": "46",
    "contractAddress": "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
    "from": "0xbb8b2da5db110ad625270061e81987ce342677c3",
    "to": "0xfb2139331532e3ee59777fbbcb14af674f3fd671",
    "value": "46737096"
}
```

#### Event Fields

| Field             | Description                                                                            |
|-------------------|----------------------------------------------------------------------------------------|
| `webhookId`       | Unique identifier for the webhook that triggered this event.                           |
| `eventType`       | Type of event, in this case, an ERC-20 token transfer.                                 |
| `network`         | Blockchain network where the event occurred, e.g., `base-mainnet`.                     |
| `blockHash`       | Hash of the block containing the transaction.                                          |
| `blockNumber`     | Number of the block containing the transaction.                                        |
| `blockTime`       | Timestamp when the block was mined.                                                    |
| `transactionHash` | Hash of the transaction that triggered the event.                                      |
| `transactionIndex`| Position of the transaction within the block.                                          |
| `logIndex`        | Position of the event log within the transaction.                                      |
| `contractAddress` | Address of the ERC-20 token contract.                                                  |
| `from`            | Address of the sender in the token transfer.                                           |
| `to`              | Address of the recipient in the token transfer.                                        |
| `value`           | Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum). |


### ERC721 Transfers

#### Sample Event

```
{
    "webhookId": "66bd79d0b9c200eae1a43165",
    "eventType": "erc721_transfer",
    "network": "base-mainnet",
    "blockHash": "0x66efeaf6eb207b040eb82de0153e3349f95c048075ba38904bdc4cff1524c656",
    "blockNumber": "18452423",
    "blockTime": "2024-08-15T03:56:33.000Z",
    "transactionHash": "0x940db3006449456b386397ab42114134d745d2876196226444601670f3e99db8",
    "transactionIndex": "65",
    "logIndex": "351",
    "contractAddress": "0xdaae4a2834cae00ae3af763df9d55e6c91f7a6bc",
    "from": "0x0000000000000000000000000000000000000000",
    "to": "0x0844b27efc14059029110d1b2aa6fdcd4536e60c",
    "tokenId": "350746"
}
```

#### Event Fields

| Field             | Description                                                        |
|-------------------|--------------------------------------------------------------------|
| `webhookId`       | Unique identifier for the webhook that triggered this event.       |
| `eventType`       | Type of event, in this case, an ERC-721 token transfer.            |
| `network`         | Blockchain network where the event occurred, e.g., `base-mainnet`. |
| `blockHash`       | Hash of the block containing the transaction.                      |
| `blockNumber`     | Number of the block containing the transaction.                    |
| `blockTime`       | Timestamp when the block was mined.                                |
| `transactionHash` | Hash of the transaction that triggered the event.                  |
| `transactionIndex`| Position of the transaction within the block.                      |
| `logIndex`        | Position of the event log within the transaction.                  |
| `contractAddress` | Address of the ERC-721 token contract.                             |
| `from`            | Address of the sender in the token transfer.                       |
| `to`              | Address of the recipient in the token transfer.                    |
| `tokenId`         | Unique identifier of the NFT being transferred.                    |


### ERC1155 Transfers Single

#### Sample Event

```
{
    "webhookId": "66bd79d0b9c200eae1a43165",
    "eventType": "erc1155_transfer_single",
    "network": "base-mainnet",
    "contractAddress": "0xab39a8b6801b0b6aa20e9a1953c861ec0a57d175",
    "blockHash": "0x351bd04dfe350fca186cd47080220283a75d07018ed251748a4ad19e7f327caf",
    "blockNumber": 20305354,
    "blockTime": "2024-09-27T21:16:40.000Z",
    "transactionHash": "0xa02b282ecccca77febe1abbbd0e6b13bbf2ff30b36d53e968cb4d2399f22d904",
    "transactionIndex": 63,
    "logIndex": 221,
    "id": 30014,
    "value": 1,
    "operator": "0xd7def291ec916b2e25562711dd3161ea2317638f",
    "from": "0x10db590ffa5b7bc46cffbd436180e01b6c5c0af6",
    "to": "0x4a9ab171e31daff484c70921f2f5e89a8fe12f59",
}
```

#### Event Fields

| Field             | Description                                                                                                                                                                                                                                                                                      |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `webhookId`       | Unique identifier for the webhook that triggered this event.                                                                                                                                                                                                                                     |
| `eventType`       | Type of event, in this case, an ERC-721 token transfer.                                                                                                                                                                                                                                          |
| `network`         | Blockchain network where the event occurred, e.g., `base-mainnet`.                                                                                                                                                                                                                               |
| `contractAddress` | Address of the ERC-721 token contract.                                                                                                                                                                                                                                                           |
| `blockHash`       | Hash of the block containing the transaction.                                                                                                                                                                                                                                                    |
| `blockNumber`     | Number of the block containing the transaction.                                                                                                                                                                                                                                                  |
| `blockTime`       | Timestamp when the block was mined.                                                                                                                                                                                                                                                              |
| `transactionHash` | Hash of the transaction that triggered the event.                                                                                                                                                                                                                                                |
| `transactionIndex`| Position of the transaction within the block.                                                                                                                                                                                                                                                    |
| `logIndex`        | Position of the event log within the transaction.                                                                                                                                                                                                                                                |
| `id`              | Unique identifier of the ERC1155 token being transferred.                                                                                                                                                                                                                                        |
| `value`           | Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).                                                                                                                                                                                                           |
| `operator`        | The address that initiated the transfer. This can be the same as the from address if the transfer is initiated directly by the token holder. Alternatively, it could be a smart contract or another address that has been granted permission to perform transfers on behalf of the from address. |
| `from`            | The address that currently owns the tokens being transferred.                                                                                                                                                                                                                                    |
| `to`              | Address of the recipient in the token transfer.                                                                                                                                                                                                                                                  |


### ERC1155 Transfers Batch

#### Sample Event

```
{
    "webhookId": "66bd79d0b9c200eae1a43165",
    "eventType": "erc1155_transfer_batch",
    "network": "base-mainnet",
    "contractAddress": "0xab39a8b6801b0b6aa20e9a1953c861ec0a57d175",
    "blockHash": "0x351bd04dfe350fca186cd47080220283a75d07018ed251748a4ad19e7f327caf",
    "blockNumber": 20305354,
    "blockTime": "2024-09-27T21:16:40.000Z",
    "transactionHash": "0xa02b282ecccca77febe1abbbd0e6b13bbf2ff30b36d53e968cb4d2399f22d904",
    "transactionIndex": 63,
    "logIndex": 221,
    "ids": [30014, 30015],
    "values": [1, 1],
    "operator": "0xd7def291ec916b2e25562711dd3161ea2317638f",
    "from": "0x10db590ffa5b7bc46cffbd436180e01b6c5c0af6",
    "to": "0x4a9ab171e31daff484c70921f2f5e89a8fe12f59",
}
```

#### Event Fields

| Field             | Description                                                                                                                                                                                                                                                                                      |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `webhookId`       | Unique identifier for the webhook that triggered this event.                                                                                                                                                                                                                                     |
| `eventType`       | Type of event, in this case, an ERC-721 token transfer.                                                                                                                                                                                                                                          |
| `network`         | Blockchain network where the event occurred, e.g., `base-mainnet`.                                                                                                                                                                                                                               |
| `contractAddress` | Address of the ERC-721 token contract.                                                                                                                                                                                                                                                           |
| `blockHash`       | Hash of the block containing the transaction.                                                                                                                                                                                                                                                    |
| `blockNumber`     | Number of the block containing the transaction.                                                                                                                                                                                                                                                  |
| `blockTime`       | Timestamp when the block was mined.                                                                                                                                                                                                                                                              |
| `transactionHash` | Hash of the transaction that triggered the event.                                                                                                                                                                                                                                                |
| `transactionIndex`| Position of the transaction within the block.                                                                                                                                                                                                                                                    |
| `logIndex`        | Position of the event log within the transaction.                                                                                                                                                                                                                                                |
| `ids`             | Array of unique identifier of the ERC1155 tokens being transferred.                                                                                                                                                                                                                              |
| `values`          | Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).                                                                                                                                                                                                           |
| `operator`        | The address that initiated the transfer. This can be the same as the from address if the transfer is initiated directly by the token holder. Alternatively, it could be a smart contract or another address that has been granted permission to perform transfers on behalf of the from address. |
| `from`            | The address that currently owns the tokens being transferred.                                                                                                                                                                                                                                    |
| `to`              | Address of the recipient in the token transfer.                                                                                                                                                                                                                                                  |


### Transactions

#### Sample Event

```
{
    "webhookId": "66bd79d0b9c200eae1a43165",
    "eventType": "transaction",
    "network": "base-mainnet",
    "transactionHash": "0x940db3006449456b386397ab42114134d745d2876196226444601670f3e99db8",
    "transactionIndex": "65",
    "blockHash": "0x351bd04dfe350fca186cd47080220283a75d07018ed251748a4ad19e7f327caf",
    "blockNumber": 20305354,
    "blockTime": "2024-09-27T21:16:40.000Z",
    "from": "0x10db590ffa5b7bc46cffbd436180e01b6c5c0af6",
    "to": "0x4a9ab171e31daff484c70921f2f5e89a8fe12f59",
    "nonce": 300487,
    "value": 0,
    "valueString": "0",
    "gas": 40000,
    "gasPrice": 52298,
    "input": "0x0101491057b2af47aa7757bc5d8611a6ac25417f6ad3d003020000000000000000000000000000000"
    "transactionType": 2,
    "maxFeePerGas": 300,
    "maxPriorityFeePerGas": 19922,
    "priorityFeePerGas": 19938,
    "cumulativeGasUsed": 12,
    "gasUsed": 1,
    "effectiveGasPrice": 23,
    "contractAddress": "0xab39a8b6801b0b6aa20e9a1953c861ec0a57d175",
    "logsBloom": "0x0000000000000000000000000000000000000000000000",
    "root": "",
    "type": 2,
    "status": 1,
    "l1GasUsed": 3456,
    "l1GasPrice": 2312310923,
    "l1Fee": 1231,
    "l1FeeScalar": "",
}
```

#### Event Fields

| Field                  | Description                                                                                                                                                                                                                                                                                      |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `webhookId`            | Unique identifier for the webhook that triggered this event.                                                                                                                                   |
| `eventType`            | Type of event, in this case, a native token (ether) transfer on base.                                                                                                                          |
| `network`              | Blockchain network where the event occurred, e.g., `base-mainnet`.                                                                                                                             |
| `transactionHash`      | Hash of the transaction that triggered the event.                                                                                                                                              |
| `transactionIndex`     | Position of the transaction within the block.                                                                                                                                                  |
| `blockHash`            | Hash of the block containing the transaction.                                                                                                                                                  |
| `blockNumber`          | Number of the block containing the transaction.                                                                                                                                                |
| `blockTime`            | Timestamp when the block was mined.                                                                                                                                                            |
| `from`                 | The address that currently owns the tokens being transferred.                                                                                                                                  |
| `to`                   | Address of the recipient in the token transfer.                                                                                                                                                |
| `nonce`                | a number that represents the count of transactions sent from a given address                                                                                                                   |
| `value`                | Amount of tokens transferred, typically in the smallest unit (e.g., wei for Ethereum).                                                                                                         |
| `valueString`          | String representation of value                                                                                                                                                                 |
| `gas`                  | Gas fee paid to execute this transaction                                                                                                                                                       |
| `gasPrice`             | The amount of Ether you are willing to pay per unit of computational work                                                                                                                      |
| `input`                | An optional field used to send additional information to smart contracts                                                                                                                       |
| `transactionType`      | Transaction type specifies the format and features of the transaction. Common types include Legacy (Type 0) with a single gas price, EIP-2930 (Type 1) for access lists, and EIP-1559 (Type 2) |
| `maxFeePerGas`         | Maximum amount a sender is willing to pay per gas unit                                                                                                                                         |
| `maxPriorityFeePerGas` | Maximum tip the sender is willing to offer to miners/validators to prioritize their transaction                                                                                                |
| `priorityFeePerGas`    | Tip the sender offers to miners/validators to prioritize their transaction                                                                                                                     |
| `cumulativeGasUsed`    | The total amount of gas used by all transactions in a block up to and including the current transaction                                                                                        |
| `gasUsed`              | Actual amount of gas consumed to execute that specific transaction                                                                                                                             |
| `effectiveGasPrice`    | Actual gas price paid per unit of gas                                                                                                                                                          |
| `contractAddress`      | Address of the ERC-721 token contract.                                                                                                                                                         |
| `logsBloom`            | A compressed representation of all logs generated in a block                                                                                                                                   |
| `root`                 | The state root hash of the blockchain's global state after the transaction is processed                                                                                                        |
| `type`                 | the format and features of the transaction. Common types include Legacy (Type 0) with a single gas price, EIP-2930 (Type 1) for access lists, and EIP-1559 (Type 2)                            |
| `status`               | Indicates whether the transaction was successful (1) or failed (0) after it is processed                                                                                                       |
| `l1GasUsed`            | The amount of Layer 1 (Ethereum mainnet) gas consumed for posting transaction data to the main chain. It's a measure of the cost for L2 to L1 communication                                    |
| `l1GasPrice`           | Cost per gas unit on the Ethereum mainnet (Layer 1) for posting transaction data from Layer 2                                                                                                  |
| `l1Fee`                | Total cost paid to cover Layer 1 (Ethereum mainnet) gas fees for posting and finalizing transaction data from Layer 2                                                                          |
| `l1FeeScalar`          | A multiplier used to adjust the base L1 fee to account for additional overhead or to incentivize certain behaviors                                                                             |




<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/cdp-sdk.mdx -->

---
title: Webhook SDK
sidebar_label: CDP SDK
slug: cdp-sdk
description: "Manage webhooks in Coinbase Developer Platform SDK"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import TypescriptCreateWebhook from './NodeJS/create_webhook.mdx';
import RubyCreateWebhook from './Ruby/create_webhook.mdx';
import PythonCreateWebhook from './Python/create_webhook.mdx';
import TypescriptListWebhooks from './NodeJS/list_webhooks.mdx';
import RubyListWebhooks from './Ruby/list_webhooks.mdx';
import PythonListWebhooks from './Python/list_webhooks.mdx';
import TypescriptUpdateWebhook from './NodeJS/update_webhook.mdx';
import RubyUpdateWebhook from './Ruby/update_webhook.mdx';
import PythonUpdateWebhook from './Python/update_webhook.mdx';
import TypescriptDeleteWebhook from './NodeJS/delete_webhook.mdx';
import RubyDeleteWebhook from './Ruby/delete_webhook.mdx';
import PythonDeleteWebhook from './Python/delete_webhook.mdx';

The CDP SDK allows you to create webhooks and receive onchain notifications within minutes.
In this document, you will learn how to create a webhook, list created webhooks,
update a webhook, and delete webhooks.

You can also configure webhooks via [CDP Portal](/get-started/docs/webhooks/cdp-portal).

To learn more about webhook configuration options or event types,
please follow this [document](/get-started/docs/webhooks/overview).

## What You'll Learn

- How to create a webhook
- How to list webhooks
- How to update a webook
- How to delete a webhook

## Prerequisites

Before you get started, please follow this [guide](/cdp-sdk/docs/installation) to install CDP SDK.

## Creating a Webhook

To start, [create a CDP API key](https://portal.cdp.coinbase.com/access/api).
Then, initialize the CDP SDK by passing your downloaded API key file,
and create a Webhook.

You can create a webhook to track ERC20, ERC721 or ERC 1155 transfer events as well as transaction events.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptCreateWebhook />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyCreateWebhook />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonCreateWebhook />
    </TabItem>
</Tabs>

## List Webhooks

You can view the list of webhooks that you've configured.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptListWebhooks />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyListWebhooks />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonListWebhooks />
    </TabItem>
</Tabs>

## Update a Webhook

You can update the notification URI of the created webhook.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptUpdateWebhook />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyUpdateWebhook />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonUpdateWebhook />
    </TabItem>
</Tabs>

## Delete a Webhook

You can remove webhooks that are no longer needed.

<Tabs  groupId="programming-language">
    <TabItem value="Typescript" label="Typescript" default>
        <TypescriptDeleteWebhook />
    </TabItem>
    <TabItem value="Ruby" label="Ruby">
        <RubyDeleteWebhook />
    </TabItem>
    <TabItem value="Python" label="Python">
        <PythonDeleteWebhook />
    </TabItem>
</Tabs>



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/cdp-portal.mdx -->

---
title: Webhook Portal
sidebar_label: CDP Portal
slug: cdp-portal
description: "Manage webhooks in Coinbase Developer Platform Portal"
---

Webhooks allow you to receive data in response to specific events as they occur within your CDP account. 
In the CDP Portal you can create a webhook by adding a webhooks endpoint that you’d like data to be sent to 
and specifying the specific event type to listen to.

You can also configure webhooks via [CDP SDK](/cdp-sdk/docs/webhooks/cdp-sdk).

To learn more about webhook configuration options or event types, 
please follow this [document](/get-started/docs/webhooks/overview).

## Creating a webhook

1. Navigate to the [Webhooks tab](https://portal.cdp.coinbase.com/products/webhooks) in the Coinbase Developer Platform.
2. Click the Create Webhook button.
3. Add a webhook URL.
4. Specify the specific event type you’d like to listen to. (note that wallet activity allows you to listen to all transfer event types)
5. Click create.

<img src={require('../../assets/images/cdp-webhooks-create.png').default} width="600" alt="To create a webhook, click Create Webhook button." />

## Activating or Deactivating a webhook

You can activate or deactivate a webhook by clicking the switch icon on the webhook card.

<img src={require('../../assets/images/cdp-webhooks-activate.png').default} width="300" alt="To activate or deactivate a webhook, click the switch icon on the webhook card." />




<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Ruby/list_webhooks.mdx -->

```ruby
# List webhooks returns enumerator
webhooks = Coinbase::Webhook.list

# Get the first webhook from the list of webhooks
webhook = Coinbase::Webhook.list.first

# Iterate over all webhooks created. This will lazily fetch webhooks from the server.
Coinbase::Webhook.list.each do |webhook|
  puts webhook
end

# Return array of all webhooks. This will paginate and fetch all webhooks.
Coinbase::Webhook.list.to_a
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Ruby/delete_webhook.mdx -->

To delete the webhook, you need to get retrieve it first.

```ruby
webhook = Coinabse::Wallet.list.first
```

Then you can call the delete method to remove it.

```ruby
webhook.delete
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Ruby/create_webhook.mdx -->

```ruby
Coinbase.configure_from_json('~/Downloads/cdp_api_key.json')

puts "CDP SDK has been successfully configured from JSON file."
```

This will allow you to [authenticate](/coinbase-sdk/docs/authentication) with the Platform APIs.

### Listening to specific events

You can create a webhook to track ERC-20 transfers for a specific contract address.

```ruby
# be sure to update notification_uri to your webhook url
#
# signature_header is an optional field, it is used for x-webhook-signature header on callbacks
# When your service receives a webhook callback, it needs to verify that the callback originated from Coinbase and has not been tampered with by any third parties. 
# The signature_header field allows you to specify a custom signature that will be included in the x-webhook-signature HTTP header of each callback request sent by Coinbase.
Coinbase::Webhook.create(
  network_id: 'base-mainnet',
  notification_uri: 'https://example.com/callback',
  event_type: 'erc20_transfer',
  event_filters: [{ contract_address: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913' }],
  signature_header: 'optional-signature-string'
)
```

### Listening to all events for a specific address

To listen to all ERC-20 transfer events for a specific address (e.g., your wallet address), 
you can set `from_address` or `to_address` filters in the `event_filters` parameter. 
This configuration ensures that you receive callbacks for any ERC-20 token transfer 
where the specified address is either the sender or receiver.

```ruby
Coinbase::Webhook.create(
  network_id: 'base-mainnet',
  notification_uri: 'https://example.com/callback',
  event_type: 'erc20_transfer',
  event_filters: [
    { from_address: '0xYourAddressHere' }, # Filter events where the specified address is the sender
    { to_address: '0xYourAddressHere' }    # Filter events where the specified address is the receiver
  ],  signature_header: 'optional-signature-string'
)
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/webhooks/Ruby/update_webhook.mdx -->

To update the notification URI, you need to get access to the webhook first.

```ruby
webhook = Coinabse::Wallet.list.first
```

Then you can call the update method to update the notification URI. We currently only support notification URI updates.

```ruby
webhook.update(notification_uri: 'http://example.com/callback2')
```

To modify addresses the webhook listens to
```ruby
webhook.update(eventTypeFilter: {addresses:["0x40A28c0fCc0BE09400bB89CdF556Cd8C4eF1c165","0x6f03b3Df22F0C57A4477EEAc3a49c2Bc4EAe2206"]})
```



<!-- File: /Users/tinahe/docs/projects/get-started/docs/cdp-keys.mdx -->

---
title: "CDP API Keys"
sidebar_label: "CDP API Keys"
slug: "cdp-api-keys"
description: "Manage your API keys in Coinbase Developer Platform"
---

Use API keys to authenticate requests to the suite of APIs offered on CDP.

## Key Types

| Type &nbsp; | Usage     | Configuration |
| :--------------------------------  | :---------------------------------------------------------- | :-------------------- | 
| Secret API Keys   | **Server-side:**  Used to securely authenticate server-to-server communication and must be kept private for maximum security.  |  - Custom scopes <br />- IP allowlist |
| Client API Key    | **Client-side:**  Used to identify applications from client-side code (ie, OnchainKit) and used in the RPC endpoint. | - Key rotation with expiration <br />- Domain allowlist |

## Secret API Keys 

### Creating Secret API Keys

1. Navigate to the Coinbase Developer Platform and select [Secret API Keys](https://portal.cdp.coinbase.com/projects/project-id/api-keys) under the **API Keys** tab 
3. Click the **Create API key** button.
4. Enter an API key nickname and click **Create & Download**.
5. Secure your private/public key pair in a safe location.

:::tip
To regenerate an API key, click **Manage** to delete and recreate the key.
:::

<img src={require('../assets/images/cdp-secret-api-keys.png').default} width="600" alt="" />

### IP Allowlist (Optional)
Restrict the use of your Secret API key to specific IPs. Separate each IP with a comma (example: "192.168.45.123, 10.54.213.87").


## Client API Key 

### Rotating the Client API Key
1. Navigate to the Coinbase Developer Platform and select [Client API Key](https://portal.cdp.coinbase.com/projects/project-id/api-keys/client-key) under the **API Keys** tab 
2. Click the **Rotate** button.
3. Select an expiration time for your previous key. This is to ensure you can replace your previous key without any downtime.
4. Click confirm and replace all references to your previous key, including in your RPC endpoint.

<img src={require('../assets/images/cdp-client-api-key.png').default} width="600" alt="" />

### Domain Allowlist
Restrict the use of your Client API key to specific domains by validating the Origin header in API requests. This prevents unauthorized websites from using your key.

*Important Considerations:*
- If domains are allowlisted, any API request without an Origin header will be rejected.
- Allowlisting a parent domain (e.g., example.com) does not automatically include its subdomains (e.g., sub.example.com).
- Wildcards are not supported; each domain must be explicitly specified.


## Secret API Key Best Practices

When using secret API keys in the Coinbase Developer Portal, it is crucial that you take the necessary steps to securely protect them. Publicly exposing your credentials could result in your account being compromised and / or a loss of funds. 

Here are some best practices you can follow to keep your CDP API keys secure.

### 1. Never embed keys directly in code

Embedding secret API keys in code increases the risk of accidentally exposing your keys to the public. For example, if you need to share your code, you may forget to remove the keys in your code. Instead, store your keys in environment variables or in files outside of your application source tree.

### 2. Never store keys inside your application's source tree

If you’re storing secret API keys in files, keep the files outside your application source tree to ensure your keys don’t end up in your source code control system (e.g., GitHub).

### 3. Restrict keys to sources that need them

Restricting your secret API keys to only the sources that need them, reduces impact of a compromised API Key. With the allowlist feature, you can specify IPs or CIDRs that ensure API requests signed with your keys are only honored from the origins (or IPs) that you define.

Steps

1. Navigate to **Secret API keys**.
2. Navigate to the API key you’d like to edit and click **Manage**.
3. Click **Edit Key** and expand **API restrictions**.
4. Add an IP or CIDR under **IP allowlist** and save the changes.

### 4. Restrict signatures to certain APIs

If you have multiple APIs enabled in your project, you should restrict usage of certain signatures (JWT tokens) to specific APIs to minimize the risk of replay attacks. You can do so by attaching the API request path as part of the signing body so that the signature can only be used for that specific API.

### 5. Delete unnecessary keys

If you no longer need any secret API keys, make sure to delete them to minimize your exposure to attack.

Steps

1. Navigate to **Secret API keys**.
2. Navigate to the API key you’d like to edit and click **Manage**.
3. Click **Delete Key**.
4. Copy and paste the the ID associated with the key and click **Delete Key** to confirm.


### 6. Rotate keys periodically

Rotating your secret API keys reduces the risks associated with the same key being compromised. Coinbase Developer Platform uses **asymmetric cryptography** meaning that you will need to create new keys and delete the old keys to get the rotation done.


